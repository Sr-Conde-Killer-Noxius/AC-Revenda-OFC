
.
|-- ACAO_IMEDIATA.md
|-- AI_RULES.md
|-- DIAGNOSTICO_AGENDAMENTOS.md
|-- README.md
|-- add_client_name_snapshot.sql
|-- bun.lock
|-- bun.lockb
|-- components.json
|-- diagnostico_agendamentos.sql
|-- eslint.config.js
|-- gerar_resumo.sh
|-- gerar_resumo_V_360.sh
|-- gerar_resumo_V_final.sh
|-- index.html
|-- package-lock.json
|-- package.json
|-- pnpm-lock.yaml
|-- postcss.config.js
|-- public
|   |-- favicon.ico
|   |-- placeholder.svg
|   `-- robots.txt
|-- rd
|-- resumo_automatico_projeto.txt
|-- src
|   |-- App.tsx
|   |-- assets
|   |-- components
|   |   |-- ProtectedRoute.tsx
|   |   |-- admin
|   |   |   |-- assinantes
|   |   |   |   |-- ConfigureSubscribersModal.tsx
|   |   |   |   |-- SubscriberAutomationRow.tsx
|   |   |   |   |-- SubscriberNotificationDialog.tsx
|   |   |   |   |-- SubscriberPlanDialog.tsx
|   |   |   |   |-- SubscriberTemplateDialog.tsx
|   |   |   |   `-- UpdateSubscriberSubscriptionDialog.tsx
|   |   |   `-- financeiro
|   |   |       `-- AdminFinancialEntryDialog.tsx
|   |   |-- automations
|   |   |   |-- AutomationRow.tsx
|   |   |   `-- ConfigureClients
|   |   |       `-- ConfigureClientsModal.tsx
|   |   |-- clients
|   |   |   |-- ClientDialog.tsx
|   |   |   `-- NotificationDialog.tsx
|   |   |-- connection
|   |   |   `-- WebhookDetailsDialog.tsx
|   |   |-- financeiro
|   |   |   |-- CustomTooltip.tsx
|   |   |   |-- EditFinancialEntryDialog.tsx
|   |   |   |-- ErrorState.tsx
|   |   |   |-- LoadingState.tsx
|   |   |   |-- charts
|   |   |   |   |-- ChartCard.tsx
|   |   |   |   |-- LostClientsByPlanChart.tsx
|   |   |   |   |-- MonthlyRevenueHistoryChart.tsx
|   |   |   |   |-- RevenueByPlanChart.tsx
|   |   |   |   |-- RevenueLast30DaysChart.tsx
|   |   |   |   `-- WeeklyRevenueComparisonChart.tsx
|   |   |   `-- kpis
|   |   |       |-- ChurnAnalysisSection.tsx
|   |   |       |-- KpiCard.tsx
|   |   |       `-- KpiSection.tsx
|   |   |-- layout
|   |   |   |-- AppSidebar.tsx
|   |   |   `-- MainLayout.tsx
|   |   |-- plans
|   |   |   `-- PlanDialog.tsx
|   |   |-- profile
|   |   |   |-- MercadoPagoPaymentModal.tsx
|   |   |   `-- PixPaymentModal.tsx
|   |   |-- templates
|   |   |   `-- TemplateDialog.tsx
|   |   `-- ui
|   |       |-- accordion.tsx
|   |       |-- alert-dialog.tsx
|   |       |-- alert.tsx
|   |       |-- aspect-ratio.tsx
|   |       |-- avatar.tsx
|   |       |-- badge.tsx
|   |       |-- breadcrumb.tsx
|   |       |-- button.tsx
|   |       |-- calendar.tsx
|   |       |-- card.tsx
|   |       |-- carousel.tsx
|   |       |-- chart.tsx
|   |       |-- checkbox.tsx
|   |       |-- collapsible.tsx
|   |       |-- command.tsx
|   |       |-- context-menu.tsx
|   |       |-- dialog.tsx
|   |       |-- drawer.tsx
|   |       |-- dropdown-menu.tsx
|   |       |-- form.tsx
|   |       |-- hover-card.tsx
|   |       |-- input-otp.tsx
|   |       |-- input.tsx
|   |       |-- label.tsx
|   |       |-- menubar.tsx
|   |       |-- navigation-menu.tsx
|   |       |-- pagination.tsx
|   |       |-- popover.tsx
|   |       |-- progress.tsx
|   |       |-- radio-group.tsx
|   |       |-- resizable.tsx
|   |       |-- scroll-area.tsx
|   |       |-- select.tsx
|   |       |-- separator.tsx
|   |       |-- sheet.tsx
|   |       |-- sidebar.tsx
|   |       |-- skeleton.tsx
|   |       |-- slider.tsx
|   |       |-- sonner.tsx
|   |       |-- switch.tsx
|   |       |-- table.tsx
|   |       |-- tabs.tsx
|   |       |-- textarea.tsx
|   |       |-- toggle-group.tsx
|   |       |-- toggle.tsx
|   |       `-- tooltip.tsx
|   |-- contexts
|   |   |-- Auth
|   |   `-- AuthContext.tsx
|   |-- hooks
|   |   |-- use-mobile.tsx
|   |   |-- useActiveGateway.ts
|   |   |-- useAdminFinancialData.ts
|   |   |-- useClients.ts
|   |   |-- useDashboardStats.ts
|   |   |-- useEvolutionLogoutHistory.ts
|   |   |-- useFinancialEntries.ts
|   |   |-- useMercadoPagoConfig.ts
|   |   |-- usePagbankConfig.ts
|   |   |-- usePlans.ts
|   |   |-- useProfileData.ts
|   |   |-- useSubscriberManagement.ts
|   |   |-- useTemplates.ts
|   |   |-- useWebhookConfig.ts
|   |   `-- useWebhookHistory.ts
|   |-- index.css
|   |-- integrations
|   |   `-- supabase
|   |       |-- client.ts
|   |       |-- schema.ts
|   |       `-- types.ts
|   |-- lib
|   |   `-- utils.ts
|   |-- main.tsx
|   |-- pages
|   |   |-- Auth.tsx
|   |   |-- Automations.tsx
|   |   |-- Clients.tsx
|   |   |-- Connection
|   |   |   |-- Metrics.tsx
|   |   |   `-- Webhooks.tsx
|   |   |-- Connection.tsx
|   |   |-- Dashboard.tsx
|   |   |-- NotFound.tsx
|   |   |-- Plans.tsx
|   |   |-- Profile.tsx
|   |   |-- Templates.tsx
|   |   |-- admin
|   |   |-- assinantes
|   |   |   |-- Automacoes.tsx
|   |   |   |-- Integracao.tsx
|   |   |   |-- Planos.tsx
|   |   |   |-- Templates.tsx
|   |   |   `-- Usuarios.tsx
|   |   |-- financeiro
|   |   |   |-- Analise.tsx
|   |   |   |-- Extrato.tsx
|   |   |   |-- Relatorios.tsx
|   |   |   `-- types.ts
|   |   `-- financeiroADM
|   |       |-- Analise.tsx
|   |       |-- Extrato.tsx
|   |       `-- Relatorios.tsx
|   `-- vite-env.d.ts
|-- supabase
|   |-- config.toml
|   |-- functions
|   |   |-- admin-financial-analysis
|   |   |   `-- index.ts
|   |   |-- admin-financial-entries
|   |   |   `-- index.ts
|   |   |-- admin-financial-summary
|   |   |   `-- index.ts
|   |   |-- apply-schema-migration
|   |   |   `-- index.ts
|   |   |-- connection-metrics
|   |   |   `-- index.ts
|   |   |-- crud-active-gateway
|   |   |   `-- index.ts
|   |   |-- crud-mercado-pago-configs
|   |   |   `-- index.ts
|   |   |-- crud-pagbank-configs
|   |   |   `-- index.ts
|   |   |-- crud-subscriber-automations
|   |   |   `-- index.ts
|   |   |-- crud-subscriber-plans
|   |   |   `-- index.ts
|   |   |-- crud-subscriber-templates
|   |   |   `-- index.ts
|   |   |-- delete-user
|   |   |   `-- index.ts
|   |   |-- evolution-webhook
|   |   |-- evolution-webhook-receiver
|   |   |   `-- index.ts
|   |   |-- financial-analysis
|   |   |   `-- index.ts
|   |   |-- financial-summary
|   |   |   `-- index.ts
|   |   |-- list-all-users
|   |   |   `-- index.ts
|   |   |-- log-n8n-qr-interaction
|   |   |   `-- index.ts
|   |   |-- mercado-pago-create-charge
|   |   |   `-- index.ts
|   |   |-- mercado-pago-webhook-receiver
|   |   |   `-- index.ts
|   |   |-- pagbank-create-charge
|   |   |   `-- index.ts
|   |   |-- pagbank-webhook-receiver
|   |   |   `-- index.ts
|   |   |-- populate-send-queue
|   |   |   `-- index.ts
|   |   |-- process-notification-queue
|   |   |-- process-queue-and-send
|   |   |   `-- index.ts
|   |   |-- renew-subscriber-subscription
|   |   |   `-- index.ts
|   |   |-- schedule-notifications-for-rule
|   |   |   `-- index.ts
|   |   |-- schedule-subscriber-notifications
|   |   |   `-- index.ts
|   |   |-- send-scheduled-notification
|   |   |   `-- index.ts
|   |   |-- set-subscriber-due-today
|   |   |   `-- index.ts
|   |   |-- setup-client-name-snapshot
|   |   |-- sync-pending-sends
|   |   |-- tsconfig.json
|   |   |-- update-instance-status
|   |   |-- update-user-role
|   |   |   `-- index.ts
|   |   `-- update-user-subscription
|   |       `-- index.ts
|   `-- migrations
|       |-- 0000_executando_um_script_sql_abrangente_e_corrigido_para_recriar_o_esquema_do_banco_de_dados_supabase_de_forma_idempotente_garantindo_que_apenas_o_c_digo_sql_v_lido_seja_executado_.sql
|       |-- 0001_atualizando_a_pol_tica_rls_de_inser_o_para_a_tabela_profiles_para_usar_uma_subquery_para_auth_uid_para_resolver_poss_veis_problemas_de_contexto_durante_a_cria_o_de_perfil_pelo_cliente_.sql
|       |-- 0002_criando_o_tipo_enum_transaction_type_e_a_tabela_financial_entries_com_rls_e_pol_ticas_de_seguran_a_.sql
|       |-- 0003_adicionando_pol_ticas_rls_para_update_e_delete_na_tabela_financial_entries_para_permitir_que_usu_rios_gerenciem_seus_pr_prios_lan_amentos_.sql
|       |-- 0004_adicionando_fun_o_e_gatilho_para_definir_o_status_do_cliente_com_base_na_data_de_vencimento_.sql
|       |-- 0005_criando_a_tabela_subscriptions_com_rls_e_trigger_para_gerenciar_assinaturas_de_usu_rios_.sql
|       |-- 0006_criando_a_tabela_automations_com_rls_e_trigger_para_gerenciar_regras_de_automa_o_.sql
|       |-- 0007_criando_as_tabelas_pending_sends_e_send_history_com_rls_para_gerenciar_a_fila_e_o_hist_rico_de_envios_de_mensagens_.sql
|       |-- 0008_criando_fun_o_e_gatilho_para_remover_clientes_inativos_de_automa_es_e_da_fila_de_envios_pendentes_.sql
|       |-- 0009_criando_fun_o_e_gatilho_para_remover_clientes_com_status_overdue_da_fila_de_envios_pendentes_.sql
|       |-- 0010_criando_a_tabela_user_instances_para_gerenciar_as_inst_ncias_do_whatsapp_por_usu_rio_com_rls_e_pol_ticas_de_seguran_a_.sql
|       |-- 0011_criando_a_tabela_url_configs_para_armazenar_urls_de_configura_o_do_sistema_com_rls_.sql
|       |-- 0013_criando_a_tabela_scheduled_notifications_com_rls_e_refer_ncias_a_clientes_templates_e_automa_es_.sql
|       |-- 0014_atualizando_a_fun_o_set_client_status_based_on_due_date_para_usar_o_fuso_hor_rio_local_america_sao_paulo_na_determina_o_do_status_do_cliente_.sql
|       |-- 0015_adicionando_colunas_request_payload_e_response_payload_tabela_webhook_history_e_atualizando_rls_.sql
|       |-- 0016_adicionando_colunas_client_id_e_template_id_tabela_webhook_history_e_criando_chaves_estrangeiras_.sql
|       |-- 0017_criando_as_tabelas_evolution_api_history_n8n_qr_code_history_e_n8n_message_sender_history_com_rls_e_chaves_estrangeiras_.sql
|       |-- 0018_criando_a_tabela_evolution_logout_history_com_rls_e_pol_ticas_de_seguran_a_.sql
|       |-- 0019_updating_rls_policies_for_all_user_specific_tables_to_ensure_multi_tenant_data_isolation_.sql
|       |-- 0020_updating_rls_policies_for_all_user_specific_tables_to_ensure_multi_tenant_data_isolation_.sql
|       |-- 0021_updating_rls_policies_for_all_user_specific_tables_and_webhook_configs_to_implement_role_based_access_control_rbac_.sql
|       |-- 0022_removendo_pol_ticas_rls_existentes_e_criando_novas_pol_ticas_n_o_recursivas_para_a_tabela_user_roles_.sql
|       |-- 0023_adicionando_a_coluna_pix_key_tabela_profiles_.sql
|       |-- 0024_migra_o_tornando_user_id_da_tabela_templates_nul_vel_e_adicionando_pix_key_tabela_profiles_se_ainda_n_o_existir_.sql
|       |-- 0025_migra_o_atualizando_as_pol_ticas_de_rls_para_a_tabela_templates_.sql
|       |-- 0026_criando_um_ndice_nico_parcial_na_coluna_name_da_tabela_templates_para_templates_padr_o_user_id_is_null_.sql
|       |-- 0027_adicionando_o_tipo_enum_template_type_e_a_coluna_type_tabela_templates_com_rls_atualizado_.sql
|       |-- 0028_removendo_a_coluna_category_da_tabela_templates_e_o_tipo_template_category_enum_.sql
|       |-- 0029_corrigindo_o_erro_ao_remover_a_coluna_category_da_tabela_templates_e_o_tipo_template_category_enum_usando_if_exists_.sql
|       |-- 0030_creating_new_tables_for_admin_financial_entries_subscriber_plans_subscriber_templates_and_subscriber_automations_along_with_their_rls_policies_.sql
|       |-- 0031_adding_type_column_to_scheduled_notifications_table_to_differentiate_between_client_and_subscriber_notifications_.sql
|       |-- 0032_contar_usu_rios_na_tabela_auth_users.sql
|       |-- 0033_contar_perfis_na_tabela_public_profiles.sql
|       |-- 0034_visualizar_os_primeiros_5_perfis.sql
|       |-- 0035_visualizar_os_primeiros_5_registros_de_fun_es_de_usu_rio.sql
|       |-- 0036_verificar_usu_rios_sem_perfil_correspondente.sql
|       |-- 0037_verificar_usu_rios_sem_fun_o_de_usu_rio_correspondente.sql
|       |-- 0038_verificar_status_do_gatilho_on_auth_user_created.sql
|       |-- 0039_update_fk_to_profiles_for_subscriptions_and_user_instances.sql
|       |-- 0040_verificar_chave_estrangeira_de_subscriptions_user_id.sql
|       |-- 0041_verificar_chave_estrangeira_de_user_instances_user_id.sql
|       |-- 0042_atualizando_a_fun_o_handle_new_user_para_criar_uma_assinatura_padr_o_para_novos_usu_rios_.sql
|       |-- 0043_corrigindo_a_chave_estrangeira_de_subscriptions_user_id_para_profiles_id_inserindo_o_plano_inicial_e_adicionando_gatilho_de_prote_o_.sql
|       |-- 0044_atualizando_a_fun_o_handle_new_user_para_usar_o_plano_inicial_dinamicamente_.sql
|       |-- 0045_limpando_registros_inconsistentes_em_user_instances_e_profiles_e_corrigindo_a_chave_estrangeira_para_user_instances_user_id_.sql
|       |-- 0046_desabilitando_temporariamente_o_gatilho_de_prote_o_consolidando_planos_plano_inicial_duplicados_e_reabilitando_o_gatilho_.sql
|       |-- 0047_adicionando_a_coluna_phone_tabela_profiles_e_atualizando_a_fun_o_handle_new_user_para_incluir_o_telefone_do_metadata_do_usu_rio_.sql
|       |-- 0048_criando_tabelas_pagbank_configs_e_pagbank_charges_com_rls_para_integra_o_pagbank_pix_.sql
|       |-- 0049_add_tax_id_to_profiles_table.sql
|       |-- 0049_adicionando_a_coluna_tax_id_cpf_cnpj_tabela_public_profiles_como_text_not_null_.sql
|       |-- 0050_adicionando_a_coluna_environment_e_o_tipo_enum_pagbank_environment_tabela_pagbank_configs_.sql
|       |-- 0051_corrigindo_a_migra_o_sql_para_adicionar_a_coluna_environment_tabela_pagbank_configs_apenas_se_ela_n_o_existir_garantindo_idempot_ncia_.sql
|       |-- 0052_creating_the_mercado_pago_configs_table_with_rls_policies_.sql
|       |-- 0053_creating_active_payment_gateway_table_with_rls_for_admin_users_.sql
|       |-- 0054_creating_the_mercado_pago_charges_table_with_rls_policies_for_mercado_pago_integration_.sql
|       |-- 0055_update_rls_policy_for_active_payment_gateway_to_allow_all_authenticated_users_to_read_.sql
|       |-- 20240801000000_populate_url_configs.sql
|       |-- 20240801103000_cleanup_old_cron_scheduler.sql
|       |-- 20240802000000_fix_security_warnings.sql
|       |-- 20240803000000_add_logging_to_process_notification_queue.sql
|       |-- 20240804000000_final_cron_cleanup.sql
|       |-- 20251007003528_102cc75e-094b-4867-af88-81f4a22932be.sql
|       |-- 20251008221742_04f85bc8-acba-4ba7-b6d0-7d68f700c615.sql
|       |-- 20251013211718_7199223e-79f3-455d-a284-7d422ac46b51.sql
|       |-- 20251013221600_fix_client_status_timezone.sql
|       |-- 20251016013741_aaf8b971-c037-421b-affa-f8e6241f5cd4.sql
|       |-- 20251016013854_c4128d56-0d29-430f-bf1b-44046107633e.sql
|       |-- 20251016020954_ea957f25-cd1a-4bb0-9173-0437ada06f90.sql
|       `-- 20251016022304_57e7bf3f-2807-4368-ad7d-e46877539e06.sql
|-- tailwind.config.ts
|-- tsconfig.app.json
|-- tsconfig.json
|-- tsconfig.node.json
`-- vite.config.ts

69 directories, 254 files

{
  "@hookform/resolvers": "^3.10.0",
  "@radix-ui/react-accordion": "^1.2.11",
  "@radix-ui/react-alert-dialog": "^1.1.14",
  "@radix-ui/react-aspect-ratio": "^1.1.7",
  "@radix-ui/react-avatar": "^1.1.10",
  "@radix-ui/react-checkbox": "^1.3.2",
  "@radix-ui/react-collapsible": "^1.1.11",
  "@radix-ui/react-context-menu": "^2.2.15",
  "@radix-ui/react-dialog": "^1.1.14",
  "@radix-ui/react-dropdown-menu": "^2.1.15",
  "@radix-ui/react-hover-card": "^1.1.14",
  "@radix-ui/react-label": "^2.1.7",
  "@radix-ui/react-menubar": "^1.1.15",
  "@radix-ui/react-navigation-menu": "^1.2.13",
  "@radix-ui/react-popover": "^1.1.14",
  "@radix-ui/react-progress": "^1.1.7",
  "@radix-ui/react-radio-group": "^1.3.7",
  "@radix-ui/react-scroll-area": "^1.2.9",
  "@radix-ui/react-select": "^2.2.5",
  "@radix-ui/react-separator": "^1.1.7",
  "@radix-ui/react-slider": "^1.3.5",
  "@radix-ui/react-slot": "^1.2.3",
  "@radix-ui/react-switch": "^1.2.5",
  "@radix-ui/react-tabs": "^1.1.12",
  "@radix-ui/react-toast": "^1.2.14",
  "@radix-ui/react-toggle": "^1.1.9",
  "@radix-ui/react-toggle-group": "^1.1.10",
  "@radix-ui/react-tooltip": "^1.2.7",
  "@supabase/supabase-js": "^2.74.0",
  "@tanstack/react-query": "^5.83.0",
  "@types/luxon": "^3.7.1",
  "@types/recharts": "^2.0.1",
  "class-variance-authority": "^0.7.1",
  "clsx": "^2.1.1",
  "cmdk": "^1.1.1",
  "date-fns": "^3.6.0",
  "date-fns-tz": "^3.2.0",
  "embla-carousel": "^8.6.0",
  "embla-carousel-react": "^8.6.0",
  "input-otp": "^1.4.2",
  "lucide-react": "^0.462.0",
  "luxon": "^3.7.2",
  "nanoid": "^5.1.6",
  "next-themes": "^0.3.0",
  "react": "^18.3.1",
  "react-day-picker": "^8.10.1",
  "react-dom": "^18.3.1",
  "react-hook-form": "^7.61.1",
  "react-resizable-panels": "^2.1.9",
  "react-router-dom": "^6.30.1",
  "recharts": "^2.15.4",
  "sonner": "^1.7.4",
  "tailwind-merge": "^2.6.0",
  "tailwindcss-animate": "^1.0.7",
  "vaul": "^0.9.9",
  "zod": "^3.25.76"
}
{
  "@eslint/js": "latest",
  "@tailwindcss/typography": "^0.5.16",
  "@types/node": "^22.16.5",
  "@types/react": "^18.3.23",
  "@types/react-dom": "^18.3.7",
  "@vitejs/plugin-react-swc": "^3.11.0",
  "autoprefixer": "^10.4.21",
  "eslint": "^9.32.0",
  "eslint-plugin-react-hooks": "^5.2.0",
  "eslint-plugin-react-refresh": "^0.4.20",
  "globals": "^15.15.0",
  "lovable-tagger": "^1.1.10",
  "postcss": "^8.5.6",
  "supabase": "^2.51.0",
  "tailwindcss": "^3.4.17",
  "typescript": "^5.8.3",
  "typescript-eslint": "^8.38.0",
  "vite": "^5.4.19"
}

VITE_SUPABASE_PROJECT_ID="cgqyfpsfymhntumrmbzj"
VITE_SUPABASE_PUBLISHABLE_KEY="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNncXlmcHNmeW1obnR1bXJtYnpqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwNjQzOTcsImV4cCI6MjA3MzY0MDM5N30.8UNzCZP9tB4bP3jzhZBMhg5IwEIhxId_Ezg8wMLXm3Q"
VITE_SUPABASE_URL="https://cgqyfpsfymhntumrmbzj.supabase.co"

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  // Allows to automatically instantiate createClient with right options
  // instead of createClient<Database, { PostgrestVersion: 'XX' }>(URL, KEY)
  __InternalSupabase: {
    PostgrestVersion: "13.0.5"
  }
  public: {
    Tables: {
      active_payment_gateway: {
        Row: {
          gateway_name: string
          id: number
          updated_at: string | null
        }
        Insert: {
          gateway_name: string
          id?: number
          updated_at?: string | null
        }
        Update: {
          gateway_name?: string
          id?: number
          updated_at?: string | null
        }
        Relationships: []
      }
      admin_financial_entries: {
        Row: {
          admin_user_id: string
          created_at: string | null
          description: string
          id: string
          subscriber_id: string
          type: Database["public"]["Enums"]["transaction_type"]
          value: number
        }
        Insert: {
          admin_user_id: string
          created_at?: string | null
          description: string
          id?: string
          subscriber_id: string
          type: Database["public"]["Enums"]["transaction_type"]
          value: number
        }
        Update: {
          admin_user_id?: string
          created_at?: string | null
          description?: string
          id?: string
          subscriber_id?: string
          type?: Database["public"]["Enums"]["transaction_type"]
          value?: number
        }
        Relationships: [
          {
            foreignKeyName: "admin_financial_entries_admin_user_id_fkey"
            columns: ["admin_user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "admin_financial_entries_subscriber_id_fkey"
            columns: ["subscriber_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      automations: {
        Row: {
          client_ids: string[]
          created_at: string
          days_offset: number
          id: string
          scheduled_time: string
          template_id: string
          updated_at: string
          user_id: string
        }
        Insert: {
          client_ids: string[]
          created_at?: string
          days_offset: number
          id?: string
          scheduled_time?: string
          template_id: string
          updated_at?: string
          user_id: string
        }
        Update: {
          client_ids?: string[]
          created_at?: string
          days_offset?: number
          id?: string
          scheduled_time?: string
          template_id?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "automations_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "templates"
            referencedColumns: ["id"]
          },
        ]
      }
      clients: {
        Row: {
          created_at: string
          due_date: string
          email: string | null
          id: string
          name: string
          next_billing_date: string
          notes: string | null
          phone: string
          plan_id: string | null
          status: Database["public"]["Enums"]["client_status"]
          updated_at: string
          user_id: string
          value: number
        }
        Insert: {
          created_at?: string
          due_date: string
          email?: string | null
          id?: string
          name: string
          next_billing_date: string
          notes?: string | null
          phone: string
          plan_id?: string | null
          status?: Database["public"]["Enums"]["client_status"]
          updated_at?: string
          user_id: string
          value: number
        }
        Update: {
          created_at?: string
          due_date?: string
          email?: string | null
          id?: string
          name?: string
          next_billing_date?: string
          notes?: string | null
          phone?: string
          plan_id?: string | null
          status?: Database["public"]["Enums"]["client_status"]
          updated_at?: string
          user_id?: string
          value?: number
        }
        Relationships: [
          {
            foreignKeyName: "clients_plan_id_fkey"
            columns: ["plan_id"]
            isOneToOne: false
            referencedRelation: "plans"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "clients_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      connection_status: {
        Row: {
          id: string
          instance_name: string
          last_updated: string
          qr_code_base64: string | null
          status: string
          user_id: string
        }
        Insert: {
          id?: string
          instance_name: string
          last_updated?: string
          qr_code_base64?: string | null
          status?: string
          user_id: string
        }
        Update: {
          id?: string
          instance_name?: string
          last_updated?: string
          qr_code_base64?: string | null
          status?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "connection_status_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      evolution_api_history: {
        Row: {
          client_id: string | null
          client_name_snapshot: string | null
          id: string
          payload: Json
          request_payload: Json | null
          response_payload: Json | null
          status_code: number | null
          template_id: string | null
          timestamp: string
          user_id: string | null
          webhook_type: string
        }
        Insert: {
          client_id?: string | null
          client_name_snapshot?: string | null
          id?: string
          payload: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          user_id?: string | null
          webhook_type: string
        }
        Update: {
          client_id?: string | null
          client_name_snapshot?: string | null
          id?: string
          payload?: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          user_id?: string | null
          webhook_type?: string
        }
        Relationships: [
          {
            foreignKeyName: "evolution_api_history_client_id_fkey"
            columns: ["client_id"]
            isOneToOne: false
            referencedRelation: "clients"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "evolution_api_history_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "templates"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "evolution_api_history_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      evolution_logout_history: {
        Row: {
          client_id: string | null
          client_name_snapshot: string | null
          id: string
          payload: Json
          request_payload: Json | null
          response_payload: Json | null
          status_code: number | null
          template_id: string | null
          timestamp: string
          user_id: string | null
          webhook_type: string
        }
        Insert: {
          client_id?: string | null
          client_name_snapshot?: string | null
          id?: string
          payload: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          user_id?: string | null
          webhook_type: string
        }
        Update: {
          client_id?: string | null
          client_name_snapshot?: string | null
          id?: string
          payload?: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          user_id?: string | null
          webhook_type?: string
        }
        Relationships: [
          {
            foreignKeyName: "evolution_logout_history_client_id_fkey"
            columns: ["client_id"]
            isOneToOne: false
            referencedRelation: "clients"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "evolution_logout_history_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "templates"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "evolution_logout_history_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      financial_entries: {
        Row: {
          created_at: string | null
          description: string
          id: string
          type: Database["public"]["Enums"]["transaction_type"]
          user_id: string
          value: number
        }
        Insert: {
          created_at?: string | null
          description: string
          id?: string
          type: Database["public"]["Enums"]["transaction_type"]
          user_id: string
          value: number
        }
        Update: {
          created_at?: string | null
          description?: string
          id?: string
          type?: Database["public"]["Enums"]["transaction_type"]
          user_id?: string
          value?: number
        }
        Relationships: []
      }
      logs: {
        Row: {
          action: string
          created_at: string
          details: Json | null
          id: string
          user_id: string
        }
        Insert: {
          action: string
          created_at?: string
          details?: Json | null
          id?: string
          user_id: string
        }
        Update: {
          action?: string
          created_at?: string
          details?: Json | null
          id?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "logs_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      mercado_pago_charges: {
        Row: {
          created_at: string | null
          id: string
          mercado_pago_payment_id: string
          status: string
          subscription_id: string
          user_id: string
          value: number
        }
        Insert: {
          created_at?: string | null
          id?: string
          mercado_pago_payment_id: string
          status?: string
          subscription_id: string
          user_id: string
          value: number
        }
        Update: {
          created_at?: string | null
          id?: string
          mercado_pago_payment_id?: string
          status?: string
          subscription_id?: string
          user_id?: string
          value?: number
        }
        Relationships: [
          {
            foreignKeyName: "mercado_pago_charges_subscription_id_fkey"
            columns: ["subscription_id"]
            isOneToOne: false
            referencedRelation: "subscriptions"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "mercado_pago_charges_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      mercado_pago_configs: {
        Row: {
          id: number
          mercado_pago_access_token: string
          mercado_pago_client_id: string
          mercado_pago_client_secret: string
          mercado_pago_public_key: string
          updated_at: string | null
        }
        Insert: {
          id?: number
          mercado_pago_access_token: string
          mercado_pago_client_id: string
          mercado_pago_client_secret: string
          mercado_pago_public_key: string
          updated_at?: string | null
        }
        Update: {
          id?: number
          mercado_pago_access_token?: string
          mercado_pago_client_id?: string
          mercado_pago_client_secret?: string
          mercado_pago_public_key?: string
          updated_at?: string | null
        }
        Relationships: []
      }
      n8n_message_sender_history: {
        Row: {
          client_id: string | null
          client_name_snapshot: string | null
          id: string
          payload: Json
          request_payload: Json | null
          response_payload: Json | null
          status_code: number | null
          template_id: string | null
          timestamp: string
          user_id: string | null
          webhook_type: string
        }
        Insert: {
          client_id?: string | null
          client_name_snapshot?: string | null
          id?: string
          payload: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          user_id?: string | null
          webhook_type: string
        }
        Update: {
          client_id?: string | null
          id?: string
          payload?: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          user_id?: string | null
          webhook_type?: string
        }
        Relationships: [
          {
            foreignKeyName: "n8n_message_sender_history_client_id_fkey"
            columns: ["client_id"]
            isOneToOne: false
            referencedRelation: "clients"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "n8n_message_sender_history_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "templates"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "n8n_message_sender_history_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      n8n_qr_code_history: {
        Row: {
          client_id: string | null
          client_name_snapshot: string | null
          id: string
          payload: Json
          request_payload: Json | null
          response_payload: Json | null
          status_code: number | null
          template_id: string | null
          timestamp: string
          user_id: string | null
          webhook_type: string
        }
        Insert: {
          client_id?: string | null
          client_name_snapshot?: string | null
          id?: string
          payload: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          user_id?: string | null
          webhook_type: string
        }
        Update: {
          client_id?: string | null
          client_name_snapshot?: string | null
          id?: string
          payload?: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          user_id?: string | null
          webhook_type?: string
        }
        Relationships: [
          {
            foreignKeyName: "n8n_qr_code_history_client_id_fkey"
            columns: ["client_id"]
            isOneToOne: false
            referencedRelation: "clients"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "n8n_qr_code_history_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "templates"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "n8n_qr_code_history_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      pagbank_charges: {
        Row: {
          created_at: string | null
          id: string
          pagbank_charge_id: string
          status: string
          subscription_id: string
          user_id: string
          value: number
        }
        Insert: {
          created_at?: string | null
          id?: string
          pagbank_charge_id: string
          status?: string
          subscription_id: string
          user_id: string
          value: number
        }
        Update: {
          created_at?: string | null
          id?: string
          pagbank_charge_id?: string
          status?: string
          subscription_id?: string
          user_id?: string
          value?: number
        }
        Relationships: [
          {
            foreignKeyName: "pagbank_charges_subscription_id_fkey"
            columns: ["subscription_id"]
            isOneToOne: false
            referencedRelation: "subscriptions"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "pagbank_charges_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      pagbank_configs: {
        Row: {
          id: number
          pagbank_email: string
          pagbank_pix_key: string
          pagbank_token: string
          updated_at: string | null
          environment: Database["public"]["Enums"]["pagbank_environment"]
        }
        Insert: {
          id?: number
          pagbank_email: string
          pagbank_pix_key: string
          pagbank_token: string
          updated_at?: string | null
          environment?: Database["public"]["Enums"]["pagbank_environment"]
        }
        Update: {
          id?: number
          pagbank_email?: string
          pagbank_pix_key?: string
          pagbank_token?: string
          updated_at?: string | null
          environment?: Database["public"]["Enums"]["pagbank_environment"]
        }
        Relationships: []
      }
      pending_sends: {
        Row: {
          automation_id: string
          client_id: string
          created_at: string
          id: string
          scheduled_for: string
          template_id: string
          user_id: string
        }
        Insert: {
          automation_id: string
          client_id: string
          created_at?: string
          id?: string
          scheduled_for: string
          template_id: string
          user_id: string
        }
        Update: {
          automation_id?: string
          client_id?: string
          created_at?: string
          id?: string
          scheduled_for?: string
          template_id?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "pending_sends_automation_id_fkey"
            columns: ["automation_id"]
            isOneToOne: false
            referencedRelation: "automations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "pending_sends_client_id_fkey"
            columns: ["client_id"]
            isOneToOne: false
            referencedRelation: "clients"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "pending_sends_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "templates"
            referencedColumns: ["id"]
          },
        ]
      }
      plans: {
        Row: {
          created_at: string
          id: string
          name: string
          period_days: number
          updated_at: string
          user_id: string
          value: number
        }
        Insert: {
          created_at?: string
          id?: string
          name: string
          period_days: number
          updated_at?: string
          user_id: string
          value: number
        }
        Update: {
          created_at?: string
          id?: string
          name?: string
          period_days?: number
          updated_at?: string
          user_id?: string
          value?: number
        }
        Relationships: [
          {
            foreignKeyName: "plans_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      profiles: {
        Row: {
          created_at: string
          email: string
          id: string
          name: string
          updated_at: string
          pix_key: string | null
          phone: string | null
          tax_id: string
        }
        Insert: {
          created_at?: string
          email: string
          id: string
          name: string
          updated_at?: string
          pix_key?: string | null
          phone?: string | null
          tax_id: string
        }
        Update: {
          created_at?: string
          email?: string
          id?: string
          name?: string
          updated_at?: string
          pix_key?: string | null
          phone?: string | null
          tax_id?: string
        }
        Relationships: []
      }
      scheduled_notifications: {
        Row: {
          automation_id: string
          client_id: string
          created_at: string | null
          id: string
          send_at: string
          status: string
          template_id: string
          user_id: string
          type: string
        }
        Insert: {
          automation_id: string
          client_id: string
          created_at?: string | null
          id?: string
          send_at: string
          status?: string
          template_id: string
          user_id: string
          type?: string
        }
        Update: {
          automation_id?: string
          client_id?: string
          created_at?: string | null
          id?: string
          send_at?: string
          status?: string
          template_id?: string
          user_id?: string
          type?: string
        }
        Relationships: [
          {
            foreignKeyName: "scheduled_notifications_automation_id_fkey"
            columns: ["automation_id"]
            isOneToOne: false
            referencedRelation: "automations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "scheduled_notifications_client_id_fkey"
            columns: ["client_id"]
            isOneToOne: false
            referencedRelation: "clients"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "scheduled_notifications_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "templates"
            referencedColumns: ["id"]
          },
        ]
      }
      send_history: {
        Row: {
          client_id: string
          error_message: string | null
          id: string
          sent_at: string
          status: string
          template_id: string
          user_id: string
        }
        Insert: {
          client_id: string
          error_message?: string | null
          id?: string
          sent_at?: string
          status: string
          template_id: string
          user_id: string
        }
        Update: {
          client_id?: string
          error_message?: string | null
          id?: string
          sent_at?: string
          status?: string
          template_id?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "send_history_client_id_fkey"
            columns: ["client_id"]
            isOneToOne: false
            referencedRelation: "clients"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "send_history_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "templates"
            referencedColumns: ["id"]
          },
        ]
      }
      subscriber_automations: {
        Row: {
          admin_user_id: string
          created_at: string
          days_offset: number
          id: string
          scheduled_time: string
          subscriber_ids: string[]
          subscriber_template_id: string
          updated_at: string
        }
        Insert: {
          admin_user_id: string
          created_at?: string
          days_offset: number
          id?: string
          scheduled_time?: string
          subscriber_ids: string[]
          subscriber_template_id: string
          updated_at?: string
        }
        Update: {
          admin_user_id?: string
          created_at?: string
          days_offset?: number
          id?: string
          scheduled_time?: string
          subscriber_ids?: string[]
          subscriber_template_id?: string
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "subscriber_automations_admin_user_id_fkey"
            columns: ["admin_user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "subscriber_automations_subscriber_template_id_fkey"
            columns: ["subscriber_template_id"]
            isOneToOne: false
            referencedRelation: "subscriber_templates"
            referencedColumns: ["id"]
          },
        ]
      }
      subscriber_plans: {
        Row: {
          created_at: string
          id: string
          name: string
          period_days: number
          updated_at: string
          value: number
        }
        Insert: {
          created_at?: string
          id?: string
          name: string
          period_days: number
          updated_at?: string
          value: number
        }
        Update: {
          created_at?: string
          id?: string
          name?: string
          period_days?: number
          updated_at?: string
          value?: number
        }
        Relationships: []
      }
      subscriber_templates: {
        Row: {
          admin_user_id: string | null
          content: string
          created_at: string
          id: string
          name: string
          type: Database["public"]["Enums"]["template_type"]
          updated_at: string
        }
        Insert: {
          admin_user_id?: string | null
          content: string
          created_at?: string
          id?: string
          name: string
          type?: Database["public"]["Enums"]["template_type"]
          updated_at?: string
        }
        Update: {
          admin_user_id?: string | null
          content?: string
          created_at?: string
          id?: string
          name?: string
          type?: Database["public"]["Enums"]["template_type"]
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "subscriber_templates_admin_user_id_fkey"
            columns: ["admin_user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      subscriptions: {
        Row: {
          created_at: string
          id: string
          next_billing_date: string
          plan_name: string
          price: number
          status: string
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          next_billing_date: string
          plan_name: string
          price: number
          status?: string
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          next_billing_date?: string
          plan_name?: string
          price?: number
          status?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      templates: {
        Row: {
          content: string
          created_at: string
          id: string
          name: string
          updated_at: string
          user_id: string | null
          type: Database["public"]["Enums"]["template_type"]
        }
        Insert: {
          content: string
          created_at?: string
          id?: string
          name: string
          updated_at?: string
          user_id?: string | null
          type?: Database["public"]["Enums"]["template_type"]
        }
        Update: {
          content?: string
          created_at?: string
          id?: string
          name?: string
          updated_at?: string
          user_id?: string | null
          type?: Database["public"]["Enums"]["template_type"]
        }
        Relationships: [
          {
            foreignKeyName: "templates_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      url_configs: {
        Row: {
          evolution_listener_url: string
          id: number
          n8n_webhook_url: string
        }
        Insert: {
          evolution_listener_url: string
          id?: number
          n8n_webhook_url: string
        }
        Update: {
          evolution_listener_url?: string
          id?: number
          n8n_webhook_url?: string
        }
        Relationships: []
      }
      user_instances: {
        Row: {
          created_at: string
          id: string
          instance_name: string
          qr_code_base64: string | null
          status: string
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          instance_name: string
          qr_code_base64?: string | null
          status?: string
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          instance_name?: string
          qr_code_base64?: string | null
          status?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      user_roles: {
        Row: {
          created_at: string
          id: string
          role: Database["public"]["Enums"]["app_role"]
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          role?: Database["public"]["Enums"]["app_role"]
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          role?: Database["public"]["Enums"]["app_role"]
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "user_roles_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      webhook_configs: {
        Row: {
          client_name_snapshot: string | null
          created_at: string
          id: string
          payload: Json
          request_payload: Json | null
          response_payload: Json | null
          status_code: number | null
          template_id: string | null
          timestamp: string
          type: string
          updated_at: string
          url: string
          user_id: string
        }
        Insert: {
          client_name_snapshot?: string | null
          created_at?: string
          id?: string
          payload: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          type: string
          updated_at?: string
          url: string
          user_id: string
        }
        Update: {
          client_name_snapshot?: string | null
          created_at?: string
          id?: string
          payload?: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          type?: string
          updated_at?: string
          url?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "webhook_configs_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      webhook_history: {
        Row: {
          client_id: string | null
          id: string
          payload: Json
          request_payload: Json | null
          response_payload: Json | null
          status_code: number | null
          template_id: string | null
          timestamp: string
          user_id: string
          webhook_type: string
        }
        Insert: {
          client_id?: string | null
          id?: string
          payload: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          user_id: string
          webhook_type: string
        }
        Update: {
          client_id?: string | null
          id?: string
          payload?: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          user_id?: string
          webhook_type?: string
        }
        Relationships: [
          {
            foreignKeyName: "webhook_history_client_id_fkey"
            columns: ["client_id"]
            isOneToOne: false
            referencedRelation: "clients"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "webhook_history_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "templates"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "webhook_history_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      bytea_to_text: {
        Args: { data: string }
        Returns: string
      }
      http: {
        Args: { request: Database["public"]["CompositeTypes"]["http_request"] }
        Returns: Database["public"]["CompositeTypes"]["http_response"]
      }
      http_delete: {
        Args:
          | { content: string; content_type: string; uri: string }
          | { uri: string }
        Returns: Database["public"]["CompositeTypes"]["http_response"]
      }
      http_get: {
        Args: { data: Json; uri: string } | { uri: string }
        Returns: Database["public"]["CompositeTypes"]["http_response"]
      }
      http_head: {
        Args: { uri: string }
        Returns: Database["public"]["CompositeTypes"]["http_response"]
      }
      http_header: {
        Args: { field: string; value: string }
        Returns: Database["public"]["CompositeTypes"]["http_header"]
      }
      http_list_curlopt: {
        Args: Record<PropertyKey, never>
        Returns: {
          curlopt: string
          value: string
        }[]
      }
      http_patch: {
        Args: { content: string; content_type: string; uri: string }
        Returns: Database["public"]["CompositeTypes"]["http_response"]
      }
      http_post: {
        Args:
          | { content: string; content_type: string; uri: string }
          | { data: Json; uri: string }
        Returns: Database["public"]["CompositeTypes"]["http_response"]
      }
      http_put: {
        Args: { content: string; content_type: string; uri: string }
        Returns: Database["public"]["CompositeTypes"]["http_response"]
      }
      http_reset_curlopt: {
        Args: Record<PropertyKey, never>
        Returns: boolean
      }
      http_set_curlopt: {
        Args: { curlopt: string; value: string }
        Returns: boolean
      }
      process_automated_notifications: {
        Args: Record<PropertyKey, never>
        Returns: undefined
      }
      process_notification_queue: {
        Args: Record<PropertyKey, never>
        Returns: undefined
      }
      text_to_bytea: {
        Args: { data: string }
        Returns: string
      }
      urlencode: {
        Args: { data: Json } | { string: string } | { string: string }
        Returns: string
      }
    }
    Enums: {
      app_role: "admin" | "user"
      client_status: "active" | "inactive" | "overdue"
      transaction_type: "credit" | "debit"
      template_type: "normal" | "global"
      pagbank_environment: "sandbox" | "production"
    }
    CompositeTypes: {
      http_header: {
        field: string | null
        value: string | null
      }
      http_request: {
        method: unknown | null
        uri: string | null
        headers: Database["public"]["CompositeTypes"]["http_header"][] | null
        content_type: string | null
        content: string | null
      }
      http_response: {
        status: number | null
        content_type: string | null
        headers: Database["public"]["CompositeTypes"]["http_header"][] | null
        content: string | null
      }
    }
  }
}

type DatabaseWithoutInternals = Omit<Database, "__InternalSupabase">

type DefaultSchema = DatabaseWithoutInternals[Extract<keyof Database, "public">]

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      DefaultSchema["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof DatabaseWithoutInternals },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof DatabaseWithoutInternals },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never

export const Constants = {
  public: {
    Enums: {
      app_role: ["admin", "user"],
      client_status: ["active", "inactive", "overdue"],
      transaction_type: ["credit", "debit"],
      template_type: ["normal", "global"],
      pagbank_environment: ["sandbox", "production"],
    },
  },
} as const
import { Toaster as Sonner } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { BrowserRouter, Routes, Route, Navigate } from "react-router-dom";
import Auth from "./pages/Auth";
import Dashboard from "./pages/Dashboard";
import Clients from "./pages/Clients";
import Plans from "./pages/Plans";
import Templates from "./pages/Templates";
import Automations from "./pages/Automations";
import Connection from "./pages/Connection";
import ConnectionMetrics from "@/pages/Connection/Metrics";
import Webhooks from "@/pages/Connection/Webhooks";
import Extrato from "./pages/financeiro/Extrato";
import Relatorios from "./pages/financeiro/Relatorios";
import Analise from "./pages/financeiro/Analise";
import Profile from "./pages/Profile";
import NotFound from "./pages/NotFound";
import { ProtectedRoute } from "./components/ProtectedRoute";
import { MainLayout } from "./components/layout/MainLayout";
import { AuthProvider } from "./contexts/AuthContext";

// NOVO: Importar pginas de admin
import AdminExtrato from "./pages/financeiroADM/Extrato";
import AdminRelatorios from "./pages/financeiroADM/Relatorios";
import AdminAnalise from "./pages/financeiroADM/Analise";
import AdminUsuarios from "./pages/assinantes/Usuarios";
import AdminPlanos from "./pages/assinantes/Planos";
import AdminTemplates from "./pages/assinantes/Templates";
import AdminAutomacoes from "./pages/assinantes/Automacoes";
import IntegracaoPagbank from "./pages/assinantes/Integracao"; // NOVO: Importar pgina de integrao PagBank


const queryClient = new QueryClient();

const App = () => (
  <QueryClientProvider client={queryClient}>
    <TooltipProvider>
      <Sonner />
      <BrowserRouter>
        <AuthProvider>
          <Routes>
            <Route path="/" element={<Navigate to="/dashboard" replace />} />
            <Route path="/auth" element={<Auth />} />
            <Route
              path="/dashboard"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <Dashboard />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/clients"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <Clients />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/plans"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <Plans />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/templates"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <Templates />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            {/* Rotas para a seo Conexo */}
            <Route
              path="/connection/whatsapp"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <Connection />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/connection/automations"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <Automations />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/connection/metrics"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <ConnectionMetrics />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/connection/webhooks"
              element={
                <ProtectedRoute requiredRole="admin">
                  <MainLayout>
                    <Webhooks />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/profile"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <Profile />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            {/* Rotas para a seo Financeiro */}
            <Route
              path="/financeiro/extrato"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <Extrato />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/financeiro/relatorios"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <Relatorios />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/financeiro/analise"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <Analise />
                  </MainLayout>
                </ProtectedRoute>
              }
            />

            {/* NOVO: Rotas para a seo Financeiro Admin */}
            <Route
              path="/financeiroADM/extrato"
              element={
                <ProtectedRoute requiredRole="admin">
                  <MainLayout>
                    <AdminExtrato />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/financeiroADM/relatorios"
              element={
                <ProtectedRoute requiredRole="admin">
                  <MainLayout>
                    <AdminRelatorios />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/financeiroADM/analise"
              element={
                <ProtectedRoute requiredRole="admin">
                  <MainLayout>
                    <AdminAnalise />
                  </MainLayout>
                </ProtectedRoute>
              }
            />

            {/* NOVO: Rotas para a seo Gerenciamento de Assinantes */}
            <Route
              path="/assinantes/usuarios"
              element={
                <ProtectedRoute requiredRole="admin">
                  <MainLayout>
                    <AdminUsuarios />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/assinantes/planos"
              element={
                <ProtectedRoute requiredRole="admin">
                  <MainLayout>
                    <AdminPlanos />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/assinantes/templates"
              element={
                <ProtectedRoute requiredRole="admin">
                  <MainLayout>
                    <AdminTemplates />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/assinantes/automacoes"
              element={
                <ProtectedRoute requiredRole="admin">
                  <MainLayout>
                    <AdminAutomacoes />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            {/* NOVO: Rota para integrao PagBank */}
            <Route
              path="/assinantes/integracao"
              element={
                <ProtectedRoute requiredRole="admin">
                  <MainLayout>
                    <IntegracaoPagbank />
                  </MainLayout>
                </ProtectedRoute>
              }
            />

            <Route path="*" element={<NotFound />} />
          </Routes>
        </AuthProvider>
      </BrowserRouter>
    </TooltipProvider>
  </QueryClientProvider>
);

export default App;

--- Contedo de: supabase/migrations/0000_executando_um_script_sql_abrangente_e_corrigido_para_recriar_o_esquema_do_banco_de_dados_supabase_de_forma_idempotente_garantindo_que_apenas_o_c_digo_sql_v_lido_seja_executado_.sql ---
-- Desabilitar verificaes de chaves estrangeiras temporariamente para permitir a excluso de tabelas em qualquer ordem
SET session_replication_role = 'replica';

-- 1. Remover Triggers existentes (se houver)
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users CASCADE;
DROP TRIGGER IF EXISTS update_profiles_updated_at ON public.profiles CASCADE;
DROP TRIGGER IF EXISTS update_plans_updated_at ON public.plans CASCADE;
DROP TRIGGER IF EXISTS update_clients_updated_at ON public.clients CASCADE;
DROP TRIGGER IF EXISTS update_templates_updated_at ON public.templates CASCADE;

-- 2. Remover Polticas RLS existentes (se houver)
DROP POLICY IF EXISTS "Users can view their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can view their own roles" ON public.user_roles;
DROP POLICY IF EXISTS "Users can manage their own plans" ON public.plans;
DROP POLICY IF EXISTS "Users can manage their own clients" ON public.clients;
DROP POLICY IF EXISTS "Users can manage their own templates" ON public.templates;
DROP POLICY IF EXISTS "Users can view their own logs" ON public.logs;
DROP POLICY IF EXISTS "Users can create their own logs" ON public.logs;

-- 3. Remover Tabelas existentes (se houver, em ordem inversa de dependncia)
DROP TABLE IF EXISTS public.logs CASCADE;
DROP TABLE IF EXISTS public.clients CASCADE;
DROP TABLE IF EXISTS public.plans CASCADE;
DROP TABLE IF EXISTS public.user_roles CASCADE;
DROP TABLE IF EXISTS public.templates CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

-- 4. Remover Funes existentes (se houver)
DROP FUNCTION IF EXISTS public.handle_new_user CASCADE;
DROP FUNCTION IF EXISTS public.update_updated_at_column CASCADE;

-- 5. Remover Tipos ENUM existentes (se houver)
DROP TYPE IF EXISTS public.app_role CASCADE;
DROP TYPE IF EXISTS public.client_status CASCADE;
DROP TYPE IF EXISTS public.template_category CASCADE;

-- Reabilitar verificaes de chaves estrangeiras
SET session_replication_role = 'origin';

-- Incio da recriao do esquema

-- 1. Criar Tipos ENUM
CREATE TYPE public.app_role AS ENUM ('admin', 'user');
CREATE TYPE public.client_status AS ENUM ('active', 'inactive', 'overdue');
CREATE TYPE public.template_category AS ENUM ('pre_due', 'due_today', 'overdue', 'celebratory');

-- 2. Criar Funes
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, name, email)
  VALUES (NEW.id, COALESCE(NEW.raw_user_meta_data->>'name', split_part(NEW.email, '@', 1)), NEW.email);
  INSERT INTO public.user_roles (user_id, role)
  VALUES (NEW.id, 'user');
  RETURN NEW;
END;
$$;

-- 3. Criar Tabelas
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE public.user_roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  role app_role NOT NULL DEFAULT 'user',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(user_id, role)
);

CREATE TABLE public.plans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  value DECIMAL(10, 2) NOT NULL,
  period_days INTEGER NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE public.clients (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  phone TEXT NOT NULL,
  email TEXT,
  notes TEXT,
  plan_id UUID REFERENCES public.plans(id) ON DELETE SET NULL,
  due_date DATE NOT NULL,
  next_billing_date DATE NOT NULL,
  status client_status NOT NULL DEFAULT 'active',
  value DECIMAL(10, 2) NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE public.templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  category template_category NOT NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE public.logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  action TEXT NOT NULL,
  details JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- 4. Habilitar Row Level Security
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.clients ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.logs ENABLE ROW LEVEL SECURITY;

-- 5. Criar Polticas RLS
CREATE POLICY "Users can view their own profile" ON public.profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Users can update their own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "Users can view their own roles" ON public.user_roles FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can manage their own plans" ON public.plans FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can manage their own clients" ON public.clients FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can manage their own templates" ON public.templates FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can view their own logs" ON public.logs FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can create their own logs" ON public.logs FOR INSERT WITH CHECK (auth.uid() = user_id);

-- 6. Criar Triggers
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

CREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE TRIGGER update_plans_updated_at BEFORE UPDATE ON public.plans FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE TRIGGER update_clients_updated_at BEFORE UPDATE ON public.clients FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE TRIGGER update_templates_updated_at BEFORE UPDATE ON public.templates FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
--- Contedo de: supabase/migrations/0001_atualizando_a_pol_tica_rls_de_inser_o_para_a_tabela_profiles_para_usar_uma_subquery_para_auth_uid_para_resolver_poss_veis_problemas_de_contexto_durante_a_cria_o_de_perfil_pelo_cliente_.sql ---
-- Remover a poltica de insero existente para perfis
DROP POLICY IF EXISTS "profiles_insert_policy" ON public.profiles;

-- Criar uma nova poltica de insero para perfis usando uma subquery para auth.uid()
CREATE POLICY "profiles_insert_policy" ON public.profiles
FOR INSERT TO authenticated WITH CHECK (id = (SELECT auth.uid()));
--- Contedo de: supabase/migrations/0002_criando_o_tipo_enum_transaction_type_e_a_tabela_financial_entries_com_rls_e_pol_ticas_de_seguran_a_.sql ---
-- Create ENUM for transaction types
DO $$ BEGIN
  CREATE TYPE public.transaction_type AS ENUM ('credit', 'debit');
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

-- Create financial_entries table
CREATE TABLE public.financial_entries (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  description TEXT NOT NULL,
  value NUMERIC(10, 2) NOT NULL,
  type public.transaction_type NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable RLS (REQUIRED)
ALTER TABLE public.financial_entries ENABLE ROW LEVEL SECURITY;

-- Policies for financial_entries
CREATE POLICY "Users can view their own financial entries" ON public.financial_entries
FOR SELECT TO authenticated USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own financial entries" ON public.financial_entries
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);

-- No update or delete policies by default for financial entries to maintain an immutable ledger.
-- If updates/deletes are needed, specific policies should be added.
--- Contedo de: supabase/migrations/0003_adicionando_pol_ticas_rls_para_update_e_delete_na_tabela_financial_entries_para_permitir_que_usu_rios_gerenciem_seus_pr_prios_lan_amentos_.sql ---
-- Add UPDATE policy for financial_entries
CREATE POLICY "Users can update their own financial entries" ON public.financial_entries
FOR UPDATE TO authenticated USING (auth.uid() = user_id);

-- Add DELETE policy for financial_entries
CREATE POLICY "Users can delete their own financial entries" ON public.financial_entries
FOR DELETE TO authenticated USING (auth.uid() = user_id);
--- Contedo de: supabase/migrations/0004_adicionando_fun_o_e_gatilho_para_definir_o_status_do_cliente_com_base_na_data_de_vencimento_.sql ---
-- 1. Criar a funo que ser executada pelo gatilho
CREATE OR REPLACE FUNCTION public.set_client_status_based_on_due_date()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- Verifica se o status atual no  'inativo'. No queremos reativar um cliente cancelado automaticamente.
  IF NEW.status != 'inactive' THEN
    -- Se a data de vencimento for anterior a hoje, define o status como 'vencido'.
    IF NEW.next_billing_date < CURRENT_DATE THEN
      NEW.status := 'overdue';
    -- Caso contrrio, define o status como 'ativo'.
    ELSE
      NEW.status := 'active';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;

-- 2. Criar o gatilho que executa a funo antes de qualquer insero ou atualizao na tabela de clientes
-- Primeiro, remove o gatilho antigo se ele existir, para evitar erros
DROP TRIGGER IF EXISTS trigger_set_client_status ON public.clients;

-- Cria o novo gatilho
CREATE TRIGGER trigger_set_client_status
BEFORE INSERT OR UPDATE ON public.clients
FOR EACH ROW
EXECUTE FUNCTION public.set_client_status_based_on_due_date();
--- Contedo de: supabase/migrations/0005_criando_a_tabela_subscriptions_com_rls_e_trigger_para_gerenciar_assinaturas_de_usu_rios_.sql ---
-- Tabela para armazenar detalhes da assinatura de cada utilizador
CREATE TABLE public.subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
  plan_name TEXT NOT NULL,
  price DECIMAL(10, 2) NOT NULL,
  status TEXT NOT NULL DEFAULT 'inactive', -- ex: 'active', 'inactive', 'past_due'
  next_billing_date DATE NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Habilitar Row Level Security
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;

-- Polticas de Segurana: Utilizadores s podem ver e gerir a sua prpria assinatura
CREATE POLICY "Users can view their own subscription" ON public.subscriptions
FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can update their own subscription" ON public.subscriptions
FOR UPDATE USING (auth.uid() = user_id);

-- Trigger para atualizar 'updated_at'
CREATE TRIGGER update_subscriptions_updated_at 
BEFORE UPDATE ON public.subscriptions 
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
--- Contedo de: supabase/migrations/0006_criando_a_tabela_automations_com_rls_e_trigger_para_gerenciar_regras_de_automa_o_.sql ---
-- Tabela para armazenar as regras de envio automtico
CREATE TABLE public.automations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  days_offset INT NOT NULL, -- Ex: -3 (3 dias antes), 0 (no dia), 1 (1 dia depois)
  template_id UUID NOT NULL REFERENCES public.templates(id) ON DELETE CASCADE,
  client_ids UUID[] NOT NULL, -- Array de IDs de clientes
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Habilitar Row Level Security
ALTER TABLE public.automations ENABLE ROW LEVEL SECURITY;

-- Polticas de Segurana: Utilizadores s podem gerir as suas prprias automaes
CREATE POLICY "Users can manage their own automations" 
ON public.automations FOR ALL USING (auth.uid() = user_id);

-- Trigger para atualizar 'updated_at'
CREATE TRIGGER update_automations_updated_at 
BEFORE UPDATE ON public.automations 
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
--- Contedo de: supabase/migrations/0007_criando_as_tabelas_pending_sends_e_send_history_com_rls_para_gerenciar_a_fila_e_o_hist_rico_de_envios_de_mensagens_.sql ---
-- Tabela 1: Fila de envios pendentes
-- Esta tabela ir conter todas as mensagens que esto agendadas para serem enviadas.
CREATE TABLE public.pending_sends (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  client_id UUID NOT NULL REFERENCES public.clients(id) ON DELETE CASCADE,
  automation_id UUID NOT NULL REFERENCES public.automations(id) ON DELETE CASCADE,
  template_id UUID NOT NULL REFERENCES public.templates(id) ON DELETE CASCADE,
  scheduled_for DATE NOT NULL, -- Data exata para a qual o envio est agendado
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  -- Garante que no haja agendamentos duplicados para o mesmo cliente na mesma data pela mesma regra
  UNIQUE(client_id, automation_id, scheduled_for) 
);

-- Habilitar Row Level Security
ALTER TABLE public.pending_sends ENABLE ROW LEVEL SECURITY;
-- Polticas: Utilizadores s podem ver e gerir os seus prprios envios pendentes
CREATE POLICY "Users can manage their own pending sends" 
ON public.pending_sends FOR ALL USING (auth.uid() = user_id);


-- Tabela 2: Histrico de envios
-- Esta tabela  um log de todas as tentativas de envio, bem-sucedidas ou no.
CREATE TABLE public.send_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  client_id UUID NOT NULL REFERENCES public.clients(id) ON DELETE CASCADE,
  template_id UUID NOT NULL REFERENCES public.templates(id) ON DELETE CASCADE,
  sent_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  status TEXT NOT NULL CHECK (status IN ('success', 'failed')), -- Status final do envio
  error_message TEXT -- Opcional: para armazenar a razo da falha
);

-- Habilitar Row Level Security
ALTER TABLE public.send_history ENABLE ROW LEVEL SECURITY;
-- Polticas: Utilizadores s podem ver o seu prprio histrico
CREATE POLICY "Users can view their own send history" 
ON public.send_history FOR SELECT USING (auth.uid() = user_id);
--- Contedo de: supabase/migrations/0008_criando_fun_o_e_gatilho_para_remover_clientes_inativos_de_automa_es_e_da_fila_de_envios_pendentes_.sql ---
-- 1. Criar a funo que contm a lgica de remoo
CREATE OR REPLACE FUNCTION public.handle_client_cancellation()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- A funo s executa se o status foi alterado PARA 'inactive'
  IF NEW.status = 'inactive' AND OLD.status != 'inactive' THEN
    
    -- Ao 1: Remover o cliente de todas as futuras mensagens agendadas
    DELETE FROM public.pending_sends
    WHERE client_id = NEW.id;

    -- Ao 2: Remover o ID do cliente de todas as regras de automao
    -- onde ele possa estar presente.
    UPDATE public.automations
    SET client_ids = array_remove(client_ids, NEW.id)
    WHERE user_id = NEW.user_id AND NEW.id = ANY(client_ids);

  END IF;
  
  RETURN NEW;
END;
$$;

-- 2. Criar o gatilho que executa a funo APS uma atualizao na tabela de clientes
-- Primeiro, remove o gatilho antigo se ele existir, para evitar erros
DROP TRIGGER IF EXISTS trigger_handle_client_cancellation ON public.clients;

-- Cria o novo gatilho
CREATE TRIGGER trigger_handle_client_cancellation
AFTER UPDATE ON public.clients
FOR EACH ROW
EXECUTE FUNCTION public.handle_client_cancellation();
--- Contedo de: supabase/migrations/0009_criando_fun_o_e_gatilho_para_remover_clientes_com_status_overdue_da_fila_de_envios_pendentes_.sql ---
-- 1. Criar a funo que ser executada pelo gatilho
CREATE OR REPLACE FUNCTION public.handle_client_overdue_status()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- A funo s executa se o status foi alterado PARA 'overdue'
  IF NEW.status = 'overdue' AND OLD.status != 'overdue' THEN
    
    -- Ao: Remove o cliente de todas as futuras mensagens agendadas
    DELETE FROM public.pending_sends
    WHERE client_id = NEW.id;

  END IF;
  
  RETURN NEW;
END;
$$;

-- 2. Criar o gatilho que executa a funo APS uma atualizao na tabela de clientes
-- Primeiro, remove o gatilho antigo se ele existir, para evitar erros
DROP TRIGGER IF EXISTS trigger_handle_client_overdue_status ON public.clients;

-- Cria o novo gatilho
CREATE TRIGGER trigger_handle_client_overdue_status
AFTER UPDATE ON public.clients
FOR EACH ROW
EXECUTE FUNCTION public.handle_client_overdue_status();
--- Contedo de: supabase/migrations/0010_criando_a_tabela_user_instances_para_gerenciar_as_inst_ncias_do_whatsapp_por_usu_rio_com_rls_e_pol_ticas_de_seguran_a_.sql ---
-- Tabela para mapear utilizadores a nomes de instncia da Evolution API
CREATE TABLE public.user_instances (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
  instance_name TEXT NOT NULL UNIQUE,
  status TEXT NOT NULL DEFAULT 'disconnected', -- ex: 'disconnected', 'connecting', 'connected'
  qr_code_base64 TEXT, -- Para armazenar o QR Code temporariamente
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Habilitar Row Level Security
ALTER TABLE public.user_instances ENABLE ROW LEVEL SECURITY;

-- Polticas: Utilizadores s podem gerir a sua prpria instncia
CREATE POLICY "Users can manage their own instance mapping" 
ON public.user_instances FOR ALL USING (auth.uid() = user_id);

-- Trigger para atualizar 'updated_at' automaticamente
CREATE TRIGGER update_user_instances_updated_at
BEFORE UPDATE ON public.user_instances
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column();
--- Contedo de: supabase/migrations/0011_criando_a_tabela_url_configs_para_armazenar_urls_de_configura_o_do_sistema_com_rls_.sql ---
-- Tabela para armazenar URLs de configurao
CREATE TABLE public.url_configs (
  id INT PRIMARY KEY DEFAULT 1,
  n8n_webhook_url TEXT NOT NULL,
  evolution_listener_url TEXT NOT NULL,
  -- Apenas uma linha pode existir nesta tabela
  CONSTRAINT single_row_check CHECK (id = 1)
);

-- Habilitar Row Level Security (RLS)
ALTER TABLE public.url_configs ENABLE ROW LEVEL SECURITY;

-- Polticas: Apenas utilizadores autenticados podem ler.
CREATE POLICY "Authenticated users can read url configs" 
ON public.url_configs FOR SELECT TO authenticated USING (true);
--- Contedo de: supabase/migrations/0013_criando_a_tabela_scheduled_notifications_com_rls_e_refer_ncias_a_clientes_templates_e_automa_es_.sql ---
-- Criar a tabela scheduled_notifications
CREATE TABLE public.scheduled_notifications (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  client_id UUID NOT NULL REFERENCES public.clients(id) ON DELETE CASCADE,
  template_id UUID NOT NULL REFERENCES public.templates(id) ON DELETE CASCADE,
  automation_id UUID NOT NULL REFERENCES public.automations(id) ON DELETE CASCADE, -- Adicionado para vincular  automao
  send_at TIMESTAMPTZ NOT NULL,
  status TEXT DEFAULT 'pending' NOT NULL, -- 'pending', 'processing', 'sent', 'failed'
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Habilitar RLS (OBRIGATRIO para segurana)
ALTER TABLE public.scheduled_notifications ENABLE ROW LEVEL SECURITY;

-- Polticas RLS: Usurios s podem gerenciar suas prprias tarefas agendadas
CREATE POLICY "Users can view their own scheduled notifications" ON public.scheduled_notifications
FOR SELECT TO authenticated USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own scheduled notifications" ON public.scheduled_notifications
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own scheduled notifications" ON public.scheduled_notifications
FOR UPDATE TO authenticated USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own scheduled notifications" ON public.scheduled_notifications
FOR DELETE TO authenticated USING (auth.uid() = user_id);
--- Contedo de: supabase/migrations/0014_atualizando_a_fun_o_set_client_status_based_on_due_date_para_usar_o_fuso_hor_rio_local_america_sao_paulo_na_determina_o_do_status_do_cliente_.sql ---
CREATE OR REPLACE FUNCTION public.set_client_status_based_on_due_date()
RETURNS trigger
LANGUAGE plpgsql
AS $function$
DECLARE
  local_today DATE;
BEGIN
  -- Obtm a data de hoje no fuso horrio 'America/Sao_Paulo'
  local_today := (NOW() AT TIME ZONE 'America/Sao_Paulo')::DATE;

  -- Apenas atualiza o status se no for 'inactive' (cancelado)
  IF NEW.status != 'inactive' THEN
    -- Se a data de vencimento for anterior a local_today, define o status como 'overdue'
    IF NEW.next_billing_date < local_today THEN
      NEW.status := 'overdue';
    -- Caso contrrio, se for local_today ou no futuro, define o status como 'active'
    ELSE
      NEW.status := 'active';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$function$;
--- Contedo de: supabase/migrations/0015_adicionando_colunas_request_payload_e_response_payload_tabela_webhook_history_e_atualizando_rls_.sql ---
-- Adicionar colunas request_payload e response_payload  tabela webhook_history
ALTER TABLE public.webhook_history
ADD COLUMN request_payload JSONB,
ADD COLUMN response_payload JSONB;

-- Atualizar polticas RLS para incluir as novas colunas
-- A poltica de INSERT j permite a insero de todas as colunas por padro,
-- mas  bom revisar para garantir que no haja restries inesperadas.
-- Se a poltica de INSERT for 'WITH CHECK (auth.uid() = user_id)', ela j cobre as novas colunas.
-- Se for 'true', tambm cobre.

-- Exemplo de reviso/criao de poltica de INSERT (se necessrio, ajuste conforme sua poltica existente)
-- CREATE OR REPLACE POLICY "Users can insert their own webhook history" ON public.webhook_history
-- FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);

-- A poltica de SELECT tambm deve permitir a leitura das novas colunas.
-- CREATE OR REPLACE POLICY "Users can view their own webhook history" ON public.webhook_history
-- FOR SELECT TO authenticated USING (auth.uid() = user_id);

-- Se as polticas existentes j so abrangentes (e.g., SELECT USING (true) ou INSERT WITH CHECK (true)),
-- no  necessrio alter-las explicitamente para as novas colunas.
-- No entanto, se houver polticas mais restritivas, elas precisariam ser atualizadas.
-- Com base no seu schema, as polticas existentes para webhook_history so:
-- "Users can view their own webhook history" ON webhook_history FOR SELECT USING (auth.uid() = user_id);
-- "Users can insert their own webhook history" ON webhook_history FOR INSERT;
-- A poltica de INSERT atual  muito permissiva. Vamos ajust-la para ser mais segura.

DROP POLICY IF EXISTS "Users can insert their own webhook history" ON public.webhook_history;
CREATE POLICY "Users can insert their own webhook history" ON public.webhook_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);

-- A poltica de SELECT j est boa.
--- Contedo de: supabase/migrations/0016_adicionando_colunas_client_id_e_template_id_tabela_webhook_history_e_criando_chaves_estrangeiras_.sql ---
ALTER TABLE public.webhook_history
ADD COLUMN client_id UUID REFERENCES public.clients(id) ON DELETE SET NULL,
ADD COLUMN template_id UUID REFERENCES public.templates(id) ON DELETE SET NULL;

-- As polticas RLS existentes para webhook_history j cobrem a insero e seleo de todas as colunas
-- para o user_id autenticado, ento no precisam de modificao explcita para as novas colunas.
-- A poltica de INSERT j foi ajustada na etapa anterior para ser mais segura.
--- Contedo de: supabase/migrations/0017_criando_as_tabelas_evolution_api_history_n8n_qr_code_history_e_n8n_message_sender_history_com_rls_e_chaves_estrangeiras_.sql ---
-- Create evolution_api_history table
CREATE TABLE public.evolution_api_history (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  webhook_type TEXT NOT NULL,
  payload JSONB NOT NULL,
  request_payload JSONB,
  response_payload JSONB,
  status_code INTEGER,
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  client_id UUID REFERENCES public.clients(id) ON DELETE SET NULL,
  template_id UUID REFERENCES public.templates(id) ON DELETE SET NULL,
  client_name_snapshot TEXT
);

-- Enable RLS for evolution_api_history
ALTER TABLE public.evolution_api_history ENABLE ROW LEVEL SECURITY;

-- Policies for evolution_api_history
CREATE POLICY "evolution_api_history_select_policy" ON public.evolution_api_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "evolution_api_history_insert_policy" ON public.evolution_api_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "evolution_api_history_update_policy" ON public.evolution_api_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "evolution_api_history_delete_policy" ON public.evolution_api_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Create n8n_qr_code_history table
CREATE TABLE public.n8n_qr_code_history (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  webhook_type TEXT NOT NULL,
  payload JSONB NOT NULL,
  request_payload JSONB,
  response_payload JSONB,
  status_code INTEGER,
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  client_id UUID REFERENCES public.clients(id) ON DELETE SET NULL,
  template_id UUID REFERENCES public.templates(id) ON DELETE SET NULL,
  client_name_snapshot TEXT
);

-- Enable RLS for n8n_qr_code_history
ALTER TABLE public.n8n_qr_code_history ENABLE ROW LEVEL SECURITY;

-- Policies for n8n_qr_code_history
CREATE POLICY "n8n_qr_code_history_select_policy" ON public.n8n_qr_code_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_qr_code_history_insert_policy" ON public.n8n_qr_code_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "n8n_qr_code_history_update_policy" ON public.n8n_qr_code_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_qr_code_history_delete_policy" ON public.n8n_qr_code_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Create n8n_message_sender_history table
CREATE TABLE public.n8n_message_sender_history (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  webhook_type TEXT NOT NULL,
  payload JSONB NOT NULL,
  request_payload JSONB,
  response_payload JSONB,
  status_code INTEGER,
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  client_id UUID REFERENCES public.clients(id) ON DELETE SET NULL,
  template_id UUID REFERENCES public.templates(id) ON DELETE SET NULL,
  client_name_snapshot TEXT
);

-- Enable RLS for n8n_message_sender_history
ALTER TABLE public.n8n_message_sender_history ENABLE ROW LEVEL SECURITY;

-- Policies for n8n_message_sender_history
CREATE POLICY "n8n_message_sender_history_select_policy" ON public.n8n_message_sender_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_message_sender_history_insert_policy" ON public.n8n_message_sender_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "n8n_message_sender_history_update_policy" ON public.n8n_message_sender_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_message_sender_history_delete_policy" ON public.n8n_message_sender_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);
--- Contedo de: supabase/migrations/0018_criando_a_tabela_evolution_logout_history_com_rls_e_pol_ticas_de_seguran_a_.sql ---
-- Create evolution_logout_history table
CREATE TABLE public.evolution_logout_history (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  webhook_type TEXT NOT NULL,
  payload JSONB NOT NULL,
  request_payload JSONB,
  response_payload JSONB,
  status_code INTEGER,
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  client_id UUID REFERENCES public.clients(id) ON DELETE SET NULL,
  template_id UUID REFERENCES public.templates(id) ON DELETE SET NULL,
  client_name_snapshot TEXT
);

-- Enable RLS (REQUIRED)
ALTER TABLE public.evolution_logout_history ENABLE ROW LEVEL SECURITY;

-- Create policies for each operation
CREATE POLICY "evolution_logout_history_select_policy" ON public.evolution_logout_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);

CREATE POLICY "evolution_logout_history_insert_policy" ON public.evolution_logout_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);

CREATE POLICY "evolution_logout_history_update_policy" ON public.evolution_logout_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);

CREATE POLICY "evolution_logout_history_delete_policy" ON public.evolution_logout_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);
--- Contedo de: supabase/migrations/0019_updating_rls_policies_for_all_user_specific_tables_to_ensure_multi_tenant_data_isolation_.sql ---
-- Enable RLS on all tables that store user-specific data if not already enabled
ALTER TABLE public.clients ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.automations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.financial_entries ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.scheduled_notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.webhook_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_instances ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.connection_status ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.evolution_api_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.n8n_qr_code_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.n8n_message_sender_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.evolution_logout_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Recreate or update RLS policies for 'clients' table
DROP POLICY IF EXISTS "Users can manage their own clients" ON public.clients;
CREATE POLICY "Users can manage their own clients" ON public.clients
FOR ALL TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Recreate or update RLS policies for 'plans' table
DROP POLICY IF EXISTS "Users can manage their own plans" ON public.plans;
CREATE POLICY "Users can manage their own plans" ON public.plans
FOR ALL TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Recreate or update RLS policies for 'templates' table
DROP POLICY IF EXISTS "Users can manage their own templates" ON public.templates;
CREATE POLICY "Users can manage their own templates" ON public.templates
FOR ALL TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Recreate or update RLS policies for 'automations' table
DROP POLICY IF EXISTS "Users can manage their own automations" ON public.automations;
CREATE POLICY "Users can manage their own automations" ON public.automations
FOR ALL TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Recreate or update RLS policies for 'financial_entries' table
DROP POLICY IF EXISTS "Users can view their own financial entries" ON public.financial_entries;
DROP POLICY IF EXISTS "Users can insert their own financial entries" ON public.financial_entries;
DROP POLICY IF EXISTS "Users can update their own financial entries" ON public.financial_entries;
DROP POLICY IF EXISTS "Users can delete their own financial entries" ON public.financial_entries;
CREATE POLICY "Users can view their own financial entries" ON public.financial_entries
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own financial entries" ON public.financial_entries
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own financial entries" ON public.financial_entries
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own financial entries" ON public.financial_entries
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'scheduled_notifications' table
DROP POLICY IF EXISTS "Users can view their own scheduled notifications" ON public.scheduled_notifications;
DROP POLICY IF EXISTS "Users can insert their own scheduled notifications" ON public.scheduled_notifications;
DROP POLICY IF EXISTS "Users can update their own scheduled notifications" ON public.scheduled_notifications;
DROP POLICY IF EXISTS "Users can delete their own scheduled notifications" ON public.scheduled_notifications;
CREATE POLICY "Users can view their own scheduled notifications" ON public.scheduled_notifications
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own scheduled notifications" ON public.scheduled_notifications
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own scheduled notifications" ON public.scheduled_notifications
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own scheduled notifications" ON public.scheduled_notifications
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'webhook_history' table
DROP POLICY IF EXISTS "Users can view their own webhook history" ON public.webhook_history;
DROP POLICY IF EXISTS "Users can insert their own webhook history" ON public.webhook_history;
CREATE POLICY "Users can view their own webhook history" ON public.webhook_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own webhook history" ON public.webhook_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
-- Add UPDATE and DELETE policies for webhook_history
DROP POLICY IF EXISTS "Users can update their own webhook history" ON public.webhook_history;
DROP POLICY IF EXISTS "Users can delete their own webhook history" ON public.webhook_history;
CREATE POLICY "Users can update their own webhook history" ON public.webhook_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own webhook history" ON public.webhook_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'user_instances' table
DROP POLICY IF EXISTS "Users can manage their own instance mapping" ON public.user_instances;
CREATE POLICY "Users can manage their own instance mapping" ON public.user_instances
FOR ALL TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Recreate or update RLS policies for 'connection_status' table
DROP POLICY IF EXISTS "Users can view their own connection status" ON public.connection_status;
DROP POLICY IF EXISTS "Users can insert their own connection status" ON public.connection_status;
DROP POLICY IF EXISTS "Users can update their own connection status" ON public.connection_status;
DROP POLICY IF EXISTS "Users can delete their own connection status" ON public.connection_status;
CREATE POLICY "Users can view their own connection status" ON public.connection_status
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own connection status" ON public.connection_status
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own connection status" ON public.connection_status
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own connection status" ON public.connection_status
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'evolution_api_history' table
DROP POLICY IF EXISTS "evolution_api_history_select_policy" ON public.evolution_api_history;
DROP POLICY IF EXISTS "evolution_api_history_insert_policy" ON public.evolution_api_history;
DROP POLICY IF EXISTS "evolution_api_history_update_policy" ON public.evolution_api_history;
DROP POLICY IF EXISTS "evolution_api_history_delete_policy" ON public.evolution_api_history;
CREATE POLICY "evolution_api_history_select_policy" ON public.evolution_api_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "evolution_api_history_insert_policy" ON public.evolution_api_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "evolution_api_history_update_policy" ON public.evolution_api_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "evolution_api_history_delete_policy" ON public.evolution_api_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'n8n_qr_code_history' table
DROP POLICY IF EXISTS "n8n_qr_code_history_select_policy" ON public.n8n_qr_code_history;
DROP POLICY IF EXISTS "n8n_qr_code_history_insert_policy" ON public.n8n_qr_code_history;
DROP POLICY IF EXISTS "n8n_qr_code_history_update_policy" ON public.n8n_qr_code_history;
DROP POLICY IF EXISTS "n8n_qr_code_history_delete_policy" ON public.n8n_qr_code_history;
CREATE POLICY "n8n_qr_code_history_select_policy" ON public.n8n_qr_code_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_qr_code_history_insert_policy" ON public.n8n_qr_code_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "n8n_qr_code_history_update_policy" ON public.n8n_qr_code_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_qr_code_history_delete_policy" ON public.n8n_qr_code_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'n8n_message_sender_history' table
DROP POLICY IF EXISTS "n8n_message_sender_history_select_policy" ON public.n8n_message_sender_history;
DROP POLICY IF EXISTS "n8n_message_sender_history_insert_policy" ON public.n8n_message_sender_history;
DROP POLICY IF EXISTS "n8n_message_sender_history_update_policy" ON public.n8n_message_sender_history;
DROP POLICY IF EXISTS "n8n_message_sender_history_delete_policy" ON public.n8n_message_sender_history;
CREATE POLICY "n8n_message_sender_history_select_policy" ON public.n8n_message_sender_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_message_sender_history_insert_policy" ON public.n8n_message_sender_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "n8n_message_sender_history_update_policy" ON public.n8n_message_sender_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_message_sender_history_delete_policy" ON public.n8n_message_sender_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'evolution_logout_history' table
DROP POLICY IF EXISTS "evolution_logout_history_select_policy" ON public.evolution_logout_history;
DROP POLICY IF EXISTS "evolution_logout_history_insert_policy" ON public.evolution_logout_history;
DROP POLICY IF EXISTS "evolution_logout_history_update_policy" ON public.evolution_logout_history;
DROP POLICY IF EXISTS "evolution_logout_history_delete_policy" ON public.evolution_logout_history;
CREATE POLICY "evolution_logout_history_select_policy" ON public.evolution_logout_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "evolution_logout_history_insert_policy" ON public.evolution_logout_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "evolution_logout_history_update_policy" ON public.evolution_logout_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "evolution_logout_history_delete_policy" ON public.evolution_logout_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'logs' table
DROP POLICY IF EXISTS "Users can view their own logs" ON public.logs;
DROP POLICY IF EXISTS "Users can create their own logs" ON public.logs;
CREATE POLICY "Users can view their own logs" ON public.logs
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can create their own logs" ON public.logs
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
-- Add UPDATE and DELETE policies for logs
DROP POLICY IF EXISTS "Users can update their own logs" ON public.logs;
DROP POLICY IF EXISTS "Users can delete their own logs" ON public.logs;
CREATE POLICY "Users can update their own logs" ON public.logs
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own logs" ON public.logs
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'subscriptions' table
DROP POLICY IF EXISTS "Users can view their own subscription" ON public.subscriptions;
DROP POLICY IF EXISTS "Users can update their own subscription" ON public.subscriptions;
CREATE POLICY "Users can view their own subscription" ON public.subscriptions
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can update their own subscription" ON public.subscriptions
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
-- Add INSERT and DELETE policies for subscriptions
DROP POLICY IF EXISTS "Users can insert their own subscription" ON public.subscriptions;
DROP POLICY IF EXISTS "Users can delete their own subscription" ON public.subscriptions;
CREATE POLICY "Users can insert their own subscription" ON public.subscriptions
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can delete their own subscription" ON public.subscriptions
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'user_roles' table
DROP POLICY IF EXISTS "Users can view their own roles" ON public.user_roles;
CREATE POLICY "Users can view their own roles" ON public.user_roles
FOR SELECT TO authenticated USING (auth.uid() = user_id);
-- Add INSERT, UPDATE, DELETE policies for user_roles
DROP POLICY IF EXISTS "Users can insert their own roles" ON public.user_roles;
DROP POLICY IF EXISTS "Users can update their own roles" ON public.user_roles;
DROP POLICY IF EXISTS "Users can delete their own roles" ON public.user_roles;
CREATE POLICY "Users can insert their own roles" ON public.user_roles
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own roles" ON public.user_roles
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own roles" ON public.user_roles
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'profiles' table
DROP POLICY IF EXISTS "Users can view their own profile" ON public.profiles;
DROP POLICY IF EXISTS "profiles_insert_policy" ON public.profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;
CREATE POLICY "Users can view their own profile" ON public.profiles
FOR SELECT TO authenticated USING (auth.uid() = id);
CREATE POLICY "profiles_insert_policy" ON public.profiles
FOR INSERT TO authenticated WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile" ON public.profiles
FOR UPDATE TO authenticated USING (auth.uid() = id);
-- Add DELETE policy for profiles
DROP POLICY IF EXISTS "Users can delete their own profile" ON public.profiles;
CREATE POLICY "Users can delete their own profile" ON public.profiles
FOR DELETE TO authenticated USING (auth.uid() = id);

-- Recreate or update RLS policies for 'webhook_configs' table
DROP POLICY IF EXISTS "Users can view their own webhook configs" ON public.webhook_configs;
DROP POLICY IF EXISTS "Users can insert their own webhook configs" ON public.webhook_configs;
DROP POLICY IF EXISTS "Users can update their own webhook configs" ON public.webhook_configs;
DROP POLICY IF EXISTS "Users can delete their own webhook configs" ON public.webhook_configs;
CREATE POLICY "Users can view their own webhook configs" ON public.webhook_configs
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own webhook configs" ON public.webhook_configs
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own webhook configs" ON public.webhook_configs
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own webhook configs" ON public.webhook_configs
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- RLS for 'send_history' table
DROP POLICY IF EXISTS "Users can view their own send history" ON public.send_history;
DROP POLICY IF EXISTS "Users can insert their own send history" ON public.send_history;
DROP POLICY IF EXISTS "Users can update their own send history" ON public.send_history;
DROP POLICY IF EXISTS "Users can delete their own send history" ON public.send_history;
CREATE POLICY "Users can view their own send history" ON public.send_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own send history" ON public.send_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own send history" ON public.send_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own send history" ON public.send_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- The 'url_configs' table is for global configurations, so public read access for authenticated users is appropriate.
-- No changes needed for 'Authenticated users can read url configs' policy.
--- Contedo de: supabase/migrations/0020_updating_rls_policies_for_all_user_specific_tables_to_ensure_multi_tenant_data_isolation_.sql ---
-- Enable RLS on all tables that store user-specific data if not already enabled
ALTER TABLE public.clients ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.automations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.financial_entries ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.scheduled_notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.webhook_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_instances ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.connection_status ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.evolution_api_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.n8n_qr_code_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.n8n_message_sender_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.evolution_logout_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Recreate or update RLS policies for 'clients' table
DROP POLICY IF EXISTS "Users can manage their own clients" ON public.clients;
CREATE POLICY "Users can manage their own clients" ON public.clients
FOR ALL TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Recreate or update RLS policies for 'plans' table
DROP POLICY IF EXISTS "Users can manage their own plans" ON public.plans;
CREATE POLICY "Users can manage their own plans" ON public.plans
FOR ALL TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Recreate or update RLS policies for 'templates' table
DROP POLICY IF EXISTS "Users can manage their own templates" ON public.templates;
CREATE POLICY "Users can manage their own templates" ON public.templates
FOR ALL TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Recreate or update RLS policies for 'automations' table
DROP POLICY IF EXISTS "Users can manage their own automations" ON public.automations;
CREATE POLICY "Users can manage their own automations" ON public.automations
FOR ALL TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Recreate or update RLS policies for 'financial_entries' table
DROP POLICY IF EXISTS "Users can view their own financial entries" ON public.financial_entries;
DROP POLICY IF EXISTS "Users can insert their own financial entries" ON public.financial_entries;
DROP POLICY IF EXISTS "Users can update their own financial entries" ON public.financial_entries;
DROP POLICY IF EXISTS "Users can delete their own financial entries" ON public.financial_entries;
CREATE POLICY "Users can view their own financial entries" ON public.financial_entries
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own financial entries" ON public.financial_entries
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own financial entries" ON public.financial_entries
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own financial entries" ON public.financial_entries
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'scheduled_notifications' table
DROP POLICY IF EXISTS "Users can view their own scheduled notifications" ON public.scheduled_notifications;
DROP POLICY IF EXISTS "Users can insert their own scheduled notifications" ON public.scheduled_notifications;
DROP POLICY IF EXISTS "Users can update their own scheduled notifications" ON public.scheduled_notifications;
DROP POLICY IF EXISTS "Users can delete their own scheduled notifications" ON public.scheduled_notifications;
CREATE POLICY "Users can view their own scheduled notifications" ON public.scheduled_notifications
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own scheduled notifications" ON public.scheduled_notifications
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own scheduled notifications" ON public.scheduled_notifications
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own scheduled notifications" ON public.scheduled_notifications
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'webhook_history' table
DROP POLICY IF EXISTS "Users can view their own webhook history" ON public.webhook_history;
DROP POLICY IF EXISTS "Users can insert their own webhook history" ON public.webhook_history;
CREATE POLICY "Users can view their own webhook history" ON public.webhook_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own webhook history" ON public.webhook_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
-- Add UPDATE and DELETE policies for webhook_history
DROP POLICY IF EXISTS "Users can update their own webhook history" ON public.webhook_history;
DROP POLICY IF EXISTS "Users can delete their own webhook history" ON public.webhook_history;
CREATE POLICY "Users can update their own webhook history" ON public.webhook_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own webhook history" ON public.webhook_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'user_instances' table
DROP POLICY IF EXISTS "Users can manage their own instance mapping" ON public.user_instances;
CREATE POLICY "Users can manage their own instance mapping" ON public.user_instances
FOR ALL TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Recreate or update RLS policies for 'connection_status' table
DROP POLICY IF EXISTS "Users can view their own connection status" ON public.connection_status;
DROP POLICY IF EXISTS "Users can insert their own connection status" ON public.connection_status;
DROP POLICY IF EXISTS "Users can update their own connection status" ON public.connection_status;
DROP POLICY IF EXISTS "Users can delete their own connection status" ON public.connection_status;
CREATE POLICY "Users can view their own connection status" ON public.connection_status
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own connection status" ON public.connection_status
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own connection status" ON public.connection_status
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own connection status" ON public.connection_status
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'evolution_api_history' table
DROP POLICY IF EXISTS "evolution_api_history_select_policy" ON public.evolution_api_history;
DROP POLICY IF EXISTS "evolution_api_history_insert_policy" ON public.evolution_api_history;
DROP POLICY IF EXISTS "evolution_api_history_update_policy" ON public.evolution_api_history;
DROP POLICY IF EXISTS "evolution_api_history_delete_policy" ON public.evolution_api_history;
CREATE POLICY "evolution_api_history_select_policy" ON public.evolution_api_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "evolution_api_history_insert_policy" ON public.evolution_api_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "evolution_api_history_update_policy" ON public.evolution_api_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "evolution_api_history_delete_policy" ON public.evolution_api_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'n8n_qr_code_history' table
DROP POLICY IF EXISTS "n8n_qr_code_history_select_policy" ON public.n8n_qr_code_history;
DROP POLICY IF EXISTS "n8n_qr_code_history_insert_policy" ON public.n8n_qr_code_history;
DROP POLICY IF EXISTS "n8n_qr_code_history_update_policy" ON public.n8n_qr_code_history;
DROP POLICY IF EXISTS "n8n_qr_code_history_delete_policy" ON public.n8n_qr_code_history;
CREATE POLICY "n8n_qr_code_history_select_policy" ON public.n8n_qr_code_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_qr_code_history_insert_policy" ON public.n8n_qr_code_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "n8n_qr_code_history_update_policy" ON public.n8n_qr_code_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_qr_code_history_delete_policy" ON public.n8n_qr_code_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'n8n_message_sender_history' table
DROP POLICY IF EXISTS "n8n_message_sender_history_select_policy" ON public.n8n_message_sender_history;
DROP POLICY IF EXISTS "n8n_message_sender_history_insert_policy" ON public.n8n_message_sender_history;
DROP POLICY IF EXISTS "n8n_message_sender_history_update_policy" ON public.n8n_message_sender_history;
DROP POLICY IF EXISTS "n8n_message_sender_history_delete_policy" ON public.n8n_message_sender_history;
CREATE POLICY "n8n_message_sender_history_select_policy" ON public.n8n_message_sender_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_message_sender_history_insert_policy" ON public.n8n_message_sender_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "n8n_message_sender_history_update_policy" ON public.n8n_message_sender_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_message_sender_history_delete_policy" ON public.n8n_message_sender_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'evolution_logout_history' table
DROP POLICY IF EXISTS "evolution_logout_history_select_policy" ON public.evolution_logout_history;
DROP POLICY IF EXISTS "evolution_logout_history_insert_policy" ON public.evolution_logout_history;
DROP POLICY IF EXISTS "evolution_logout_history_update_policy" ON public.evolution_logout_history;
DROP POLICY IF EXISTS "evolution_logout_history_delete_policy" ON public.evolution_logout_history;
CREATE POLICY "evolution_logout_history_select_policy" ON public.evolution_logout_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "evolution_logout_history_insert_policy" ON public.evolution_logout_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "evolution_logout_history_update_policy" ON public.evolution_logout_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "evolution_logout_history_delete_policy" ON public.evolution_logout_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'logs' table
DROP POLICY IF EXISTS "Users can view their own logs" ON public.logs;
DROP POLICY IF EXISTS "Users can create their own logs" ON public.logs;
CREATE POLICY "Users can view their own logs" ON public.logs
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can create their own logs" ON public.logs
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
-- Add UPDATE and DELETE policies for logs
DROP POLICY IF EXISTS "Users can update their own logs" ON public.logs;
DROP POLICY IF EXISTS "Users can delete their own logs" ON public.logs;
CREATE POLICY "Users can update their own logs" ON public.logs
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own logs" ON public.logs
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'subscriptions' table
DROP POLICY IF EXISTS "Users can view their own subscription" ON public.subscriptions;
DROP POLICY IF EXISTS "Users can update their own subscription" ON public.subscriptions;
CREATE POLICY "Users can view their own subscription" ON public.subscriptions
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can update their own subscription" ON public.subscriptions
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
-- Add INSERT and DELETE policies for subscriptions
DROP POLICY IF EXISTS "Users can insert their own subscription" ON public.subscriptions;
DROP POLICY IF EXISTS "Users can delete their own subscription" ON public.subscriptions;
CREATE POLICY "Users can insert their own subscription" ON public.subscriptions
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can delete their own subscription" ON public.subscriptions
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'user_roles' table
DROP POLICY IF EXISTS "Users can view their own roles" ON public.user_roles;
CREATE POLICY "Users can view their own roles" ON public.user_roles
FOR SELECT TO authenticated USING (auth.uid() = user_id);
-- Add INSERT, UPDATE, DELETE policies for user_roles
DROP POLICY IF EXISTS "Users can insert their own roles" ON public.user_roles;
DROP POLICY IF EXISTS "Users can update their own roles" ON public.user_roles;
DROP POLICY IF EXISTS "Users can delete their own roles" ON public.user_roles;
CREATE POLICY "Users can insert their own roles" ON public.user_roles
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own roles" ON public.user_roles
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own roles" ON public.user_roles
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'profiles' table
DROP POLICY IF EXISTS "Users can view their own profile" ON public.profiles;
DROP POLICY IF EXISTS "profiles_insert_policy" ON public.profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;
CREATE POLICY "Users can view their own profile" ON public.profiles
FOR SELECT TO authenticated USING (auth.uid() = id);
CREATE POLICY "profiles_insert_policy" ON public.profiles
FOR INSERT TO authenticated WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile" ON public.profiles
FOR UPDATE TO authenticated USING (auth.uid() = id);
-- Add DELETE policy for profiles
DROP POLICY IF EXISTS "Users can delete their own profile" ON public.profiles;
CREATE POLICY "Users can delete their own profile" ON public.profiles
FOR DELETE TO authenticated USING (auth.uid() = id);

-- Recreate or update RLS policies for 'webhook_configs' table
DROP POLICY IF EXISTS "Users can view their own webhook configs" ON public.webhook_configs;
DROP POLICY IF EXISTS "Users can insert their own webhook configs" ON public.webhook_configs;
DROP POLICY IF EXISTS "Users can update their own webhook configs" ON public.webhook_configs;
DROP POLICY IF EXISTS "Users can delete their own webhook configs" ON public.webhook_configs;
CREATE POLICY "Users can view their own webhook configs" ON public.webhook_configs
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own webhook configs" ON public.webhook_configs
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own webhook configs" ON public.webhook_configs
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own webhook configs" ON public.webhook_configs
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- RLS for 'send_history' table
DROP POLICY IF EXISTS "Users can view their own send history" ON public.send_history;
DROP POLICY IF EXISTS "Users can insert their own send history" ON public.send_history;
DROP POLICY IF EXISTS "Users can update their own send history" ON public.send_history;
DROP POLICY IF EXISTS "Users can delete their own send history" ON public.send_history;
CREATE POLICY "Users can view their own send history" ON public.send_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own send history" ON public.send_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own send history" ON public.send_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own send history" ON public.send_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- The 'url_configs' table is for global configurations, so public read access for authenticated users is appropriate.
-- No changes needed for 'Authenticated users can read url configs' policy.
--- Contedo de: supabase/migrations/0021_updating_rls_policies_for_all_user_specific_tables_and_webhook_configs_to_implement_role_based_access_control_rbac_.sql ---
-- Etapa 1: Modificar Polticas RLS para Acesso de Admin em tabelas com user_id
-- Aplicar o padro "Users can manage their own data OR Admins can manage all"

-- Tables with FOR ALL policies
-- clients
DROP POLICY IF EXISTS "Users can manage their own clients" ON public.clients;
CREATE POLICY "Users can manage their own clients OR Admins can manage all" ON public.clients
FOR ALL TO authenticated
USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin')
WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- plans
DROP POLICY IF EXISTS "Users can manage their own plans" ON public.plans;
CREATE POLICY "Users can manage their own plans OR Admins can manage all" ON public.plans
FOR ALL TO authenticated
USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin')
WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- templates
DROP POLICY IF EXISTS "Users can manage their own templates" ON public.templates;
CREATE POLICY "Users can manage their own templates OR Admins can manage all" ON public.templates
FOR ALL TO authenticated
USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin')
WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- automations
DROP POLICY IF EXISTS "Users can manage their own automations" ON public.automations;
CREATE POLICY "Users can manage their own automations OR Admins can manage all" ON public.automations
FOR ALL TO authenticated
USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin')
WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- user_instances
DROP POLICY IF EXISTS "Users can manage their own instance mapping" ON public.user_instances;
CREATE POLICY "Users can manage their own instance mapping OR Admins can manage all" ON public.user_instances
FOR ALL TO authenticated
USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin')
WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- Tables with specific SELECT/INSERT/UPDATE/DELETE policies
-- financial_entries
DROP POLICY IF EXISTS "Users can view their own financial entries" ON public.financial_entries;
DROP POLICY IF EXISTS "Users can insert their own financial entries" ON public.financial_entries;
DROP POLICY IF EXISTS "Users can update their own financial entries" ON public.financial_entries;
DROP POLICY IF EXISTS "Users can delete their own financial entries" ON public.financial_entries;
CREATE POLICY "Users can view their own financial entries OR Admins can view all" ON public.financial_entries
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can insert their own financial entries OR Admins can insert for others" ON public.financial_entries
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can update their own financial entries OR Admins can update for others" ON public.financial_entries
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can delete their own financial entries OR Admins can delete for others" ON public.financial_entries
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- scheduled_notifications
DROP POLICY IF EXISTS "Users can view their own scheduled notifications" ON public.scheduled_notifications;
DROP POLICY IF EXISTS "Users can insert their own scheduled notifications" ON public.scheduled_notifications;
DROP POLICY IF EXISTS "Users can update their own scheduled notifications" ON public.scheduled_notifications;
DROP POLICY IF EXISTS "Users can delete their own scheduled notifications" ON public.scheduled_notifications;
CREATE POLICY "Users can view their own scheduled notifications OR Admins can view all" ON public.scheduled_notifications
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can insert their own scheduled notifications OR Admins can insert for others" ON public.scheduled_notifications
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can update their own scheduled notifications OR Admins can update for others" ON public.scheduled_notifications
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can delete their own scheduled notifications OR Admins can delete for others" ON public.scheduled_notifications
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- webhook_history
DROP POLICY IF EXISTS "Users can view their own webhook history" ON public.webhook_history;
DROP POLICY IF EXISTS "Users can insert their own webhook history" ON public.webhook_history;
DROP POLICY IF EXISTS "Users can update their own webhook history" ON public.webhook_history;
DROP POLICY IF EXISTS "Users can delete their own webhook history" ON public.webhook_history;
CREATE POLICY "Users can view their own webhook history OR Admins can view all" ON public.webhook_history
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can insert their own webhook history OR Admins can insert for others" ON public.webhook_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can update their own webhook history OR Admins can update for others" ON public.webhook_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can delete their own webhook history OR Admins can delete for others" ON public.webhook_history
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- connection_status
DROP POLICY IF EXISTS "Users can view their own connection status" ON public.connection_status;
DROP POLICY IF EXISTS "Users can insert their own connection status" ON public.connection_status;
DROP POLICY IF EXISTS "Users can update their own connection status" ON public.connection_status;
DROP POLICY IF EXISTS "Users can delete their own connection status" ON public.connection_status;
CREATE POLICY "Users can view their own connection status OR Admins can view all" ON public.connection_status
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can insert their own connection status OR Admins can insert for others" ON public.connection_status
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can update their own connection status OR Admins can update for others" ON public.connection_status
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can delete their own connection status OR Admins can delete for others" ON public.connection_status
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- evolution_api_history
DROP POLICY IF EXISTS "evolution_api_history_select_policy" ON public.evolution_api_history;
DROP POLICY IF EXISTS "evolution_api_history_insert_policy" ON public.evolution_api_history;
DROP POLICY IF EXISTS "evolution_api_history_update_policy" ON public.evolution_api_history;
DROP POLICY IF EXISTS "evolution_api_history_delete_policy" ON public.evolution_api_history;
CREATE POLICY "evolution_api_history_select_policy OR Admins can view all" ON public.evolution_api_history
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "evolution_api_history_insert_policy OR Admins can insert for others" ON public.evolution_api_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "evolution_api_history_update_policy OR Admins can update for others" ON public.evolution_api_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "evolution_api_history_delete_policy OR Admins can delete for others" ON public.evolution_api_history
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- n8n_qr_code_history
DROP POLICY IF EXISTS "n8n_qr_code_history_select_policy" ON public.n8n_qr_code_history;
DROP POLICY IF EXISTS "n8n_qr_code_history_insert_policy" ON public.n8n_qr_code_history;
DROP POLICY IF EXISTS "n8n_qr_code_history_update_policy" ON public.n8n_qr_code_history;
DROP POLICY IF EXISTS "n8n_qr_code_history_delete_policy" ON public.n8n_qr_code_history;
CREATE POLICY "n8n_qr_code_history_select_policy OR Admins can view all" ON public.n8n_qr_code_history
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "n8n_qr_code_history_insert_policy OR Admins can insert for others" ON public.n8n_qr_code_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "n8n_qr_code_history_update_policy OR Admins can update for others" ON public.n8n_qr_code_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "n8n_qr_code_history_delete_policy OR Admins can delete for others" ON public.n8n_qr_code_history
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- n8n_message_sender_history
DROP POLICY IF EXISTS "n8n_message_sender_history_select_policy" ON public.n8n_message_sender_history;
DROP POLICY IF EXISTS "n8n_message_sender_history_insert_policy" ON public.n8n_message_sender_history;
DROP POLICY IF EXISTS "n8n_message_sender_history_update_policy" ON public.n8n_message_sender_history;
DROP POLICY IF EXISTS "n8n_message_sender_history_delete_policy" ON public.n8n_message_sender_history;
CREATE POLICY "n8n_message_sender_history_select_policy OR Admins can view all" ON public.n8n_message_sender_history
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "n8n_message_sender_history_insert_policy OR Admins can insert for others" ON public.n8n_message_sender_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "n8n_message_sender_history_update_policy OR Admins can update for others" ON public.n8n_message_sender_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "n8n_message_sender_history_delete_policy OR Admins can delete for others" ON public.n8n_message_sender_history
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- evolution_logout_history
DROP POLICY IF EXISTS "evolution_logout_history_select_policy" ON public.evolution_logout_history;
DROP POLICY IF EXISTS "evolution_logout_history_insert_policy" ON public.evolution_logout_history;
DROP POLICY IF EXISTS "evolution_logout_history_update_policy" ON public.evolution_logout_history;
DROP POLICY IF EXISTS "evolution_logout_history_delete_policy" ON public.evolution_logout_history;
CREATE POLICY "evolution_logout_history_select_policy OR Admins can view all" ON public.evolution_logout_history
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "evolution_logout_history_insert_policy OR Admins can insert for others" ON public.evolution_logout_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "evolution_logout_history_update_policy OR Admins can update for others" ON public.evolution_logout_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "evolution_logout_history_delete_policy OR Admins can delete for others" ON public.evolution_logout_history
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- logs
DROP POLICY IF EXISTS "Users can view their own logs" ON public.logs;
DROP POLICY IF EXISTS "Users can create their own logs" ON public.logs;
DROP POLICY IF EXISTS "Users can update their own logs" ON public.logs;
DROP POLICY IF EXISTS "Users can delete their own logs" ON public.logs;
CREATE POLICY "Users can view their own logs OR Admins can view all" ON public.logs
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can insert their own logs OR Admins can insert for others" ON public.logs
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can update their own logs OR Admins can update for others" ON public.logs
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can delete their own logs OR Admins can delete for others" ON public.logs
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- subscriptions
DROP POLICY IF EXISTS "Users can view their own subscription" ON public.subscriptions;
DROP POLICY IF EXISTS "Users can update their own subscription" ON public.subscriptions;
DROP POLICY IF EXISTS "Users can insert their own subscription" ON public.subscriptions;
DROP POLICY IF EXISTS "Users can delete their own subscription" ON public.subscriptions;
CREATE POLICY "Users can view their own subscription OR Admins can view all" ON public.subscriptions
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can insert their own subscription OR Admins can insert for others" ON public.subscriptions
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can update their own subscription OR Admins can update for others" ON public.subscriptions
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can delete their own subscription OR Admins can delete for others" ON public.subscriptions
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- user_roles
DROP POLICY IF EXISTS "Users can view their own roles" ON public.user_roles;
DROP POLICY IF EXISTS "Users can insert their own roles" ON public.user_roles;
DROP POLICY IF EXISTS "Users can update their own roles" ON public.user_roles;
DROP POLICY IF EXISTS "Users can delete their own roles" ON public.user_roles;
CREATE POLICY "Users can view their own roles OR Admins can view all" ON public.user_roles
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Admins can manage user roles" ON public.user_roles
FOR ALL TO authenticated USING ((SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin')
WITH CHECK ((SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- profiles (uses 'id' instead of 'user_id')
DROP POLICY IF EXISTS "Users can view their own profile" ON public.profiles;
DROP POLICY IF EXISTS "profiles_insert_policy" ON public.profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can delete their own profile" ON public.profiles;
CREATE POLICY "Users can view their own profile OR Admins can view all" ON public.profiles
FOR SELECT TO authenticated USING (auth.uid() = id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "profiles_insert_policy OR Admins can insert for others" ON public.profiles
FOR INSERT TO authenticated WITH CHECK (auth.uid() = id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can update their own profile OR Admins can update for others" ON public.profiles
FOR UPDATE TO authenticated USING (auth.uid() = id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can delete their own profile OR Admins can delete for others" ON public.profiles
FOR DELETE TO authenticated USING (auth.uid() = id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- send_history
DROP POLICY IF EXISTS "Users can view their own send history" ON public.send_history;
DROP POLICY IF EXISTS "Users can insert their own send history" ON public.send_history;
DROP POLICY IF EXISTS "Users can update their own send history" ON public.send_history;
DROP POLICY IF EXISTS "Users can delete their own send history" ON public.send_history;
CREATE POLICY "Users can view their own send history OR Admins can view all" ON public.send_history
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can insert their own send history OR Admins can insert for others" ON public.send_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can update their own send history OR Admins can update for others" ON public.send_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can delete their own send history OR Admins can delete for others" ON public.send_history
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');


-- Etapa 2: Ajustar Lgica e RLS da Tabela `webhook_configs`
-- Remove existing policies
DROP POLICY IF EXISTS "Users can view their own webhook configs" ON public.webhook_configs;
DROP POLICY IF EXISTS "Users can insert their own webhook configs" ON public.webhook_configs;
DROP POLICY IF EXISTS "Users can update their own webhook configs" ON public.webhook_configs;
DROP POLICY IF EXISTS "Users can delete their own webhook configs" ON public.webhook_configs;

-- New RLS policies for `webhook_configs`
-- SELECT: Allow any authenticated user to read (global config)
CREATE POLICY "Authenticated users can read webhook configs" ON public.webhook_configs
FOR SELECT TO authenticated USING (true);

-- INSERT, UPDATE, DELETE: Allow only Admins to manage
CREATE POLICY "Admins can manage webhook configs" ON public.webhook_configs
FOR ALL TO authenticated
USING ((SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin')
WITH CHECK ((SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- The 'url_configs' table is for global configurations, so public read access for authenticated users is appropriate.
-- No changes needed for 'Authenticated users can read url configs' policy.
--- Contedo de: supabase/migrations/0022_removendo_pol_ticas_rls_existentes_e_criando_novas_pol_ticas_n_o_recursivas_para_a_tabela_user_roles_.sql ---
-- Remover polticas RLS existentes na tabela user_roles para evitar recurso infinita
DROP POLICY IF EXISTS "Users can view their own roles OR Admins can view all" ON public.user_roles;
DROP POLICY IF EXISTS "Admins can manage user roles" ON public.user_roles;

-- Criar poltica RLS para SELECT: Usurios podem ver apenas seu prprio papel
CREATE POLICY "Users can view their own role" ON public.user_roles
FOR SELECT TO authenticated USING (auth.uid() = user_id);

-- Criar poltica RLS para INSERT, UPDATE, DELETE: Usurios podem gerenciar apenas seu prprio papel
CREATE POLICY "Users can manage their own role" ON public.user_roles
FOR ALL TO authenticated USING (auth.uid() = user_id);

-- Opcional: Se voc precisa que administradores vejam *todos* os papis via RLS no frontend,
-- e no apenas atravs de funes de backend com service_role, voc precisaria de uma funo
-- SECURITY INVOKER para verificar o papel de admin sem recurso.
-- Por enquanto, a abordagem  que o frontend s busca o prprio papel do usurio,
-- e operaes de admin em massa so feitas via backend (Edge Functions com service_role).

-- Backfill: Inserir papel 'user' para usurios existentes que no tm um
INSERT INTO public.user_roles (user_id, role)
SELECT
    au.id,
    'user'::app_role
FROM
    auth.users au
LEFT JOIN
    public.user_roles ur ON au.id = ur.user_id
WHERE
    ur.user_id IS NULL;
--- Contedo de: supabase/migrations/0023_adicionando_a_coluna_pix_key_tabela_profiles_.sql ---
ALTER TABLE public.profiles
ADD COLUMN pix_key TEXT NULL;

COMMENT ON COLUMN public.profiles.pix_key IS 'Chave PIX do usurio para recebimento de pagamentos.';
--- Contedo de: supabase/migrations/0024_migra_o_tornando_user_id_da_tabela_templates_nul_vel_e_adicionando_pix_key_tabela_profiles_se_ainda_n_o_existir_.sql ---
-- Migrao: Tornando user_id da tabela templates nulvel
ALTER TABLE public.templates
ALTER COLUMN user_id DROP NOT NULL;

-- Migrao: Adicionando pix_key  tabela profiles (se ainda no existir)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'pix_key') THEN
        ALTER TABLE public.profiles ADD COLUMN pix_key TEXT NULL;
        COMMENT ON COLUMN public.profiles.pix_key IS 'Chave PIX do usurio para recebimento de pagamentos.';
    END IF;
END
$$;
--- Contedo de: supabase/migrations/0025_migra_o_atualizando_as_pol_ticas_de_rls_para_a_tabela_templates_.sql ---
-- Migrao: Atualizando as polticas de RLS para a tabela templates

-- Desabilitar RLS temporariamente para remover polticas existentes
ALTER TABLE public.templates DISABLE ROW LEVEL SECURITY;

-- Remover polticas existentes para templates
DROP POLICY IF EXISTS "Users can manage their own templates OR Admins can manage all" ON public.templates;

-- Reabilitar RLS
ALTER TABLE public.templates ENABLE ROW LEVEL SECURITY;

-- Poltica SELECT: Permitir que usurios autenticados leiam seus prprios templates ou templates padro
CREATE POLICY "Allow authenticated users to read their own or standard templates"
ON public.templates FOR SELECT TO authenticated
USING ((auth.uid() = user_id) OR (user_id IS NULL));

-- Poltica INSERT: Permitir que usurios autenticados insiram seus prprios templates
CREATE POLICY "Allow authenticated users to insert their own templates"
ON public.templates FOR INSERT TO authenticated
WITH CHECK (auth.uid() = user_id);

-- Poltica UPDATE: Permitir que proprietrios ou administradores atualizem templates
CREATE POLICY "Allow owners or admins to update templates"
ON public.templates FOR UPDATE TO authenticated
USING (
    (auth.uid() = user_id) OR
    (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'))
)
WITH CHECK (
    (auth.uid() = user_id) OR
    (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'))
);

-- Poltica DELETE: Permitir que proprietrios ou administradores excluam templates
CREATE POLICY "Allow owners or admins to delete templates"
ON public.templates FOR DELETE TO authenticated
USING (
    (auth.uid() = user_id) OR
    (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'))
);
--- Contedo de: supabase/migrations/0026_criando_um_ndice_nico_parcial_na_coluna_name_da_tabela_templates_para_templates_padr_o_user_id_is_null_.sql ---
-- Criando um ndice nico parcial na coluna 'name' da tabela 'templates' para templates padro (user_id IS NULL)
CREATE UNIQUE INDEX IF NOT EXISTS unique_standard_template_name ON public.templates (name) WHERE user_id IS NULL;
--- Contedo de: supabase/migrations/0027_adicionando_o_tipo_enum_template_type_e_a_coluna_type_tabela_templates_com_rls_atualizado_.sql ---
-- Adicionar o tipo ENUM 'template_type' se no existir
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'template_type') THEN
        CREATE TYPE public.template_type AS ENUM ('normal', 'global');
    END IF;
END $$;

-- Adicionar a coluna 'type'  tabela 'templates' se no existir
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'templates' AND column_name = 'type') THEN
        ALTER TABLE public.templates ADD COLUMN type public.template_type DEFAULT 'normal' NOT NULL;
    END IF;
END $$;

-- Remover polticas RLS antigas para templates
DROP POLICY IF EXISTS "Allow authenticated users to read their own or standard templat" ON public.templates;
DROP POLICY IF EXISTS "Allow authenticated users to insert their own templates" ON public.templates;
DROP POLICY IF EXISTS "Allow owners or admins to update templates" ON public.templates;
DROP POLICY IF EXISTS "Allow owners or admins to delete templates" ON public.templates;

-- Criar novas polticas RLS para templates com base no novo campo 'type' e roles
-- SELECT: Usurios autenticados podem ler seus prprios templates, templates padro (user_id IS NULL) e templates globais.
CREATE POLICY "Allow authenticated users to read their own, standard, or global templates"
ON public.templates FOR SELECT TO authenticated
USING (
    (auth.uid() = user_id) OR (user_id IS NULL) OR (type = 'global')
);

-- INSERT: Usurios normais podem inserir seus prprios templates 'normal'. Admins podem inserir qualquer tipo.
CREATE POLICY "Allow users to insert normal templates and admins to insert any type"
ON public.templates FOR INSERT TO authenticated
WITH CHECK (
    (auth.uid() = user_id AND type = 'normal') OR
    (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'))
);

-- UPDATE: Usurios normais podem atualizar seus prprios templates 'normal'. Admins podem atualizar qualquer tipo.
CREATE POLICY "Allow users to update normal templates and admins to update any type"
ON public.templates FOR UPDATE TO authenticated
USING (
    (auth.uid() = user_id AND type = 'normal') OR
    (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'))
)
WITH CHECK (
    (auth.uid() = user_id AND type = 'normal') OR
    (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'))
);

-- DELETE: Usurios normais podem deletar seus prprios templates 'normal'. Admins podem deletar qualquer tipo.
CREATE POLICY "Allow users to delete normal templates and admins to delete any type"
ON public.templates FOR DELETE TO authenticated
USING (
    (auth.uid() = user_id AND type = 'normal') OR
    (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'))
);
--- Contedo de: supabase/migrations/0028_removendo_a_coluna_category_da_tabela_templates_e_o_tipo_template_category_enum_.sql ---
-- 1. Remover a coluna 'category' da tabela 'templates'
ALTER TABLE public.templates DROP COLUMN category;

-- 2. Remover o tipo ENUM 'template_category'
DROP TYPE public.template_category;
--- Contedo de: supabase/migrations/0029_corrigindo_o_erro_ao_remover_a_coluna_category_da_tabela_templates_e_o_tipo_template_category_enum_usando_if_exists_.sql ---
-- 1. Remover a coluna 'category' da tabela 'templates' (se existir)
ALTER TABLE public.templates DROP COLUMN IF EXISTS category;

-- 2. Remover o tipo ENUM 'template_category' (se existir)
DROP TYPE IF EXISTS public.template_category;
--- Contedo de: supabase/migrations/0030_creating_new_tables_for_admin_financial_entries_subscriber_plans_subscriber_templates_and_subscriber_automations_along_with_their_rls_policies_.sql ---
-- Create admin_financial_entries table
CREATE TABLE public.admin_financial_entries (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  admin_user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  subscriber_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  description TEXT NOT NULL,
  value NUMERIC NOT NULL,
  type public.transaction_type NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable RLS for admin_financial_entries
ALTER TABLE public.admin_financial_entries ENABLE ROW LEVEL SECURITY;

-- RLS Policies for admin_financial_entries (Admin only)
CREATE POLICY "Admins can view all admin financial entries" ON public.admin_financial_entries
FOR SELECT TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can insert admin financial entries" ON public.admin_financial_entries
FOR INSERT TO authenticated WITH CHECK (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can update admin financial entries" ON public.admin_financial_entries
FOR UPDATE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can delete admin financial entries" ON public.admin_financial_entries
FOR DELETE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));


-- Create subscriber_plans table
CREATE TABLE public.subscriber_plans (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  name TEXT NOT NULL,
  value NUMERIC NOT NULL,
  period_days INTEGER NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable RLS for subscriber_plans
ALTER TABLE public.subscriber_plans ENABLE ROW LEVEL SECURITY;

-- RLS Policies for subscriber_plans (Admin only)
CREATE POLICY "Admins can view all subscriber plans" ON public.subscriber_plans
FOR SELECT TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can insert subscriber plans" ON public.subscriber_plans
FOR INSERT TO authenticated WITH CHECK (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can update subscriber plans" ON public.subscriber_plans
FOR UPDATE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can delete subscriber plans" ON public.subscriber_plans
FOR DELETE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));


-- Create subscriber_templates table
CREATE TABLE public.subscriber_templates (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  admin_user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- Can be NULL for global templates
  name TEXT NOT NULL,
  content TEXT NOT NULL,
  type public.template_type DEFAULT 'normal' NOT NULL, -- 'normal' or 'global'
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable RLS for subscriber_templates
ALTER TABLE public.subscriber_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies for subscriber_templates (Admin only)
CREATE POLICY "Admins can view all subscriber templates" ON public.subscriber_templates
FOR SELECT TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can insert subscriber templates" ON public.subscriber_templates
FOR INSERT TO authenticated WITH CHECK (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can update subscriber templates" ON public.subscriber_templates
FOR UPDATE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can delete subscriber templates" ON public.subscriber_templates
FOR DELETE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));


-- Create subscriber_automations table
CREATE TABLE public.subscriber_automations (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  admin_user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  days_offset INTEGER NOT NULL,
  subscriber_template_id UUID REFERENCES public.subscriber_templates(id) ON DELETE CASCADE,
  subscriber_ids UUID[] NOT NULL, -- Array of profiles.id
  scheduled_time TIME WITHOUT TIME ZONE DEFAULT '09:00:00' NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable RLS for subscriber_automations
ALTER TABLE public.subscriber_automations ENABLE ROW LEVEL SECURITY;

-- RLS Policies for subscriber_automations (Admin only)
CREATE POLICY "Admins can view all subscriber automations" ON public.subscriber_automations
FOR SELECT TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can insert subscriber automations" ON public.subscriber_automations
FOR INSERT TO authenticated WITH CHECK (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can update subscriber automations" ON public.subscriber_automations
FOR UPDATE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can delete subscriber automations" ON public.subscriber_automations
FOR DELETE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

-- Add triggers for updated_at columns
CREATE TRIGGER update_subscriber_plans_updated_at
BEFORE UPDATE ON public.subscriber_plans
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_subscriber_templates_updated_at
BEFORE UPDATE ON public.subscriber_templates
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_subscriber_automations_updated_at
BEFORE UPDATE ON public.subscriber_automations
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
--- Contedo de: supabase/migrations/0031_adding_type_column_to_scheduled_notifications_table_to_differentiate_between_client_and_subscriber_notifications_.sql ---
ALTER TABLE public.scheduled_notifications
ADD COLUMN type TEXT DEFAULT 'client_notification' NOT NULL;

COMMENT ON COLUMN public.scheduled_notifications.type IS 'Type of notification: client_notification or subscriber_notification.';

-- Update RLS policies for scheduled_notifications to include the new 'type' column
-- Existing policy: Users can view their own scheduled notifications OR Admins can view all
DROP POLICY IF EXISTS "Users can view their own scheduled notifications OR Admins can " ON public.scheduled_notifications;
CREATE POLICY "Users can view their own scheduled notifications OR Admins can view all" ON public.scheduled_notifications
FOR SELECT TO authenticated USING (
  (auth.uid() = user_id AND type = 'client_notification') OR
  (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'))
);

-- Existing policy: Users can insert their own scheduled notifications OR Admins ca
DROP POLICY IF EXISTS "Users can insert their own scheduled notifications OR Admins ca" ON public.scheduled_notifications;
CREATE POLICY "Users can insert their own scheduled notifications OR Admins can insert for others" ON public.scheduled_notifications
FOR INSERT TO authenticated WITH CHECK (
  (auth.uid() = user_id AND type = 'client_notification') OR
  (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'))
);

-- Existing policy: Users can update their own scheduled notifications OR Admins ca
DROP POLICY IF EXISTS "Users can update their own scheduled notifications OR Admins ca" ON public.scheduled_notifications;
CREATE POLICY "Users can update their own scheduled notifications OR Admins can update for others" ON public.scheduled_notifications
FOR UPDATE TO authenticated USING (
  (auth.uid() = user_id AND type = 'client_notification') OR
  (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'))
);

-- Existing policy: Users can delete their own scheduled notifications OR Admins ca
DROP POLICY IF EXISTS "Users can delete their own scheduled notifications OR Admins ca" ON public.scheduled_notifications;
CREATE POLICY "Users can delete their own scheduled notifications OR Admins can delete for others" ON public.scheduled_notifications
FOR DELETE TO authenticated USING (
  (auth.uid() = user_id AND type = 'client_notification') OR
  (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'))
);
--- Contedo de: supabase/migrations/0032_contar_usu_rios_na_tabela_auth_users.sql ---
SELECT count(*) FROM auth.users;
--- Contedo de: supabase/migrations/0033_contar_perfis_na_tabela_public_profiles.sql ---
SELECT count(*) FROM public.profiles;
--- Contedo de: supabase/migrations/0034_visualizar_os_primeiros_5_perfis.sql ---
SELECT id, name, email, created_at FROM public.profiles LIMIT 5;
--- Contedo de: supabase/migrations/0035_visualizar_os_primeiros_5_registros_de_fun_es_de_usu_rio.sql ---
SELECT user_id, role FROM public.user_roles LIMIT 5;
--- Contedo de: supabase/migrations/0036_verificar_usu_rios_sem_perfil_correspondente.sql ---
SELECT au.id, au.email
    FROM auth.users au
    LEFT JOIN public.profiles pp ON au.id = pp.id
    WHERE pp.id IS NULL;
--- Contedo de: supabase/migrations/0037_verificar_usu_rios_sem_fun_o_de_usu_rio_correspondente.sql ---
SELECT au.id, au.email
    FROM auth.users au
    LEFT JOIN public.user_roles ur ON au.id = ur.user_id
    WHERE ur.user_id IS NULL;
--- Contedo de: supabase/migrations/0038_verificar_status_do_gatilho_on_auth_user_created.sql ---
SELECT event_object_table, event_manipulation, action_statement, action_timing, event_object_schema
    FROM information_schema.triggers
    WHERE trigger_name = 'on_auth_user_created';
--- Contedo de: supabase/migrations/0039_update_fk_to_profiles_for_subscriptions_and_user_instances.sql ---
-- Remover a chave estrangeira existente de subscriptions.user_id para auth.users
ALTER TABLE public.subscriptions DROP CONSTRAINT subscriptions_user_id_fkey;

-- Adicionar uma nova chave estrangeira de subscriptions.user_id para public.profiles.id
ALTER TABLE public.subscriptions
ADD CONSTRAINT subscriptions_user_id_fkey
FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;

-- Remover a chave estrangeira existente de user_instances.user_id para auth.users
ALTER TABLE public.user_instances DROP CONSTRAINT user_instances_user_id_fkey;

-- Adicionar uma nova chave estrangeira de user_instances.user_id para public.profiles.id
ALTER TABLE public.user_instances
ADD CONSTRAINT user_instances_user_id_fkey
FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;
--- Contedo de: supabase/migrations/0040_verificar_chave_estrangeira_de_subscriptions_user_id.sql ---
-- Remover a chave estrangeira existente de subscriptions.user_id para auth.users ou profiles, se existir
ALTER TABLE public.subscriptions DROP CONSTRAINT IF EXISTS subscriptions_user_id_fkey;

-- Adicionar uma nova chave estrangeira de subscriptions.user_id para public.profiles.id
ALTER TABLE public.subscriptions
ADD CONSTRAINT subscriptions_user_id_fkey
FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;
--- Contedo de: supabase/migrations/0041_verificar_chave_estrangeira_de_user_instances_user_id.sql ---
-- Remover a chave estrangeira existente de user_instances.user_id para auth.users ou profiles, se existir
ALTER TABLE public.user_instances DROP CONSTRAINT IF EXISTS user_instances_user_id_fkey;

-- Adicionar uma nova chave estrangeira de user_instances.user_id para public.profiles.id
ALTER TABLE public.user_instances
ADD CONSTRAINT user_instances_user_id_fkey
FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;
--- Contedo de: supabase/migrations/0042_atualizando_a_fun_o_handle_new_user_para_criar_uma_assinatura_padr_o_para_novos_usu_rios_.sql ---
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE PLPGSQL
SECURITY DEFINER SET search_path = 'public'
AS $$
BEGIN
  -- Insert into profiles
  INSERT INTO public.profiles (id, name, email)
  VALUES (NEW.id, COALESCE(NEW.raw_user_meta_data->>'name', split_part(NEW.email, '@', 1)), NEW.email);

  -- Insert into user_roles
  INSERT INTO public.user_roles (user_id, role)
  VALUES (NEW.id, 'user');

  -- Insert into subscriptions with a default free plan
  INSERT INTO public.subscriptions (user_id, plan_name, price, status, next_billing_date)
  VALUES (NEW.id, 'Plano Gratuito', 0.00, 'active', (NOW() + INTERVAL '30 days')::date); -- Default to active for 30 days

  RETURN NEW;
END;
$$;
--- Contedo de: supabase/migrations/0043_corrigindo_a_chave_estrangeira_de_subscriptions_user_id_para_profiles_id_inserindo_o_plano_inicial_e_adicionando_gatilho_de_prote_o_.sql ---
-- 1. Remover a chave estrangeira existente em subscriptions.user_id
ALTER TABLE public.subscriptions
DROP CONSTRAINT IF EXISTS subscriptions_user_id_fkey;

-- 2. Adicionar nova chave estrangeira em subscriptions.user_id referenciando public.profiles.id
ALTER TABLE public.subscriptions
ADD CONSTRAINT subscriptions_user_id_fkey
FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;

-- 3. Inserir o "Plano Inicial" na tabela subscriber_plans se no existir
INSERT INTO public.subscriber_plans (name, value, period_days)
SELECT 'Plano Inicial', 25.00, 30
WHERE NOT EXISTS (SELECT 1 FROM public.subscriber_plans WHERE name = 'Plano Inicial');

-- 4. Criar funo para impedir a excluso do "Plano Inicial"
CREATE OR REPLACE FUNCTION public.prevent_default_plan_deletion()
RETURNS TRIGGER
LANGUAGE PLPGSQL
SECURITY DEFINER
SET search_path = 'public'
AS $$
BEGIN
  IF OLD.name = 'Plano Inicial' THEN
    RAISE EXCEPTION 'No  permitido excluir o Plano Inicial. Voc pode edit-lo se necessrio.';
  END IF;
  RETURN OLD;
END;
$$;

-- 5. Criar gatilho para a funo prevent_default_plan_deletion
DROP TRIGGER IF EXISTS prevent_default_plan_deletion_trigger ON public.subscriber_plans;
CREATE TRIGGER prevent_default_plan_deletion_trigger
BEFORE DELETE ON public.subscriber_plans
FOR EACH ROW EXECUTE FUNCTION public.prevent_default_plan_deletion();
--- Contedo de: supabase/migrations/0044_atualizando_a_fun_o_handle_new_user_para_usar_o_plano_inicial_dinamicamente_.sql ---
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE PLPGSQL
SECURITY DEFINER SET search_path = 'public'
AS $$
DECLARE
  default_plan RECORD;
BEGIN
  -- 1. Inserir na tabela profiles
  INSERT INTO public.profiles (id, name, email)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'name', split_part(NEW.email, '@', 1)),
    NEW.email
  );

  -- 2. Inserir na tabela user_roles
  INSERT INTO public.user_roles (user_id, role)
  VALUES (NEW.id, 'user');

  -- 3. Buscar o "Plano Inicial" dinamicamente
  SELECT name, value, period_days
  INTO default_plan
  FROM public.subscriber_plans
  WHERE name = 'Plano Inicial'
  LIMIT 1;

  -- 4. Inserir na tabela subscriptions usando o Plano Inicial
  IF default_plan IS NOT NULL THEN
    INSERT INTO public.subscriptions (user_id, plan_name, price, status, next_billing_date)
    VALUES (
      NEW.id,
      default_plan.name,
      default_plan.value,
      'active',
      (NOW() + (default_plan.period_days || ' days')::INTERVAL)::date
    );
  ELSE
    -- Fallback: Se o Plano Inicial no existir, usar valores padro
    INSERT INTO public.subscriptions (user_id, plan_name, price, status, next_billing_date)
    VALUES (NEW.id, 'Plano Gratuito', 0.00, 'active', (NOW() + INTERVAL '30 days')::date);
  END IF;

  RETURN NEW;
END;
$$;
--- Contedo de: supabase/migrations/0045_limpando_registros_inconsistentes_em_user_instances_e_profiles_e_corrigindo_a_chave_estrangeira_para_user_instances_user_id_.sql ---
-- 1. Deletar registros em user_instances onde o user_id no existe em auth.users
-- Isso remove instncias que apontam para usurios que no existem mais no sistema de autenticao.
DELETE FROM public.user_instances
WHERE user_id NOT IN (SELECT id FROM auth.users);

-- 2. Inserir perfis ausentes para user_ids que existem em auth.users mas no em public.profiles
-- Isso garante que todo user_id referenciado em user_instances tenha um perfil correspondente.
INSERT INTO public.profiles (id, name, email)
SELECT
    au.id,
    -- Tenta usar o nome do metadata, seno usa a parte do email antes do '@', seno 'Usurio'
    COALESCE(au.raw_user_meta_data->>'name', split_part(au.email, '@', 1), 'Usurio'),
    au.email -- Usa o email do auth.users
FROM auth.users au
WHERE au.id IN (
    SELECT ui.user_id
    FROM public.user_instances ui
    LEFT JOIN public.profiles p ON ui.user_id = p.id
    WHERE p.id IS NULL
)
AND au.id NOT IN (SELECT id FROM public.profiles); -- Evita duplicatas se o perfil j foi criado por outro meio

-- 3. Remover a chave estrangeira existente em user_instances.user_id (se existir)
ALTER TABLE public.user_instances
DROP CONSTRAINT IF EXISTS user_instances_user_id_fkey;

-- 4. Adicionar a nova chave estrangeira em user_instances.user_id referenciando public.profiles.id
ALTER TABLE public.user_instances
ADD CONSTRAINT user_instances_user_id_fkey
FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;
--- Contedo de: supabase/migrations/0046_desabilitando_temporariamente_o_gatilho_de_prote_o_consolidando_planos_plano_inicial_duplicados_e_reabilitando_o_gatilho_.sql ---
-- 1. Desabilitar temporariamente o gatilho de proteo
ALTER TABLE public.subscriber_plans DISABLE TRIGGER prevent_default_plan_deletion_trigger;

-- 2. Consolidar entradas duplicadas de 'Plano Inicial' na tabela subscriber_plans
WITH plan_to_keep AS (
    SELECT id
    FROM public.subscriber_plans
    WHERE name = 'Plano Inicial'
    ORDER BY created_at ASC
    LIMIT 1
)
DELETE FROM public.subscriber_plans
WHERE name = 'Plano Inicial'
  AND id NOT IN (SELECT id FROM plan_to_keep);

-- 3. Reabilitar o gatilho de proteo
ALTER TABLE public.subscriber_plans ENABLE TRIGGER prevent_default_plan_deletion_trigger;
--- Contedo de: supabase/migrations/0047_adicionando_a_coluna_phone_tabela_profiles_e_atualizando_a_fun_o_handle_new_user_para_incluir_o_telefone_do_metadata_do_usu_rio_.sql ---
-- Adicionar a coluna 'phone'  tabela 'profiles' se ela no existir
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'phone') THEN
        ALTER TABLE public.profiles ADD COLUMN phone TEXT;
        -- Adicionar um ndice para consultas mais rpidas, se necessrio
        CREATE INDEX IF NOT EXISTS idx_profiles_phone ON public.profiles(phone);
        COMMENT ON COLUMN public.profiles.phone IS 'Nmero de telefone do usurio, obrigatrio para usurios no-admin.';
    END IF;
END
$$;

-- Atualizar a funo handle_new_user para incluir o campo 'phone'
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE PLPGSQL
SECURITY DEFINER SET search_path = ''
AS $$
DECLARE
  default_plan RECORD;
BEGIN
  -- 1. Inserir na tabela profiles
  INSERT INTO public.profiles (id, name, email, phone) -- Adicionado 'phone'
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'name', split_part(NEW.email, '@', 1)),
    NEW.email,
    NEW.raw_user_meta_data->>'phone' -- Tenta pegar o telefone do metadata
  );

  -- 2. Inserir na tabela user_roles
  INSERT INTO public.user_roles (user_id, role)
  VALUES (NEW.id, 'user');

  -- 3. Buscar o "Plano Inicial" dinamicamente
  SELECT name, value, period_days
  INTO default_plan
  FROM public.subscriber_plans
  WHERE name = 'Plano Inicial'
  LIMIT 1;

  -- 4. Inserir na tabela subscriptions usando o Plano Inicial
  IF default_plan IS NOT NULL THEN
    INSERT INTO public.subscriptions (user_id, plan_name, price, status, next_billing_date)
    VALUES (
      NEW.id,
      default_plan.name,
      default_plan.value,
      'active',
      (NOW() + (default_plan.period_days || ' days')::INTERVAL)::date
    );
  ELSE
    -- Fallback: Se o Plano Inicial no existir, usar valores padro
    INSERT INTO public.subscriptions (user_id, plan_name, price, status, next_billing_date)
    VALUES (NEW.id, 'Plano Gratuito', 0.00, 'active', (NOW() + INTERVAL '30 days')::date);
  END IF;

  RETURN NEW;
END;
$$;
--- Contedo de: supabase/migrations/0048_criando_tabelas_pagbank_configs_e_pagbank_charges_com_rls_para_integra_o_pagbank_pix_.sql ---
-- Tabela: pagbank_configs
-- Armazena as credenciais da API do PagBank de forma segura.
CREATE TABLE public.pagbank_configs (
  id BIGINT PRIMARY KEY DEFAULT 1, -- Garante uma nica linha de configurao
  pagbank_email TEXT NOT NULL,
  pagbank_token TEXT NOT NULL,
  pagbank_pix_key TEXT NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Habilitar RLS (Row Level Security)
ALTER TABLE public.pagbank_configs ENABLE ROW LEVEL SECURITY;

-- Polticas de RLS para pagbank_configs: Apenas admins podem ler e escrever
CREATE POLICY "Admins can view PagBank configs" ON public.pagbank_configs
FOR SELECT TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

CREATE POLICY "Admins can insert PagBank configs" ON public.pagbank_configs
FOR INSERT TO authenticated WITH CHECK (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

CREATE POLICY "Admins can update PagBank configs" ON public.pagbank_configs
FOR UPDATE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

-- Tabela: pagbank_charges
-- Rastreia cada cobrana PIX gerada.
CREATE TABLE public.pagbank_charges (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  subscription_id UUID NOT NULL REFERENCES public.subscriptions(id) ON DELETE CASCADE,
  pagbank_charge_id TEXT NOT NULL UNIQUE,
  status TEXT NOT NULL DEFAULT 'PENDING', -- PENDING, PAID, EXPIRED
  value NUMERIC NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Habilitar RLS (Row Level Security)
ALTER TABLE public.pagbank_charges ENABLE ROW LEVEL SECURITY;

-- Polticas de RLS para pagbank_charges:
-- Usurios podem ler apenas suas prprias cobranas. Admins podem ler todas.
CREATE POLICY "Users can view their own PagBank charges" ON public.pagbank_charges
FOR SELECT TO authenticated USING (auth.uid() = user_id OR EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

-- Ningum pode inserir, atualizar ou deletar via RLS diretamente (apenas via Edge Functions com service_role_key)
-- As Edge Functions usaro o service_role_key para manipular esta tabela, ignorando RLS.
--- Contedo de: supabase/migrations/0049_add_tax_id_to_profiles_table.sql ---
-- Adicionando a coluna tax_id (CPF/CNPJ)  tabela public.profiles como TEXT NOT NULL.
ALTER TABLE public.profiles
ADD COLUMN tax_id TEXT NOT NULL DEFAULT '';

COMMENT ON COLUMN public.profiles.tax_id IS 'CPF ou CNPJ do usurio (apenas nmeros). Obrigatrio.';

-- Atualiza registros existentes para ter um valor padro vlido (ex: '00000000000')
-- Isso  necessrio porque a coluna  NOT NULL e pode haver perfis existentes sem esse campo.
-- O usurio dever atualizar seu perfil com um CPF/CNPJ real.
UPDATE public.profiles
SET tax_id = '00000000000'
WHERE tax_id IS NULL OR tax_id = '';
--- Contedo de: supabase/migrations/0049_adicionando_a_coluna_tax_id_cpf_cnpj_tabela_public_profiles_como_text_not_null_.sql ---
ALTER TABLE public.profiles
ADD COLUMN tax_id TEXT NOT NULL DEFAULT '';

COMMENT ON COLUMN public.profiles.tax_id IS 'CPF ou CNPJ do usurio (apenas nmeros). Obrigatrio.';

-- Atualiza registros existentes para ter um valor padro vlido (ex: '00000000000')
-- Isso  necessrio porque a coluna  NOT NULL e pode haver perfis existentes sem esse campo.
-- O usurio dever atualizar seu perfil com um CPF/CNPJ real.
UPDATE public.profiles
SET tax_id = '00000000000'
WHERE tax_id IS NULL OR tax_id = '';
--- Contedo de: supabase/migrations/0050_adicionando_a_coluna_environment_e_o_tipo_enum_pagbank_environment_tabela_pagbank_configs_.sql ---
-- Create the enum type if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'pagbank_environment') THEN
        CREATE TYPE public.pagbank_environment AS ENUM ('sandbox', 'production');
    END IF;
END
$$;

-- Add the 'environment' column to 'pagbank_configs' table
ALTER TABLE public.pagbank_configs
ADD COLUMN environment public.pagbank_environment NOT NULL DEFAULT 'sandbox'::public.pagbank_environment;

-- Add a comment to the new column
COMMENT ON COLUMN public.pagbank_configs.environment IS 'Ambiente da API PagBank a ser utilizado (sandbox ou production).';
--- Contedo de: supabase/migrations/0051_corrigindo_a_migra_o_sql_para_adicionar_a_coluna_environment_tabela_pagbank_configs_apenas_se_ela_n_o_existir_garantindo_idempot_ncia_.sql ---
-- Create the enum type if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'pagbank_environment') THEN
        CREATE TYPE public.pagbank_environment AS ENUM ('sandbox', 'production');
    END IF;
END
$$;

-- Add the 'environment' column to 'pagbank_configs' table if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_schema = 'public'
        AND table_name = 'pagbank_configs'
        AND column_name = 'environment'
    ) THEN
        ALTER TABLE public.pagbank_configs
        ADD COLUMN environment public.pagbank_environment NOT NULL DEFAULT 'sandbox'::public.pagbank_environment;

        -- Add a comment to the new column
        COMMENT ON COLUMN public.pagbank_configs.environment IS 'Ambiente da API PagBank a ser utilizado (sandbox ou production).';
    END IF;
END
$$;
--- Contedo de: supabase/migrations/0052_creating_the_mercado_pago_configs_table_with_rls_policies_.sql ---
CREATE TABLE public.mercado_pago_configs (
  id BIGINT PRIMARY KEY DEFAULT 1,
  mercado_pago_public_key TEXT NOT NULL,
  mercado_pago_access_token TEXT NOT NULL,
  mercado_pago_client_id TEXT NOT NULL,
  mercado_pago_client_secret TEXT NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

ALTER TABLE public.mercado_pago_configs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins can view Mercado Pago configs" ON public.mercado_pago_configs
FOR SELECT TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

CREATE POLICY "Admins can manage Mercado Pago configs" ON public.mercado_pago_configs
FOR ALL TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

-- Ensure only one row exists
ALTER TABLE public.mercado_pago_configs ADD CONSTRAINT enforce_single_row CHECK (id = 1);
--- Contedo de: supabase/migrations/0053_creating_active_payment_gateway_table_with_rls_for_admin_users_.sql ---
-- Create active_payment_gateway table
CREATE TABLE public.active_payment_gateway (
  id BIGINT PRIMARY KEY DEFAULT 1,
  gateway_name TEXT NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable RLS (REQUIRED)
ALTER TABLE public.active_payment_gateway ENABLE ROW LEVEL SECURITY;

-- Policy: Admins can view the active payment gateway
CREATE POLICY "Admins can view active payment gateway" ON public.active_payment_gateway
FOR SELECT TO authenticated
USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

-- Policy: Admins can update the active payment gateway
CREATE POLICY "Admins can update active payment gateway" ON public.active_payment_gateway
FOR UPDATE TO authenticated
USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

-- Policy: Admins can insert the active payment gateway (for initial setup)
CREATE POLICY "Admins can insert active payment gateway" ON public.active_payment_gateway
FOR INSERT TO authenticated
WITH CHECK (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

-- Ensure only one row exists by preventing inserts if id=1 already exists
-- This is handled by the Edge Function's upsert logic, but a unique constraint on id=1 is good.
-- No need for a specific trigger here, the primary key default 1 handles it.
--- Contedo de: supabase/migrations/0054_creating_the_mercado_pago_charges_table_with_rls_policies_for_mercado_pago_integration_.sql ---
-- Create mercado_pago_charges table
CREATE TABLE public.mercado_pago_charges (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  subscription_id UUID NOT NULL REFERENCES public.subscriptions(id) ON DELETE CASCADE,
  mercado_pago_payment_id TEXT NOT NULL UNIQUE,
  status TEXT NOT NULL DEFAULT 'pending', -- e.g., 'pending', 'approved', 'rejected', 'cancelled'
  value NUMERIC NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable RLS (REQUIRED for security)
ALTER TABLE public.mercado_pago_charges ENABLE ROW LEVEL SECURITY;

-- RLS Policies for mercado_pago_charges
-- Users can view their own Mercado Pago charges
CREATE POLICY "Users can view their own Mercado Pago charges" ON public.mercado_pago_charges
FOR SELECT TO authenticated USING (auth.uid() = user_id);

-- Users can insert their own Mercado Pago charges (e.g., when initiating a payment)
CREATE POLICY "Users can insert their own Mercado Pago charges" ON public.mercado_pago_charges
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);

-- Users can update their own Mercado Pago charges (e.g., if status changes on client-side)
CREATE POLICY "Users can update their own Mercado Pago charges" ON public.mercado_pago_charges
FOR UPDATE TO authenticated USING (auth.uid() = user_id);

-- Users can delete their own Mercado Pago charges (if needed, though usually not for payments)
CREATE POLICY "Users can delete their own Mercado Pago charges" ON public.mercado_pago_charges
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Admin policies (optional, but good for full control)
-- Admins can view all Mercado Pago charges
CREATE POLICY "Admins can view all Mercado Pago charges" ON public.mercado_pago_charges
FOR SELECT TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

-- Admins can insert Mercado Pago charges for any user
CREATE POLICY "Admins can insert Mercado Pago charges" ON public.mercado_pago_charges
FOR INSERT TO authenticated WITH CHECK (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

-- Admins can update Mercado Pago charges for any user
CREATE POLICY "Admins can update Mercado Pago charges" ON public.mercado_pago_charges
FOR UPDATE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

-- Admins can delete Mercado Pago charges for any user
CREATE POLICY "Admins can delete Mercado Pago charges" ON public.mercado_pago_charges
FOR DELETE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));
--- Contedo de: supabase/migrations/0055_update_rls_policy_for_active_payment_gateway_to_allow_all_authenticated_users_to_read_.sql ---
DROP POLICY IF EXISTS "Admins can view active payment gateway" ON public.active_payment_gateway;
CREATE POLICY "Authenticated users can view active payment gateway" ON public.active_payment_gateway
FOR SELECT TO authenticated USING (true);
--- Contedo de: supabase/migrations/20240801000000_populate_url_configs.sql ---
-- Este script insere a linha de configurao na tabela url_configs.
-- Se a linha com id=1 j existir, ele atualiza os valores (operao idempotente).

INSERT INTO public.url_configs (id, n8n_webhook_url, evolution_listener_url)
VALUES (
  1,
  -- URL do n8n para criar a instncia (fornecida pelo utilizador)
  'https://tragic-crayfish-noxius-cyberwork-redes2-f82088fb.koyeb.app/webhook/ffd0c002-d429-48a1-8d0d-101d312497c5',
  -- URL do "ouvinte" (a sua Supabase Function).
  'https://cgqyfpsfymhntumrmbzj.supabase.co/functions/v1/evolution-webhook-receiver'
)
ON CONFLICT (id) 
DO UPDATE SET 
  n8n_webhook_url = EXCLUDED.n8n_webhook_url,
  evolution_listener_url = EXCLUDED.evolution_listener_url;
--- Contedo de: supabase/migrations/20240801103000_cleanup_old_cron_scheduler.sql ---
-- Desativar e remover todos os cron jobs conhecidos
SELECT cron.unschedule('process-notification-queue-job');
SELECT cron.unschedule('process-automated-notifications-job');

-- Remover funes SQL que usam tipos da extenso http ou so parte dela
-- Usamos CASCADE para remover quaisquer objetos dependentes (como triggers, se houver)
DROP FUNCTION IF EXISTS public.http_post(character varying, jsonb) CASCADE;
DROP FUNCTION IF EXISTS public.http_post(character varying, character varying, character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http_set_curlopt(character varying, character varying) CASCADE;
DROP FUNCTION IF EXISTS public.bytea_to_text(bytea) CASCADE;
DROP FUNCTION IF EXISTS public.http_header(character varying, character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http_delete(character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http_delete(character varying, character varying, character varying) CASCADE;
DROP FUNCTION IF EXISTS public.urlencode(bytea) CASCADE;
DROP FUNCTION IF EXISTS public.urlencode(character varying) CASCADE;
DROP FUNCTION IF EXISTS public.urlencode(jsonb) CASCADE;
DROP FUNCTION IF EXISTS public.http_head(character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http_list_curlopt() CASCADE;
DROP FUNCTION IF EXISTS public.text_to_bytea(text) CASCADE;
DROP FUNCTION IF EXISTS public.http_reset_curlopt() CASCADE;
DROP FUNCTION IF EXISTS public.http_get(character varying, jsonb) CASCADE;
DROP FUNCTION IF EXISTS public.http_get(character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http(http_request) CASCADE;
DROP FUNCTION IF EXISTS public.http_put(character varying, character varying, character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http_patch(character varying, character varying, character varying) CASCADE;

-- Remover as funes de agendamento que foram substitudas
DROP FUNCTION IF EXISTS public.process_notification_queue CASCADE;
DROP FUNCTION IF EXISTS public.process_automated_notifications CASCADE;

-- Remover a extenso http (pg_net) e seus tipos
DROP EXTENSION IF EXISTS http CASCADE;
DROP TYPE IF EXISTS public.http_request CASCADE;
DROP TYPE IF EXISTS public.http_response CASCADE;
DROP TYPE IF EXISTS public.http_header CASCADE;
--- Contedo de: supabase/migrations/20240802000000_fix_security_warnings.sql ---
-- Correo de Alertas de Segurana do Banco de Dados Supabase

-- 1. Corrigir o search_path das Funes para 'public'

-- Funo: public.set_client_status_based_on_due_date
CREATE OR REPLACE FUNCTION public.set_client_status_based_on_due_date()
RETURNS trigger
LANGUAGE plpgsql
AS $function$
BEGIN
  -- Verifica se o status atual no  'inativo'. No queremos reativar um cliente cancelado automaticamente.
  IF NEW.status != 'inactive' THEN
    -- Se a data de vencimento for anterior a hoje, define o status como 'vencido'.
    IF NEW.next_billing_date < CURRENT_DATE THEN
      NEW.status := 'overdue';
    -- Caso contrrio, define o status como 'ativo'.
    ELSE
      NEW.status := 'active';
    END IF;
  END IF;

  RETURN NEW;
END;
$function$
SET search_path = public;

-- Funo: public.handle_client_cancellation
CREATE OR REPLACE FUNCTION public.handle_client_cancellation()
RETURNS trigger
LANGUAGE plpgsql
AS $function$
BEGIN
  -- A funo s executa se o status foi alterado PARA 'inactive'
  IF NEW.status = 'inactive' AND OLD.status != 'inactive' THEN

    -- Ao 1: Remover o cliente de todas as futuras mensagens agendadas
    DELETE FROM public.pending_sends
    WHERE client_id = NEW.id;

    -- Ao 2: Remover o ID do cliente de todas as regras de automao
    -- onde ele possa estar presente.
    UPDATE public.automations
    SET client_ids = array_remove(client_ids, NEW.id)
    WHERE user_id = NEW.user_id AND NEW.id = ANY(client_ids);

  END IF;

  RETURN NEW;
END;
$function$
SET search_path = public;

-- Funo: public.handle_client_overdue_status
CREATE OR REPLACE FUNCTION public.handle_client_overdue_status()
RETURNS trigger
LANGUAGE plpgsql
AS $function$
BEGIN
  -- A funo s executa se o status foi alterado PARA 'overdue'
  IF NEW.status = 'overdue' AND OLD.status != 'overdue' THEN

    -- Ao: Remove o cliente de todas as futuras mensagens agendadas
    DELETE FROM public.pending_sends
    WHERE client_id = NEW.id;

  END IF;

  RETURN NEW;
END;
$function$
SET search_path = public;

-- Funo: public.update_updated_at_column
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS trigger
LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
SET search_path = public;

-- Funo: public.process_notification_queue
-- Nota: Esta funo j tinha SECURITY DEFINER SET search_path = '', que ser substitudo por SET search_path = public.
CREATE OR REPLACE FUNCTION public.process_notification_queue()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
DECLARE
    notification_record RECORD;
    edge_function_url TEXT;
    supabase_project_id TEXT := 'cgqyfpsfymhntumrmbzj'; -- Substitua pelo seu Project ID do Supabase
    edge_function_name TEXT := 'send-scheduled-notification';
BEGIN
    -- Constri a URL da Edge Function
    edge_function_url := 'https://' || supabase_project_id || '.supabase.co/functions/v1/' || edge_function_name;

    -- Seleciona notificaes pendentes que esto vencidas ou para vencer agora
    FOR notification_record IN
        SELECT id, user_id, client_id, template_id, send_at
        FROM public.scheduled_notifications
        WHERE status = 'pending' AND send_at <= NOW()
        FOR UPDATE SKIP LOCKED -- Bloqueia as linhas selecionadas e pula se j estiverem bloqueadas
    LOOP
        -- Atualiza o status para 'processing' para evitar reprocessamento
        UPDATE public.scheduled_notifications
        SET status = 'processing'
        WHERE id = notification_record.id;

        -- Invoca a Edge Function assincronamente usando pg_net
        PERFORM extensions.http_post( -- Usar extensions.http_post
            url := edge_function_url,
            headers := ARRAY[
                extensions.http_header('Content-Type', 'application/json') -- Usar extensions.http_header
            ],
            body := jsonb_build_object('id', notification_record.id)
        );

        RAISE NOTICE 'Notificao agendada % para o usurio % enviada para a Edge Function para processamento.', notification_record.id, notification_record.user_id;
    END LOOP;
END;
$function$
SET search_path = public;


-- 2. Isolar a Extenso 'http' no schema 'extensions'

-- Criar um schema dedicado para extenses, se ainda no existir.
CREATE SCHEMA IF NOT EXISTS extensions;

-- Mover a extenso 'http' do schema 'public' para o schema 'extensions'.
ALTER EXTENSION http SET SCHEMA extensions;
--- Contedo de: supabase/migrations/20240803000000_add_logging_to_process_notification_queue.sql ---
-- Adicionando logs  funo public.process_notification_queue para diagnstico

CREATE OR REPLACE FUNCTION public.process_notification_queue()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
DECLARE
    notification_record RECORD;
    edge_function_url TEXT;
    supabase_project_id TEXT := 'cgqyfpsfymhntumrmbzj'; -- Substitua pelo seu Project ID do Supabase
    edge_function_name TEXT := 'send-scheduled-notification';
    pending_count INTEGER;
BEGIN
    RAISE NOTICE 'process_notification_queue: Funo iniciada pelo cron job.';

    -- Constri a URL da Edge Function
    edge_function_url := 'https://' || supabase_project_id || '.supabase.co/functions/v1/' || edge_function_name;

    -- Seleciona notificaes pendentes que esto vencidas ou para vencer agora
    SELECT COUNT(*)
    INTO pending_count
    FROM public.scheduled_notifications
    WHERE status = 'pending' AND send_at <= NOW();

    RAISE NOTICE 'process_notification_queue: Encontrados % agendamentos pendentes para processar.', pending_count;

    FOR notification_record IN
        SELECT id, user_id, client_id, template_id, send_at, automation_id
        FROM public.scheduled_notifications
        WHERE status = 'pending' AND send_at <= NOW()
        FOR UPDATE SKIP LOCKED -- Bloqueia as linhas selecionadas e pula se j estiverem bloqueadas
    LOOP
        RAISE NOTICE 'process_notification_queue: Processando notificao agendada ID: %, Cliente ID: %, Enviar em: %', notification_record.id, notification_record.client_id, notification_record.send_at;

        -- Atualiza o status para 'processing' para evitar reprocessamento
        UPDATE public.scheduled_notifications
        SET status = 'processing'
        WHERE id = notification_record.id;

        -- Invoca a Edge Function assincronamente usando pg_net
        PERFORM extensions.http_post(
            url := edge_function_url,
            headers := ARRAY[
                extensions.http_header('Content-Type', 'application/json')
            ],
            body := jsonb_build_object('id', notification_record.id)
        );

        RAISE NOTICE 'process_notification_queue: Notificao agendada % para o usurio % delegada para a Edge Function de envio.', notification_record.id, notification_record.user_id;
    END LOOP;

    RAISE NOTICE 'process_notification_queue: Concludo o processamento da fila.';
END;
$function$
SET search_path = public;
--- Contedo de: supabase/migrations/20240804000000_final_cron_cleanup.sql ---
-- Desativar e remover todos os cron jobs conhecidos para evitar execues indesejadas
SELECT cron.unschedule('process-notification-queue-job');
SELECT cron.unschedule('process-automated-notifications-job');

-- Remover as funes de agendamento antigas que foram substitudas pelas Edge Functions.
-- Usamos CASCADE para garantir que quaisquer objetos dependentes (como triggers) tambm sejam removidos.
DROP FUNCTION IF EXISTS public.process_notification_queue CASCADE;
DROP FUNCTION IF EXISTS public.process_automated_notifications CASCADE;

-- Remover todas as funes relacionadas  extenso 'http' (pg_net) que podem estar causando o erro.
-- A ordem  importante para evitar erros de dependncia.
DROP FUNCTION IF EXISTS public.http_post(character varying, jsonb) CASCADE;
DROP FUNCTION IF EXISTS public.http_post(character varying, character varying, character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http_set_curlopt(character varying, character varying) CASCADE;
DROP FUNCTION IF EXISTS public.bytea_to_text(bytea) CASCADE;
DROP FUNCTION IF EXISTS public.http_header(character varying, character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http_delete(character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http_delete(character varying, character varying, character varying) CASCADE;
DROP FUNCTION IF EXISTS public.urlencode(bytea) CASCADE;
DROP FUNCTION IF EXISTS public.urlencode(character varying) CASCADE;
DROP FUNCTION IF EXISTS public.urlencode(jsonb) CASCADE;
DROP FUNCTION IF EXISTS public.http_head(character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http_list_curlopt() CASCADE;
DROP FUNCTION IF EXISTS public.text_to_bytea(text) CASCADE;
DROP FUNCTION IF EXISTS public.http_reset_curlopt() CASCADE;
DROP FUNCTION IF EXISTS public.http_get(character varying, jsonb) CASCADE;
DROP FUNCTION IF EXISTS public.http_get(character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http(http_request) CASCADE; -- Esta pode falhar se o tipo http_request j no existir, mas  importante tentar.
DROP FUNCTION IF EXISTS public.http_put(character varying, character varying, character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http_patch(character varying, character varying, character varying) CASCADE;

-- Finalmente, remover a prpria extenso 'http' e seus tipos, se ainda existirem.
DROP EXTENSION IF EXISTS http CASCADE;
DROP TYPE IF EXISTS public.http_request CASCADE;
DROP TYPE IF EXISTS public.http_response CASCADE;
DROP TYPE IF EXISTS public.http_header CASCADE;
--- Contedo de: supabase/migrations/20251007003528_102cc75e-094b-4867-af88-81f4a22932be.sql ---
-- Create enum for user roles
CREATE TYPE public.app_role AS ENUM ('admin', 'user');

-- Create enum for client status
CREATE TYPE public.client_status AS ENUM ('active', 'inactive', 'overdue');

-- Create enum for template category
CREATE TYPE public.template_category AS ENUM ('pre_due', 'due_today', 'overdue', 'celebratory');

-- Create profiles table
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Create user_roles table
CREATE TABLE public.user_roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  role app_role NOT NULL DEFAULT 'user',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(user_id, role)
);

-- Create plans table
CREATE TABLE public.plans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  value DECIMAL(10, 2) NOT NULL,
  period_days INTEGER NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Create clients table
CREATE TABLE public.clients (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  phone TEXT NOT NULL,
  email TEXT,
  notes TEXT,
  plan_id UUID REFERENCES public.plans(id) ON DELETE SET NULL,
  due_date DATE NOT NULL,
  next_billing_date DATE NOT NULL,
  status client_status NOT NULL DEFAULT 'active',
  value DECIMAL(10, 2) NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Create templates table
CREATE TABLE public.templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  category template_category NOT NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Create logs table
CREATE TABLE public.logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  action TEXT NOT NULL,
  details JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Enable Row Level Security
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.clients ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.logs ENABLE ROW LEVEL SECURITY;

-- Create security definer function to check roles
CREATE OR REPLACE FUNCTION public.has_role(_user_id UUID, _role app_role)
RETURNS BOOLEAN
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.user_roles
    WHERE user_id = _user_id
    AND role = _role
  )
$$;

-- RLS Policies for profiles
CREATE POLICY "Users can view their own profile"
  ON public.profiles FOR SELECT
  USING (auth.uid() = id);

CREATE POLICY "Users can update their own profile"
  ON public.profiles FOR UPDATE
  USING (auth.uid() = id);

CREATE POLICY "Admins can view all profiles"
  ON public.profiles FOR SELECT
  USING (public.has_role(auth.uid(), 'admin'));

-- RLS Policies for user_roles
CREATE POLICY "Users can view their own roles"
  ON public.user_roles FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Admins can manage all roles"
  ON public.user_roles FOR ALL
  USING (public.has_role(auth.uid(), 'admin'));

-- RLS Policies for plans
CREATE POLICY "Users can view their own plans"
  ON public.plans FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own plans"
  ON public.plans FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own plans"
  ON public.plans FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own plans"
  ON public.plans FOR DELETE
  USING (auth.uid() = user_id);

CREATE POLICY "Admins can view all plans"
  ON public.plans FOR SELECT
  USING (public.has_role(auth.uid(), 'admin'));

-- RLS Policies for clients
CREATE POLICY "Users can view their own clients"
  ON public.clients FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own clients"
  ON public.clients FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own clients"
  ON public.clients FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own clients"
  ON public.clients FOR DELETE
  USING (auth.uid() = user_id);

CREATE POLICY "Admins can view all clients"
  ON public.clients FOR SELECT
  USING (public.has_role(auth.uid(), 'admin'));

-- RLS Policies for templates
CREATE POLICY "Users can view their own templates"
  ON public.templates FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own templates"
  ON public.templates FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own templates"
  ON public.templates FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own templates"
  ON public.templates FOR DELETE
  USING (auth.uid() = user_id);

CREATE POLICY "Admins can view all templates"
  ON public.templates FOR SELECT
  USING (public.has_role(auth.uid(), 'admin'));

-- RLS Policies for logs
CREATE POLICY "Users can view their own logs"
  ON public.logs FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own logs"
  ON public.logs FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Admins can view all logs"
  ON public.logs FOR SELECT
  USING (public.has_role(auth.uid(), 'admin'));

-- Function to handle new user creation
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, name, email)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'name', split_part(NEW.email, '@', 1)),
    NEW.email
  );
  
  -- Assign default user role
  INSERT INTO public.user_roles (user_id, role)
  VALUES (NEW.id, 'user');
  
  RETURN NEW;
END;
$$;

-- Trigger to create profile on user signup
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

-- Triggers for updated_at
CREATE TRIGGER update_profiles_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_plans_updated_at
  BEFORE UPDATE ON public.plans
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_clients_updated_at
  BEFORE UPDATE ON public.clients
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_templates_updated_at
  BEFORE UPDATE ON public.templates
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
--- Contedo de: supabase/migrations/20251008221742_04f85bc8-acba-4ba7-b6d0-7d68f700c615.sql ---
-- Create templates table
CREATE TABLE public.templates (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  category TEXT NOT NULL CHECK (category IN ('pre_due', 'due_today', 'overdue', 'celebratory')),
  content TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Enable Row Level Security
ALTER TABLE public.templates ENABLE ROW LEVEL SECURITY;

-- Create policies for user access
CREATE POLICY "Users can view their own templates" 
ON public.templates 
FOR SELECT 
USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own templates" 
ON public.templates 
FOR INSERT 
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own templates" 
ON public.templates 
FOR UPDATE 
USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own templates" 
ON public.templates 
FOR DELETE 
USING (auth.uid() = user_id);

-- Create function to update timestamps
CREATE OR REPLACE FUNCTION public.update_templates_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SET search_path = public;

-- Create trigger for automatic timestamp updates
CREATE TRIGGER update_templates_updated_at
BEFORE UPDATE ON public.templates
FOR EACH ROW
EXECUTE FUNCTION public.update_templates_updated_at();
--- Contedo de: supabase/migrations/20251013211718_7199223e-79f3-455d-a284-7d422ac46b51.sql ---
-- Criar tabela de configuraes de webhooks
CREATE TABLE public.webhook_configs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  type TEXT NOT NULL,
  url TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(user_id, type)
);

-- Habilitar RLS
ALTER TABLE public.webhook_configs ENABLE ROW LEVEL SECURITY;

-- Polticas RLS para webhook_configs
CREATE POLICY "Users can view their own webhook configs"
  ON public.webhook_configs FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own webhook configs"
  ON public.webhook_configs FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own webhook configs"
  ON public.webhook_configs FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own webhook configs"
  ON public.webhook_configs FOR DELETE
  USING (auth.uid() = user_id);

-- Criar tabela de histrico de webhooks
CREATE TABLE public.webhook_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  webhook_type TEXT NOT NULL,
  payload JSONB NOT NULL,
  status_code INTEGER,
  timestamp TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Habilitar RLS
ALTER TABLE public.webhook_history ENABLE ROW LEVEL SECURITY;

-- Polticas RLS para webhook_history
CREATE POLICY "Users can view their own webhook history"
  ON public.webhook_history FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own webhook history"
  ON public.webhook_history FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Trigger para atualizar updated_at em webhook_configs
CREATE TRIGGER update_webhook_configs_updated_at
  BEFORE UPDATE ON public.webhook_configs
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

-- Criar tabela de status de conexo
CREATE TABLE public.connection_status (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  instance_name TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'disconnected',
  qr_code_base64 TEXT,
  last_updated TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(user_id, instance_name)
);

-- Habilitar RLS
ALTER TABLE public.connection_status ENABLE ROW LEVEL SECURITY;

-- Polticas RLS para connection_status
CREATE POLICY "Users can view their own connection status"
  ON public.connection_status FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own connection status"
  ON public.connection_status FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own connection status"
  ON public.connection_status FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own connection status"
  ON public.connection_status FOR DELETE
  USING (auth.uid() = user_id);

-- Habilitar Realtime para connection_status
ALTER PUBLICATION supabase_realtime ADD TABLE public.connection_status;
--- Contedo de: supabase/migrations/20251013221600_fix_client_status_timezone.sql ---
-- Fix client status timezone issue in set_client_status_based_on_due_date function

CREATE OR REPLACE FUNCTION public.set_client_status_based_on_due_date()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    local_current_date DATE;
BEGIN
  -- Get the current date in the 'America/Sao_Paulo' timezone
  -- This ensures consistency with the application's expected "today"
  local_current_date := (NOW() AT TIME ZONE 'America/Sao_Paulo')::DATE;

  -- Verifica se o status atual no  'inativo'. No queremos reativar um cliente cancelado automaticamente.
  IF NEW.status != 'inactive' THEN
    -- Se a data de vencimento for anterior a hoje (na timezone local), define o status como 'overdue'.
    IF NEW.next_billing_date < local_current_date THEN
      NEW.status := 'overdue';
    -- Caso contrrio, define o status como 'ativo'.
    ELSE
      NEW.status := 'active';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$function$;
--- Contedo de: supabase/migrations/20251016013741_aaf8b971-c037-421b-affa-f8e6241f5cd4.sql ---
-- Habilitar extenses necessrias para cron jobs
CREATE EXTENSION IF NOT EXISTS pg_cron;
CREATE EXTENSION IF NOT EXISTS pg_net;

-- Configurar cron job para processar fila de notificaes a cada minuto
SELECT cron.schedule(
  'process-notification-queue',
  '* * * * *', -- Executa a cada minuto
  $$
  SELECT net.http_post(
    url := 'https://cgqyfpsfymhntumrmbzj.supabase.co/functions/v1/process-queue-and-send',
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || current_setting('app.settings.cron_secret')
    ),
    body := jsonb_build_object('trigger', 'cron', 'time', now())
  ) as request_id;
  $$
);
--- Contedo de: supabase/migrations/20251016013854_c4128d56-0d29-430f-bf1b-44046107633e.sql ---
-- Habilitar extenses necessrias para cron jobs
CREATE EXTENSION IF NOT EXISTS pg_cron;
CREATE EXTENSION IF NOT EXISTS pg_net;

-- Configurar cron job para processar fila de notificaes a cada minuto
SELECT cron.schedule(
  'process-notification-queue',
  '* * * * *', -- Executa a cada minuto
  $$
  SELECT net.http_post(
    url := 'https://cgqyfpsfymhntumrmbzj.supabase.co/functions/v1/process-queue-and-send',
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || current_setting('app.settings.cron_secret')
    ),
    body := jsonb_build_object('trigger', 'cron', 'time', now())
  ) as request_id;
  $$
);
--- Contedo de: supabase/migrations/20251016020954_ea957f25-cd1a-4bb0-9173-0437ada06f90.sql ---
-- Remove o cron job PostgreSQL que est causando os erros
-- Este job estava tentando usar current_setting('app.settings.cron_secret') que no existe
SELECT cron.unschedule(1);
--- Contedo de: supabase/migrations/20251016022304_57e7bf3f-2807-4368-ad7d-e46877539e06.sql ---
-- Ensure pg_cron schedules our Edge Function every minute using Vault secret
-- Safely remove any existing job with the same name
DO $$
BEGIN
  PERFORM cron.unschedule('process-queue-and-send-every-minute');
EXCEPTION WHEN OTHERS THEN
  -- ignore if it doesn't exist
  NULL;
END;
$$;

-- Schedule the process-queue-and-send function to run every minute
SELECT
  cron.schedule(
    'process-queue-and-send-every-minute',
    '* * * * *',
    $$
    SELECT
      net.http_post(
        url := 'https://cgqyfpsfymhntumrmbzj.supabase.co/functions/v1/process-queue-and-send',
        headers := jsonb_build_object(
          'Content-Type','application/json',
          'Authorization','Bearer ' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = 'CRON_SECRET')
        ),
        body := jsonb_build_object('trigger','supabase-cron')
      ) AS request_id;
    $$
  );
======================================
  EXTRA: CONTEDO DAS EDGE FUNCTIONS, PGINAS E HOOKS
======================================

--- Contedo de: supabase/functions/admin-financial-analysis/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Interfaces para tipagem dos dados do Supabase
interface AdminFinancialEntry {
  value: number;
  created_at: string;
}

interface SubscriptionData {
  user_id: string;
  price: number;
  next_billing_date: string;
  created_at: string;
  status: string;
  subscriber_plans: { name: string; id: string; value: number }[] | { name: string; id: string; value: number } | null;
}

interface ProfileData {
  id: string;
  created_at: string;
}

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const now = new Date();
    const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
    const monthEnd = new Date(now.getFullYear(), now.getMonth() + 1, 1);

    // --- Valores Recebidos (admin_financial_entries) ---
    const { data: adminFinancialEntries, error: financialError } = await supabaseAdmin
      .from('admin_financial_entries')
      .select('value, created_at')
      .eq('type', 'credit');

    if (financialError) throw financialError;
    console.log('Edge Function: adminFinancialEntries fetched, count:', adminFinancialEntries?.length || 0);

    let receivedThisMonth = 0; // Para currentMonthRevenue
    let receivedPreviousMonth = 0; // Para previousMonthRevenue

    const previousMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
    const previousMonthEnd = new Date(now.getFullYear(), now.getMonth(), 1);

    (adminFinancialEntries as AdminFinancialEntry[] || []).forEach((entry: AdminFinancialEntry) => {
      const entryDate = new Date(entry.created_at);
      if (entryDate >= monthStart && entryDate < monthEnd) {
        receivedThisMonth += entry.value;
      } else if (entryDate >= previousMonthStart && entryDate < previousMonthEnd) {
        receivedPreviousMonth += entry.value;
      }
    });

    // --- Dados de Assinaturas (subscriptions) e Perfis (profiles) ---
    const { data: subscriptions, error: subscriptionsError } = await supabaseAdmin
      .from('subscriptions')
      .select('user_id, price, next_billing_date, created_at, status'); // Removed subscriber_plans join for now

    if (subscriptionsError) throw subscriptionsError;
    console.log('Edge Function: subscriptions fetched, count:', subscriptions?.length || 0);

    const { data: profiles, error: profilesError } = await supabaseAdmin
      .from('profiles')
      .select('id, created_at');

    if (profilesError) throw profilesError;
    console.log('Edge Function: profiles fetched, count:', profiles?.length || 0);

    let newSubscribersThisMonth = 0;
    let activeSubscribers = 0;
    let revenueForecast = 0; // Baseado em assinaturas ativas para o ms atual

    const subscriberCreationMonthStart = new Date(now.getFullYear(), now.getMonth(), 1);
    const subscriberCreationMonthEnd = new Date(now.getFullYear(), now.getMonth() + 1, 1);

    const activeSubscriberIds = new Set<string>();

    (subscriptions as SubscriptionData[] || []).forEach((sub: SubscriptionData) => {
      const subCreationDate = new Date(sub.created_at);
      if (subCreationDate >= subscriberCreationMonthStart && subCreationDate < subscriberCreationMonthEnd) {
        // Check if the user associated with this subscription is actually new this month
        const profileCreatedThisMonth = (profiles as ProfileData[] || []).some(p => 
          p.id === sub.user_id && new Date(p.created_at) >= subscriberCreationMonthStart && new Date(p.created_at) < subscriberCreationMonthEnd
        );
        if (profileCreatedThisMonth) {
          newSubscribersThisMonth++;
        }
      }
      if (sub.status === 'active') {
        activeSubscriberIds.add(sub.user_id); // Count unique active subscribers
        if (sub.next_billing_date) {
          const dueDate = new Date(sub.next_billing_date + 'T00:00:00'); // Tratar como data local
          if (dueDate >= monthStart && dueDate < monthEnd) {
            revenueForecast += sub.price;
          }
        }
      }
    });
    activeSubscribers = activeSubscriberIds.size;

    // --- KPIs Calculation ---
    const currentMonthRevenue = receivedThisMonth;
    const previousMonthRevenue = receivedPreviousMonth;

    const monthlyGrowthPercentage = previousMonthRevenue > 0
      ? ((currentMonthRevenue / previousMonthRevenue) - 1) * 100
      : (currentMonthRevenue > 0 ? 100 : 0);

    const kpis = {
      currentMonthRevenue,
      previousMonthRevenue,
      monthlyGrowthPercentage,
      newSubscribersThisMonth: newSubscribersThisMonth, // Renomeado
      activeSubscribers: activeSubscribers, // Renomeado
      revenueForecast: currentMonthRevenue + revenueForecast, // Total de receita do ms + previso de recebveis
    };

    // --- Churn Analysis Calculation ---
    const { data: churnedSubscriptionsData, error: churnedSubscriptionsError } = await supabaseAdmin
      .from('subscriptions')
      .select(`
        user_id,
        price,
        subscriber_plans ( name )
      `)
      .in('status', ['inactive', 'overdue'])
      .gte('next_billing_date', monthStart.toISOString().split('T')[0])
      .lte('next_billing_date', new Date(monthEnd.getTime() - 1).toISOString().split('T')[0]);

    if (churnedSubscriptionsError) throw churnedSubscriptionsError;

    let lostSubscribersThisMonth = 0;
    let lostRevenueThisMonth = 0;
    const churnByPlanMap = new Map<string, { planName: string; lostCount: number }>();

    (churnedSubscriptionsData || []).forEach((sub: any) => {
      const planData = Array.isArray(sub.subscriber_plans) ? sub.subscriber_plans[0] : sub.subscriber_plans;
      const planName = planData?.name || 'Plano Desconhecido';
      const subPrice = sub.price || 0;

      if (!churnByPlanMap.has(planName)) {
        churnByPlanMap.set(planName, { planName, lostCount: 0 });
      }
      churnByPlanMap.get(planName)!.lostCount++;

      lostSubscribersThisMonth++;
      lostRevenueThisMonth += subPrice;
    });

    const churnByPlan = Array.from(churnByPlanMap.values()).sort((a, b) => b.lostCount - a.lostCount);

    const totalSubscribersForChurn = activeSubscribers + lostSubscribersThisMonth;
    const churnRate = totalSubscribersForChurn > 0
      ? (lostSubscribersThisMonth / totalSubscribersForChurn) * 100
      : 0;

    const churnAnalysis = {
      lostSubscribersThisMonth,
      lostRevenueThisMonth,
      churnRate,
      churnByPlan,
    };

    // --- Revenue Last 30 Days (from admin_financial_entries) ---
    const revenueLast30DaysMap = new Map<string, number>();
    const thirtyDaysAgo = new Date(now);
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 29);
    
    for (let d = new Date(thirtyDaysAgo); d <= now; d.setDate(d.getDate() + 1)) {
      const dateStr = d.toISOString().split('T')[0];
      revenueLast30DaysMap.set(dateStr, 0);
    }

    (adminFinancialEntries as AdminFinancialEntry[] || []).forEach((entry: AdminFinancialEntry) => {
      const entryDate = new Date(entry.created_at);
      const entryDateStr = entryDate.toISOString().split('T')[0];
      if (revenueLast30DaysMap.has(entryDateStr)) {
        revenueLast30DaysMap.set(entryDateStr, revenueLast30DaysMap.get(entryDateStr)! + entry.value);
      }
    });

    // --- Weekly Revenue Comparison (from admin_financial_entries) ---
    const weeklyRevenueComparison: { [key: string]: { currentMonth: number; previousMonth: number } } = {};

    const getWeekNumber = (date: Date) => {
      const startOfYear = new Date(date.getFullYear(), 0, 1);
      const diff = date.getTime() - startOfYear.getTime();
      return Math.ceil(diff / (1000 * 60 * 60 * 24 * 7));
    };

    const processWeeklyRevenue = (entries: AdminFinancialEntry[] | null, monthStart: Date, monthEnd: Date, targetObject: any, monthKey: 'currentMonth' | 'previousMonth') => {
      const monthEntries = (entries || []).filter((entry: AdminFinancialEntry) => {
        const entryDate = new Date(entry.created_at);
        return entryDate >= monthStart && entryDate < monthEnd;
      });

      monthEntries.forEach((entry: AdminFinancialEntry) => {
        const entryDate = new Date(entry.created_at);
        const weekNum = getWeekNumber(entryDate);
        const weekKey = `week${weekNum}`;

        if (!targetObject[weekKey]) {
          targetObject[weekKey] = { currentMonth: 0, previousMonth: 0 };
        }
        targetObject[weekKey][monthKey] += entry.value;
      });
    };

    processWeeklyRevenue(adminFinancialEntries, monthStart, monthEnd, weeklyRevenueComparison, 'currentMonth');
    processWeeklyRevenue(adminFinancialEntries, previousMonthStart, previousMonthEnd, weeklyRevenueComparison, 'previousMonth');

    const allWeekKeys = new Set<string>();
    Object.keys(weeklyRevenueComparison).forEach(key => allWeekKeys.add(key));
    for (const key of allWeekKeys) {
      if (!weeklyRevenueComparison[key].currentMonth) weeklyRevenueComparison[key].currentMonth = 0;
      if (!weeklyRevenueComparison[key].previousMonth) weeklyRevenueComparison[key].previousMonth = 0;
    }

    // --- Revenue by Subscriber Plan (Current Month) ---
    const revenueByPlanData: { planName: string; totalRevenue: number }[] = [];
    const tempRevenueByPlan = new Map<string, number>();

    // Fetch subscriber plans to get names
    const { data: subscriberPlans, error: subscriberPlansError } = await supabaseAdmin
      .from('subscriber_plans')
      .select('id, name');
    if (subscriberPlansError) throw subscriberPlansError;
    const subscriberPlansMap = new Map(subscriberPlans?.map(p => [p.id, p.name]));

    (subscriptions as SubscriptionData[] || []).forEach((sub: SubscriptionData) => {
      if (sub.status === 'active' && sub.next_billing_date) {
        const dueDate = new Date(sub.next_billing_date + 'T00:00:00'); // Tratar como data local
        if (dueDate >= monthStart && dueDate < monthEnd) {
          // Find the plan name from subscriber_plans based on subscription's plan_name (string)
          // This assumes subscription.plan_name directly matches subscriber_plans.name
          const planName = sub.plan_name || 'Plano Desconhecido'; // Assuming subscription has a plan_name field
          tempRevenueByPlan.set(planName, (tempRevenueByPlan.get(planName) || 0) + sub.price);
        }
      }
    });

    tempRevenueByPlan.forEach((totalRevenue, planName) => {
      revenueByPlanData.push({ planName, totalRevenue });
    });

    // --- Monthly Revenue History (Last 12 Months from admin_financial_entries) ---
    const twelveMonthsAgo = new Date(now);
    twelveMonthsAgo.setMonth(twelveMonthsAgo.getMonth() - 11);
    const twelveMonthsAgoStart = new Date(twelveMonthsAgo.getFullYear(), twelveMonthsAgo.getMonth(), 1);
    const currentMonthEnd = new Date(now.getFullYear(), now.getMonth() + 1, 1);

    const { data: monthlyEntriesHistory, error: monthlyEntriesHistoryError } = await supabaseAdmin
      .from('admin_financial_entries')
      .select('value, created_at')
      .eq('type', 'credit')
      .gte('created_at', twelveMonthsAgoStart.toISOString())
      .lte('created_at', currentMonthEnd.toISOString());

    if (monthlyEntriesHistoryError) throw monthlyEntriesHistoryError;
    console.log('Edge Function: monthlyEntriesHistory fetched, count:', monthlyEntriesHistory?.length || 0);

    const monthlyRevenueHistoryMap = new Map<string, number>();
    (monthlyEntriesHistory as AdminFinancialEntry[] || []).forEach((entry: AdminFinancialEntry) => {
      const entryDate = new Date(entry.created_at);
      const monthKey = `${entryDate.getFullYear()}-${String(entryDate.getMonth() + 1).padStart(2, '0')}`;
      monthlyRevenueHistoryMap.set(monthKey, (monthlyRevenueHistoryMap.get(monthKey) || 0) + entry.value);
    });

    const monthlyRevenueHistory: { month: string; revenue: number }[] = [];
    const months = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
    let currentMonthIterator = new Date(twelveMonthsAgoStart);
    while (currentMonthIterator < currentMonthEnd) {
      const monthKey = `${currentMonthIterator.getFullYear()}-${String(currentMonthIterator.getMonth() + 1).padStart(2, '0')}`;
      const monthLabel = `${months[currentMonthIterator.getMonth()]}/${String(currentMonthIterator.getFullYear()).slice(2)}`;
      monthlyRevenueHistory.push({
        month: monthLabel,
        revenue: monthlyRevenueHistoryMap.get(monthKey) || 0,
      });
      currentMonthIterator.setMonth(currentMonthIterator.getMonth() + 1);
    }

    console.log('Edge Function: Admin financial analysis data prepared successfully.');

    return new Response(
      JSON.stringify({
        kpis,
        revenueLast30Days: Array.from(revenueLast30DaysMap.entries()).map(([date, revenue]) => ({ date, revenue })),
        weeklyRevenueComparison,
        revenueByPlan: revenueByPlanData,
        churnAnalysis,
        monthlyRevenueHistory,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error: any) {
    console.error('Edge Function: Error fetching admin financial analysis:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred in the admin financial analysis function.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/admin-financial-entries/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const { method } = req;
    const url = new URL(req.url);
    const id = url.searchParams.get('id'); // For GET (single), PUT, DELETE

    switch (method) {
      case 'GET': {
        if (id) {
          const { data, error } = await supabaseAdmin
            .from('admin_financial_entries')
            .select('*')
            .eq('id', id)
            .single();
          if (error) throw error;
          return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        } else {
          const { data, error } = await supabaseAdmin
            .from('admin_financial_entries')
            .select('*')
            .order('created_at', { ascending: false });
          if (error) throw error;
          return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
      }
      case 'POST': {
        const body = await req.json();
        const { description, value, type, subscriber_id } = body;
        if (!description || !value || !type || !subscriber_id) {
          return new Response(JSON.stringify({ error: 'Missing required fields: description, value, type, subscriber_id' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        const { data, error } = await supabaseAdmin
          .from('admin_financial_entries')
          .insert({ admin_user_id: user.id, description, value, type, subscriber_id })
          .select()
          .single();
        if (error) throw error;
        return new Response(JSON.stringify(data), { status: 201, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      case 'PUT': {
        if (!id) {
          return new Response(JSON.stringify({ error: 'Missing ID for update' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        const body = await req.json();
        const { description, value, type, subscriber_id } = body;
        const updateData: any = {};
        if (description !== undefined) updateData.description = description;
        if (value !== undefined) updateData.value = value;
        if (type !== undefined) updateData.type = type;
        if (subscriber_id !== undefined) updateData.subscriber_id = subscriber_id;

        const { data, error } = await supabaseAdmin
          .from('admin_financial_entries')
          .update(updateData)
          .eq('id', id)
          .select()
          .single();
        if (error) throw error;
        return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      case 'DELETE': {
        if (!id) {
          return new Response(JSON.stringify({ error: 'Missing ID for delete' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        const { error } = await supabaseAdmin
          .from('admin_financial_entries')
          .delete()
          .eq('id', id);
        if (error) throw error;
        return new Response(JSON.stringify({ message: 'Entry deleted successfully.' }), { status: 204, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      default:
        return new Response('Method Not Allowed', { status: 405, headers: corsHeaders });
    }
  } catch (error: any) {
    console.error('Edge Function: Error in admin-financial-entries:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/admin-financial-summary/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

// @ts-ignore
import { DateTime } from 'https://esm.sh/luxon@3.4.4'; // Use Luxon

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Interfaces para tipagem dos dados do Supabase
interface AdminFinancialEntry {
  value: number;
  created_at: string;
}

interface SubscriptionSummary {
  price: number;
  next_billing_date: string;
  status: string;
}

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const now = DateTime.local(); // Current local time
    const todayStart = now.startOf('day');
    const todayEnd = now.plus({ days: 1 }).startOf('day'); // Exclusive end: start of tomorrow

    // Luxon's startOf('week') defaults to Monday. To match date-fns weekStartsOn: 0 (Sunday),
    // we need to set locale or explicitly adjust. 'en-US' starts on Sunday.
    const weekStart = now.setLocale('en-US').startOf('week');
    const weekEnd = weekStart.plus({ weeks: 1 }).startOf('day'); // Exclusive end: start of next week

    const monthStart = now.startOf('month');
    const monthEnd = monthStart.plus({ months: 1 }).startOf('day'); // Exclusive end: start of next month

    // --- Valores Recebidos (admin_financial_entries) ---
    const { data: adminFinancialEntries, error: financialError } = await supabaseAdmin
      .from('admin_financial_entries')
      .select('value, created_at')
      .eq('type', 'credit');

    if (financialError) throw financialError;
    console.log('Edge Function: adminFinancialEntries fetched, count:', adminFinancialEntries?.length || 0);

    let receivedToday = 0;
    let receivedThisWeek = 0;
    let receivedThisMonth = 0;

    (adminFinancialEntries as AdminFinancialEntry[] || []).forEach((entry: AdminFinancialEntry) => {
      const entryDateTime = DateTime.fromISO(entry.created_at, { zone: 'utc' }).toLocal(); // Convert to local for comparison
      if (entryDateTime >= todayStart && entryDateTime < todayEnd) {
        receivedToday += entry.value;
      }
      if (entryDateTime >= weekStart && entryDateTime < weekEnd) {
        receivedThisWeek += entry.value;
      }
      if (entryDateTime >= monthStart && entryDateTime < monthEnd) {
        receivedThisMonth += entry.value;
      }
    });

    // --- Previso de Recebveis (subscriptions) ---
    const { data: subscriptions, error: subscriptionsError } = await supabaseAdmin
      .from('subscriptions')
      .select('price, next_billing_date, status')
      .eq('status', 'active'); // Apenas assinaturas ativas geram recebveis

    if (subscriptionsError) throw subscriptionsError;
    console.log('Edge Function: subscriptions fetched, count:', subscriptions?.length || 0);

    let receivableToday = 0;
    let receivableTomorrow = 0;
    let receivableThisWeek = 0;
    let receivableThisMonth = 0;

    const tomorrowStart = now.plus({ days: 1 }).startOf('day');
    const tomorrowEnd = now.plus({ days: 2 }).startOf('day'); // Exclusive end: start of day after tomorrow

    (subscriptions as SubscriptionSummary[] || []).forEach((sub: SubscriptionSummary) => {
      if (!sub.next_billing_date) return;
      const dueDate = DateTime.fromISO(sub.next_billing_date, { zone: 'local' }).startOf('day'); // Treat as local date, start of day

      if (dueDate >= todayStart && dueDate < todayEnd) {
        receivableToday += sub.price;
      }
      if (dueDate >= tomorrowStart && dueDate < tomorrowEnd) {
        receivableTomorrow += sub.price;
      }
      if (dueDate >= weekStart && dueDate < weekEnd) {
        receivableThisWeek += sub.price;
      }
      if (dueDate >= monthStart && dueDate < monthEnd) {
        receivableThisMonth += sub.price;
      }
    });

    // --- Valores Perdidos (Churn de Assinantes) ---
    // For direct Supabase queries, we need YYYY-MM-DD strings.
    // Use Luxon's toISODate() for this.
    const { data: churnedSubscriptionsToday, error: churnedTodayError } = await supabaseAdmin
      .from('subscriptions')
      .select('price')
      .in('status', ['inactive', 'overdue'])
      .gte('next_billing_date', todayStart.toISODate())
      .lt('next_billing_date', todayEnd.toISODate()); // Use lt for exclusive end
    if (churnedTodayError) throw churnedTodayError;
    const lostValueToday = (churnedSubscriptionsToday as { price: number }[] || []).reduce((sum: number, sub: { price: number }) => sum + sub.price, 0);
    console.log('Edge Function: lostValueToday calculated:', lostValueToday);

    const { data: churnedSubscriptionsThisWeek, error: churnedThisWeekError } = await supabaseAdmin
      .from('subscriptions')
      .select('price')
      .in('status', ['inactive', 'overdue'])
      .gte('next_billing_date', weekStart.toISODate())
      .lt('next_billing_date', weekEnd.toISODate()); // Use lt for exclusive end
    if (churnedThisWeekError) throw churnedThisWeekError;
    const lostValueThisWeek = (churnedSubscriptionsThisWeek as { price: number }[] || []).reduce((sum: number, sub: { price: number }) => sum + sub.price, 0);
    console.log('Edge Function: lostValueThisWeek calculated:', lostValueThisWeek);

    const { data: churnedSubscriptionsThisMonth, error: churnedThisMonthError } = await supabaseAdmin
      .from('subscriptions')
      .select('price')
      .in('status', ['inactive', 'overdue'])
      .gte('next_billing_date', monthStart.toISODate())
      .lt('next_billing_date', monthEnd.toISODate()); // Use lt for exclusive end
    if (churnedThisMonthError) throw churnedThisMonthError;
    const lostValueThisMonth = (churnedSubscriptionsThisMonth as { price: number }[] || []).reduce((sum: number, sub: { price: number }) => sum + sub.price, 0);
    console.log('Edge Function: lostValueThisMonth calculated:', lostValueThisMonth);


    console.log('Edge Function: Admin financial summary data prepared successfully.');

    return new Response(
      JSON.stringify({
        receivedToday,
        receivedThisWeek,
        receivedThisMonth,
        receivableToday,
        receivableTomorrow,
        receivableThisWeek,
        receivableThisMonth,
        lostValueToday,
        lostValueThisWeek,
        lostValueThisMonth,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error: any) {
    console.error('Edge Function: Error fetching admin financial summary:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred in the financial summary function.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/apply-schema-migration/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';
// @ts-ignore
import { Client } from "https://deno.land/x/postgres@v0.17.0/mod.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    console.log('apply-schema-migration: Starting schema migration...');

    // Connect directly to PostgreSQL to execute DDL
    const client = new Client({
      // @ts-ignore
      hostname: Deno.env.get('SUPABASE_DB_HOST') ?? '',
      // @ts-ignore
      port: parseInt(Deno.env.get('SUPABASE_DB_PORT') ?? '5432'),
      // @ts-ignore
      user: 'postgres',
      // @ts-ignore
      password: Deno.env.get('SUPABASE_DB_PASSWORD') ?? '',
      database: 'postgres',
    });

    await client.connect();

    // Add column if it doesn't exist
    await client.queryArray(`
      DO $$ 
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM information_schema.columns 
          WHERE table_name = 'webhook_history' 
          AND column_name = 'client_name_snapshot'
        ) THEN
          ALTER TABLE webhook_history ADD COLUMN client_name_snapshot TEXT;
          CREATE INDEX idx_webhook_history_client_name_snapshot ON webhook_history(client_name_snapshot);
          COMMENT ON COLUMN webhook_history.client_name_snapshot IS 'Snapshot of the client name at the time of the webhook call. Used to preserve history even if client is deleted.';
        END IF;
      END $$;
    `);

    await client.end();

    console.log('apply-schema-migration: Schema migration completed');

    // Now populate existing records using Supabase client
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    // This function is called by useDashboardStats, which is user-authenticated.
    // We need to get the user from the request to filter the population.
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      // If no auth header, this is likely a direct invocation without user context.
      // For migration, we might want to process all, but for data population, it should be user-specific.
      // For now, we'll skip population if no user context.
      console.warn('apply-schema-migration: No Authorization header found. Skipping data population for specific user.');
      return new Response(
        JSON.stringify({
          success: true,
          message: 'Schema migration completed. Data population skipped due to missing user context.',
          recordsUpdated: 0
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 200,
        }
      );
    }

    const token = authHeader.replace('Bearer ', '');
    const supabaseUserClient = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabaseUserClient.auth.getUser();
    if (userError || !user) {
      console.error('apply-schema-migration: User authentication failed for data population:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated for data population' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    const userId = user.id;

    // Fetch user role
    const { data: userRoleData, error: userRoleError } = await supabaseUserClient
      .from('user_roles')
      .select('role')
      .eq('user_id', userId)
      .single();

    if (userRoleError && userRoleError.code !== 'PGRST116') {
      console.error('apply-schema-migration: Error fetching user role for data population:', userRoleError.message);
      throw userRoleError;
    }
    const userRole = userRoleData?.role || 'user';

    let historyRecordsQuery = supabaseAdmin
      .from('webhook_history')
      .select('id, client_id, clients(name)')
      .is('client_name_snapshot', null)
      .not('client_id', 'is', null);

    // Apply user_id filter for non-admin users during data population
    if (userRole !== 'admin') {
      historyRecordsQuery = historyRecordsQuery.eq('user_id', userId);
    }

    const { data: historyRecords } = await historyRecordsQuery;

    let updatedCount = 0;
    if (historyRecords && historyRecords.length > 0) {
      for (const record of historyRecords) {
        const client = Array.isArray(record.clients) ? record.clients[0] : record.clients;
        if (client?.name) {
          await supabaseAdmin
            .from('webhook_history')
            .update({ client_name_snapshot: client.name })
            .eq('id', record.id);
          updatedCount++;
        }
      }
    }

    return new Response(
      JSON.stringify({
        success: true,
        message: 'Schema migration and data population completed',
        recordsUpdated: updatedCount
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );

  } catch (error: any) {
    console.error('apply-schema-migration: Error:', error.message);
    return new Response(
      JSON.stringify({ error: error.message }),
      {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      }
    );
  }
});
--- Contedo de: supabase/functions/connection-metrics/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

// @ts-ignore
import * as dateFns from 'npm:date-fns@3.6.0'; // Use npm: for date-fns
// @ts-ignore
import { toZonedTime } from 'npm:date-fns-tz@3.2.0'; // Updated to v3 - renamed from utcToZonedTime

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Define interfaces for detailed history items
interface DetailedHistoryItem {
  id: string;
  clientName: string;
  templateName: string;
  eventDate: string; // This will be send_at or sent_at
  status: 'pending' | 'success' | 'failed';
  errorMessage?: string | null;
  requestPayload?: any | null; // Adicionado
  responsePayload?: any | null; // Adicionado
}

// Interfaces for raw data from Supabase queries
interface ScheduledNotificationRow {
  id: string;
  send_at: string;
  status: 'pending';
  clients: { name: string } | null;
  templates: { name: string } | null;
}

interface N8nMessageSenderHistoryRow { // Renomeado para refletir a nova tabela
  id: string;
  timestamp: string; 
  status_code: number | null; 
  webhook_type: string; 
  clients: { name: string } | null;
  templates: { name: string } | null;
  error_message?: string | null; 
  request_payload?: any | null; 
  response_payload?: any | null; 
  client_name_snapshot?: string | null; // Added for deleted clients
}

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    const userId = user.id;
    const url = new URL(req.url);
    const statusFilter = url.searchParams.get('status'); // Get the status query parameter

    // Fetch user role
    const { data: userRoleData, error: userRoleError } = await supabase
      .from('user_roles')
      .select('role')
      .eq('user_id', userId)
      .single();

    if (userRoleError && userRoleError.code !== 'PGRST116') { // PGRST116 = No rows found
      console.error('Edge Function: Error fetching user role:', userRoleError.message);
      throw userRoleError;
    }
    const userRole = userRoleData?.role || 'user'; // Default to 'user' if no role found

    // Conditionally apply user_id filter
    const applyUserIdFilter = (query: any) => {
      return userRole === 'admin' ? query : query.eq('user_id', userId);
    };

    // --- Detailed List Logic ---
    if (statusFilter === 'pending' || statusFilter === 'success' || statusFilter === 'failed') {
      let detailedData: DetailedHistoryItem[] = [];
      let query;

      if (statusFilter === 'pending') {
        query = applyUserIdFilter(
          supabase
            .from('scheduled_notifications')
            .select(`
              id,
              send_at,
              status,
              clients(name),
              templates(name)
            `)
        )
          .eq('status', 'pending')
          .order('send_at', { ascending: false });
      } else { // 'success' or 'failed'
        query = applyUserIdFilter(
          supabase
            .from('n8n_message_sender_history') // Alterado para n8n_message_sender_history
            .select(`
              id,
              timestamp,
              status_code,
              webhook_type,
              request_payload,
              response_payload,
              client_name_snapshot,
              clients:clients(name),
              templates:templates(name)
            `)
        )
          .in('webhook_type', ['n8n_message_outbound', 'n8n_message_outbound_automated']) // Filtrar por tipos de webhook de mensagem
          .order('timestamp', { ascending: false });
          
          if (statusFilter === 'success') {
            query = query.eq('status_code', 200);
          } else if (statusFilter === 'failed') {
            query = query.or('status_code.neq.200,status_code.is.null'); // MODIFICADO: Incluir status_code nulo como falha
          }
      }

      const { data, error: detailedError } = await query;

      if (detailedError) throw detailedError;

      detailedData = (data || []).map((item: any) => { // Usar 'any' temporariamente para flexibilidade
        if (statusFilter === 'pending') {
          const scheduledItem = item as ScheduledNotificationRow;
          return {
            id: scheduledItem.id,
            clientName: scheduledItem.clients?.name || 'Cliente Desconhecido',
            templateName: scheduledItem.templates?.name || 'Template Desconhecido',
            eventDate: scheduledItem.send_at,
            status: scheduledItem.status,
          };
        } else {
          const historyItem = item as N8nMessageSenderHistoryRow; // Usar o novo tipo
          // Use snapshot if client is deleted, otherwise use current client name
          const clientName = historyItem.clients?.name 
            ? historyItem.clients.name 
            : historyItem.client_name_snapshot 
              ? `${historyItem.client_name_snapshot} (Deletado)` 
              : 'Cliente Desconhecido';
          
          return {
            id: historyItem.id,
            clientName,
            templateName: historyItem.templates?.name || 'Template Desconhecido',
            eventDate: historyItem.timestamp, // Usar timestamp do webhook_history
            status: historyItem.status_code && historyItem.status_code >= 200 && historyItem.status_code < 300 ? 'success' : 'failed', // Mapear status_code para 'success'/'failed'
            requestPayload: historyItem.request_payload,
            responsePayload: historyItem.response_payload,
          };
        }
      });

      return new Response(JSON.stringify({ detailedData }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      });
    }

    // --- Existing Metrics and Recent History Logic (if no statusFilter) ---
    // Agendados: Contagem de scheduled_notifications com status 'pending'
    const { count: scheduledCount, error: scheduledError } = await applyUserIdFilter(
      supabase
        .from('scheduled_notifications')
        .select('*', { count: 'exact', head: true })
    )
      .eq('status', 'pending');

    if (scheduledError) throw scheduledError;

    // Enviados: Contagem de n8n_message_sender_history com status_code 200
    const { count: sentCount, error: sentError } = await applyUserIdFilter(
      supabase
        .from('n8n_message_sender_history') // Alterado para n8n_message_sender_history
        .select('*', { count: 'exact', head: true })
    )
      .in('webhook_type', ['n8n_message_outbound', 'n8n_message_outbound_automated']) // Incluir ambos os tipos
      .eq('status_code', 200);

    if (sentError) throw sentError;

    // Falhas: Contagem de n8n_message_sender_history com status_code diferente de 200 OU status_code  NULL
    const { count: failedCount, error: failedError } = await applyUserIdFilter(
      supabase
        .from('n8n_message_sender_history') // Alterado para n8n_message_sender_history
        .select('*', { count: 'exact', head: true })
    )
      .in('webhook_type', ['n8n_message_outbound', 'n8n_message_outbound_automated']) // Incluir ambos os tipos
      .or('status_code.neq.200,status_code.is.null'); // MODIFICADO: Incluir status_code nulo como falha

    if (failedError) throw failedError;

    // Histrico de Envios (recentes, para o dashboard principal)
    const { data: historyData, error: historyError } = await applyUserIdFilter(
      supabase
        .from('n8n_message_sender_history') // Alterado para n8n_message_sender_history
        .select(`
          id,
          timestamp,
          status_code,
          client_name_snapshot,
          clients:clients(name),
          templates:templates(name)
        `)
    )
      .in('webhook_type', ['n8n_message_outbound', 'n8n_message_outbound_automated']) // Incluir ambos os tipos
      .order('timestamp', { ascending: false })
      .limit(10);

    if (historyError) throw historyError;

    const formattedHistory = (historyData || []).map((item: any) => {
      // Use snapshot if client is deleted, otherwise use current client name
      const clientName = item.clients?.name 
        ? item.clients.name 
        : item.client_name_snapshot 
          ? `${item.client_name_snapshot} (Deletado)` 
          : 'Cliente Desconhecido';
      
      return {
        id: item.id,
        clientName,
        templateName: item.templates?.name || 'Template Desconhecido',
        sentDate: new Date(item.timestamp).toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit' }),
        status: item.status_code && item.status_code >= 200 && item.status_code < 300 ? 'success' : 'failed',
      };
    });

    const responsePayload = {
      metrics: {
        sent: sentCount || 0,
        scheduled: scheduledCount || 0,
        failed: failedCount || 0,
      },
      history: formattedHistory,
    };

    return new Response(JSON.stringify(responsePayload), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (error: any) {
    console.error('Edge Function: An unexpected error occurred:', error.message);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/crud-active-gateway/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { method } = req;

    // Para operaes GET, qualquer usurio autenticado pode ler o gateway ativo.
    // A verificao de funo de admin  necessria apenas para POST/PUT.
    if (method !== 'GET') {
      const { data: userRoleData, error: userRoleError } = await supabaseAdmin
        .from('user_roles')
        .select('role')
        .eq('user_id', user.id)
        .single();

      if (userRoleError || userRoleData?.role !== 'admin') {
        console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
        return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
          status: 403,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        });
      }
      console.log('Edge Function: Admin user confirmed for write operation.');
    }


    switch (method) {
      case 'GET': {
        const { data, error } = await supabaseAdmin
          .from('active_payment_gateway')
          .select('*')
          .eq('id', 1)
          .maybeSingle(); // Use maybeSingle to handle no rows found

        if (error) throw error;
        return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      case 'POST':
      case 'PUT': { // Both POST and PUT will perform an upsert
        const body = await req.json();
        const { gateway_name } = body;

        if (!gateway_name) {
          return new Response(JSON.stringify({ error: 'Missing required field: gateway_name' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }

        const { data, error } = await supabaseAdmin
          .from('active_payment_gateway')
          .upsert({ id: 1, gateway_name }, { onConflict: 'id' })
          .select()
          .single();

        if (error) throw error;
        return new Response(JSON.stringify(data), { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      default:
        return new Response('Method Not Allowed', { status: 405, headers: corsHeaders });
    }
  } catch (error: any) {
    console.error('Edge Function: Error in crud-active-gateway:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/crud-mercado-pago-configs/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    const { method } = req;

    switch (method) {
      case 'GET': {
        const { data, error } = await supabaseAdmin
          .from('mercado_pago_configs')
          .select('*')
          .eq('id', 1)
          .maybeSingle(); // Use maybeSingle to handle no rows found

        if (error) throw error;
        return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      case 'POST':
      case 'PUT': {
        const body = await req.json();
        const { mercado_pago_public_key, mercado_pago_access_token, mercado_pago_client_id, mercado_pago_client_secret } = body;

        if (!mercado_pago_public_key || !mercado_pago_access_token || !mercado_pago_client_id || !mercado_pago_client_secret) {
          return new Response(JSON.stringify({ error: 'Missing required fields: public_key, access_token, client_id, client_secret' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }

        const { data, error } = await supabaseAdmin
          .from('mercado_pago_configs')
          .upsert({ id: 1, mercado_pago_public_key, mercado_pago_access_token, mercado_pago_client_id, mercado_pago_client_secret }, { onConflict: 'id' })
          .select()
          .single();

        if (error) throw error;
        return new Response(JSON.stringify(data), { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      default:
        return new Response('Method Not Allowed', { status: 405, headers: corsHeaders });
    }
  } catch (error: any) {
    console.error('Edge Function: Error in crud-mercado-pago-configs:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/crud-pagbank-configs/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    const { method } = req;

    switch (method) {
      case 'GET': {
        const { data, error } = await supabaseAdmin
          .from('pagbank_configs')
          .select('*, environment') // NOVO: Incluir 'environment' na seleo
          .eq('id', 1)
          .maybeSingle(); // Use maybeSingle to handle no rows found

        if (error) throw error;
        return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      case 'POST':
      case 'PUT': {
        const body = await req.json();
        const { pagbank_email, pagbank_token, pagbank_pix_key, environment } = body; // NOVO: Obter 'environment'

        if (!pagbank_email || !pagbank_token || !pagbank_pix_key || !environment) { // NOVO: Validar 'environment'
          return new Response(JSON.stringify({ error: 'Missing required fields: pagbank_email, pagbank_token, pagbank_pix_key, environment' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }

        // NOVO: Validao estrita para o campo 'environment'
        if (environment !== 'sandbox' && environment !== 'production') {
          return new Response(JSON.stringify({ error: 'Invalid environment value. Must be "sandbox" or "production".' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }

        const { data, error } = await supabaseAdmin
          .from('pagbank_configs')
          .upsert({ id: 1, pagbank_email, pagbank_token, pagbank_pix_key, environment }, { onConflict: 'id' }) // NOVO: Incluir 'environment' no upsert
          .select()
          .single();

        if (error) throw error;
        return new Response(JSON.stringify(data), { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      default:
        return new Response('Method Not Allowed', { status: 405, headers: corsHeaders });
    }
  } catch (error: any) {
    console.error('Edge Function: Error in crud-pagbank-configs:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/crud-subscriber-automations/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const { method } = req;
    const url = new URL(req.url);
    const id = url.searchParams.get('id'); // For GET (single), PUT, DELETE

    switch (method) {
      case 'GET': {
        if (id) {
          const { data, error } = await supabaseAdmin
            .from('subscriber_automations')
            .select('*, subscriber_templates(name)')
            .eq('id', id)
            .single();
          if (error) throw error;
          return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        } else {
          const { data, error } = await supabaseAdmin
            .from('subscriber_automations')
            .select('*, subscriber_templates(name)')
            .order('created_at', { ascending: true });
          if (error) throw error;
          return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
      }
      case 'POST': {
        const body = await req.json();
        const { days_offset, subscriber_template_id, subscriber_ids, scheduled_time } = body;
        if (days_offset === undefined || !subscriber_template_id || !subscriber_ids || !scheduled_time) {
          return new Response(JSON.stringify({ error: 'Missing required fields: days_offset, subscriber_template_id, subscriber_ids, scheduled_time' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        const { data, error } = await supabaseAdmin
          .from('subscriber_automations')
          .insert({ admin_user_id: user.id, days_offset, subscriber_template_id, subscriber_ids, scheduled_time })
          .select()
          .single();
        if (error) throw error;
        return new Response(JSON.stringify(data), { status: 201, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      case 'PUT': {
        if (!id) {
          return new Response(JSON.stringify({ error: 'Missing ID for update' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        const body = await req.json();
        const { days_offset, subscriber_template_id, subscriber_ids, scheduled_time } = body;
        const updateData: any = {};
        if (days_offset !== undefined) updateData.days_offset = days_offset;
        if (subscriber_template_id !== undefined) updateData.subscriber_template_id = subscriber_template_id;
        if (subscriber_ids !== undefined) updateData.subscriber_ids = subscriber_ids;
        if (scheduled_time !== undefined) updateData.scheduled_time = scheduled_time;

        const { data, error } = await supabaseAdmin
          .from('subscriber_automations')
          .update(updateData)
          .eq('id', id)
          .select()
          .single();
        if (error) throw error;
        return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      case 'DELETE': {
        if (!id) {
          return new Response(JSON.stringify({ error: 'Missing ID for delete' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        const { error } = await supabaseAdmin
          .from('subscriber_automations')
          .delete()
          .eq('id', id);
        if (error) throw error;
        return new Response(JSON.stringify({ message: 'Subscriber automation deleted successfully.' }), { status: 204, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      default:
        return new Response('Method Not Allowed', { status: 405, headers: corsHeaders });
    }
  } catch (error: any) {
    console.error('Edge Function: Error in crud-subscriber-automations:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/crud-subscriber-plans/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS', // Adicionado PUT, DELETE e OPTIONS
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders, status: 200 }); // Retorna 200 OK para preflight
  }

  try {
    console.log('crud-subscriber-plans: Function started.');
    console.log(`crud-subscriber-plans: Request Method: ${req.method}`);
    console.log(`crud-subscriber-plans: Request URL: ${req.url}`);

    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      console.error('crud-subscriber-plans: Unauthorized - Missing Authorization header.');
      return new Response('Unauthorized', { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const { method } = req;
    const url = new URL(req.url);
    const id = url.searchParams.get('id');

    switch (method) {
      case 'GET': {
        if (id) {
          console.log(`crud-subscriber-plans: GET (single) request for ID: ${id}`);
          const { data, error } = await supabaseAdmin
            .from('subscriber_plans')
            .select('*')
            .eq('id', id)
            .single();
          if (error) {
            console.error(`crud-subscriber-plans: GET (single) error for ID ${id}:`, error.message);
            throw error;
          }
          console.log(`crud-subscriber-plans: GET (single) successful for ID ${id}.`);
          return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        } else {
          console.log('crud-subscriber-plans: GET (all) request.');
          const { data, error } = await supabaseAdmin
            .from('subscriber_plans')
            .select('*')
            .order('name', { ascending: true });
          if (error) {
            console.error('crud-subscriber-plans: GET (all) error:', error.message);
            throw error;
          }
          console.log(`crud-subscriber-plans: GET (all) successful, found ${data?.length || 0} plans.`);
          return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
      }
      case 'POST': {
        const body = await req.json();
        console.log('crud-subscriber-plans: POST request body:', JSON.stringify(body));
        const { name, value, period_days } = body;
        if (!name || !value || !period_days) {
          console.error('crud-subscriber-plans: POST error - Missing required fields.');
          return new Response(JSON.stringify({ error: 'Missing required fields: name, value, period_days' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        const { data, error } = await supabaseAdmin
          .from('subscriber_plans')
          .insert({ name, value, period_days })
          .select()
          .single();
        if (error) {
          console.error('crud-subscriber-plans: POST error:', error.message);
          throw error;
        }
        console.log('crud-subscriber-plans: POST successful, data:', JSON.stringify(data));
        return new Response(JSON.stringify(data), { status: 201, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      case 'PUT': {
        if (!id) {
          console.error('crud-subscriber-plans: PUT error - Missing ID for update.');
          return new Response(JSON.stringify({ error: 'Missing ID for update' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        const body = await req.json();
        console.log(`crud-subscriber-plans: PUT request for ID ${id}, body:`, JSON.stringify(body));
        const { name, value, period_days } = body;
        const updateData: any = {};
        if (name !== undefined) updateData.name = name;
        if (value !== undefined) updateData.value = value;
        if (period_days !== undefined) updateData.period_days = period_days;

        console.log(`crud-subscriber-plans: Attempting to update subscriber_plans for ID ${id} with data:`, JSON.stringify(updateData));
        const { data, error } = await supabaseAdmin
          .from('subscriber_plans')
          .update(updateData)
          .eq('id', id)
          .select()
          .single();
        if (error) {
          console.error(`crud-subscriber-plans: PUT error for ID ${id}:`, error.message);
          throw error;
        }
        console.log(`crud-subscriber-plans: PUT successful for ID ${id}, data:`, JSON.stringify(data));
        return new Response(JSON.stringify(data), { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      case 'DELETE': {
        if (!id) {
          console.error('crud-subscriber-plans: DELETE error - Missing ID for delete.');
          return new Response(JSON.stringify({ error: 'Missing ID for delete' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        console.log(`crud-subscriber-plans: DELETE request for ID ${id}`);
        const { error } = await supabaseAdmin
          .from('subscriber_plans')
          .delete()
          .eq('id', id);
        if (error) {
          console.error(`crud-subscriber-plans: DELETE error for ID ${id}:`, error.message);
          throw error;
        }
        console.log(`crud-subscriber-plans: DELETE successful for ID ${id}`);
        return new Response(JSON.stringify({ message: 'Subscriber plan deleted successfully.' }), { status: 204, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      default:
        console.warn(`crud-subscriber-plans: Method Not Allowed: ${method}`);
        return new Response('Method Not Allowed', { status: 405, headers: corsHeaders });
    }
  } catch (error: any) {
    console.error('crud-subscriber-plans: Unhandled error in Edge Function:', error.message, error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/crud-subscriber-templates/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    console.log('crud-subscriber-templates: Function started.');
    console.log(`crud-subscriber-templates: Request Method: ${req.method}`);
    console.log(`crud-subscriber-templates: Request URL: ${req.url}`);

    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      console.error('crud-subscriber-templates: Unauthorized - Missing Authorization header.');
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const { method } = req;
    const url = new URL(req.url);
    const id = url.searchParams.get('id');

    switch (method) {
      case 'GET': {
        if (id) {
          const { data, error } = await supabaseAdmin
            .from('subscriber_templates')
            .select('*')
            .eq('id', id)
            .single();
          if (error) {
            console.error(`crud-subscriber-templates: GET (single) error for ID ${id}:`, error.message);
            throw error;
          }
          return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        } else {
          const { data, error } = await supabaseAdmin
            .from('subscriber_templates')
            .select('*')
            .order('name', { ascending: true });
          if (error) {
            console.error('crud-subscriber-templates: GET (all) error:', error.message);
            throw error;
          }
          return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
      }
      case 'POST': {
        const body = await req.json();
        console.log('crud-subscriber-templates: POST request body:', JSON.stringify(body));
        const { name, content, type } = body;
        if (!name || !content) {
          return new Response(JSON.stringify({ error: 'Missing required fields: name, content' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        const { data, error } = await supabaseAdmin
          .from('subscriber_templates')
          .insert({ admin_user_id: user.id, name, content, type: type || 'normal' })
          .select()
          .single();
        if (error) {
          console.error('crud-subscriber-templates: POST error:', error.message);
          throw error;
        }
        console.log('crud-subscriber-templates: POST successful, data:', JSON.stringify(data));
        return new Response(JSON.stringify(data), { status: 201, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      case 'PUT': {
        if (!id) {
          return new Response(JSON.stringify({ error: 'Missing ID for update' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        const body = await req.json();
        console.log(`crud-subscriber-templates: PUT request for ID ${id}, body:`, JSON.stringify(body));
        const { name, content, type, admin_user_id } = body; // Capturar admin_user_id do body
        const updateData: any = {};
        if (name !== undefined) updateData.name = name;
        if (content !== undefined) updateData.content = content;
        if (type !== undefined) updateData.type = type;
        if (admin_user_id !== undefined) updateData.admin_user_id = admin_user_id; // Incluir admin_user_id na atualizao

        const { data, error } = await supabaseAdmin
          .from('subscriber_templates')
          .update(updateData)
          .eq('id', id)
          .select()
          .single();
        if (error) {
          console.error(`crud-subscriber-templates: PUT error for ID ${id}:`, error.message);
          throw error;
        }
        console.log(`crud-subscriber-templates: PUT successful for ID ${id}, data:`, JSON.stringify(data));
        return new Response(JSON.stringify(data), { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }); // Alterado para 200 OK
      }
      case 'DELETE': {
        if (!id) {
          return new Response(JSON.stringify({ error: 'Missing ID for delete' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        console.log(`crud-subscriber-templates: DELETE request for ID ${id}`);
        const { error } = await supabaseAdmin
          .from('subscriber_templates')
          .delete()
          .eq('id', id);
        if (error) {
          console.error(`crud-subscriber-templates: DELETE error for ID ${id}:`, error.message);
          throw error;
        }
        console.log(`crud-subscriber-templates: DELETE successful for ID ${id}`);
        return new Response(JSON.stringify({ message: 'Subscriber template deleted successfully.' }), { status: 204, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      default:
        return new Response('Method Not Allowed', { status: 405, headers: corsHeaders });
    }
  } catch (error: any) {
    console.error('crud-subscriber-templates: Unhandled error in Edge Function:', error.message, error); // Log do erro completo
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/delete-user/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: adminRoleData, error: adminRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (adminRoleError || adminRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const { targetUserId } = await req.json();

    if (!targetUserId) {
      return new Response(JSON.stringify({ error: 'Missing targetUserId.' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    // Prevent admin from deleting themselves
    if (targetUserId === user.id) {
      return new Response(JSON.stringify({ error: 'Admins cannot delete their own account.' }), { status: 403, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    // Delete the user from auth.users. Due to CASCADE DELETE, this will also delete
    // associated profiles, user_roles, subscriptions, and user_instances.
    const { error: deleteUserError } = await supabaseAdmin.auth.admin.deleteUser(targetUserId);

    if (deleteUserError) {
      console.error('Edge Function: Error deleting user:', deleteUserError.message);
      throw deleteUserError;
    }

    return new Response(JSON.stringify({ success: true, message: 'User and associated data deleted successfully.' }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (error: any) {
    console.error('Edge Function: Error in delete-user:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/evolution-webhook-receiver/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseAdmin = createClient(
    // @ts-ignore
    Deno.env.get('SUPABASE_URL') ?? '',
    // @ts-ignore
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  let payload: any;
  let instanceName: string | null = null;
  let userId: string | null = null;
  let eventType: string | null = null;
  let historyEntryId: string | null = null; // Para armazenar o ID da entrada inicial do histrico

  try {
    payload = await req.json();
    console.log('Evolution Webhook received:', JSON.stringify(payload, null, 2));

    instanceName = payload.instance;
    eventType = payload.event;

    // Se o nome da instncia no for encontrado, loga e retorna erro 400
    if (!instanceName) {
      console.error('Evolution Webhook: Instance name not found in payload.');
      // Tenta logar o erro mesmo sem userId, se possvel
      await supabaseAdmin.from('evolution_api_history').insert({
        user_id: null, // userId ainda no disponvel
        webhook_type: eventType || 'evolution_inbound_unknown',
        payload: payload,
        request_payload: payload,
        response_payload: { error: 'Instance name not found in payload.' },
        status_code: 400,
      });
      return new Response(
        JSON.stringify({ error: 'Instance name not found in payload.' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Buscar o user_id associado a esta instncia
    // Service role bypasses RLS, so no explicit user_id filter needed here.
    const { data: instanceData, error: instanceError } = await supabaseAdmin
      .from('user_instances')
      .select('user_id')
      .eq('instance_name', instanceName)
      .single();

    if (instanceError || !instanceData) {
      console.error('Evolution Webhook: Instance not found or error fetching user_id:', instanceError?.message);
      // Tenta logar o erro mesmo sem userId, se possvel
      await supabaseAdmin.from('evolution_api_history').insert({
        user_id: null, // userId ainda no disponvel
        webhook_type: eventType || 'evolution_inbound_unknown',
        payload: payload,
        request_payload: payload,
        response_payload: { error: 'Instance not found or associated user_id could not be retrieved.' },
        status_code: 404,
      });
      return new Response(
        JSON.stringify({ error: 'Instance not found or associated user_id could not be retrieved.' }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    userId = instanceData.user_id;

    // Log inicial da requisio recebida
    const { data: initialHistoryEntry, error: initialLogError } = await supabaseAdmin
      .from('evolution_api_history')
      .insert({
        user_id: userId,
        webhook_type: eventType || 'evolution_inbound_unknown',
        payload: payload, // Armazena o payload completo
        request_payload: payload,
        status_code: 200, // Assume sucesso no recebimento da requisio
        response_payload: { message: 'Processing...' }, // Placeholder
      })
      .select('id')
      .single();

    if (initialLogError) {
      console.error('Evolution Webhook: Error logging initial history entry:', initialLogError.message);
    } else {
      historyEntryId = initialHistoryEntry?.id;
    }

    let finalStatus = 200;
    let finalMessage = `Evolution webhook processed. Event: ${eventType}, Instance: ${instanceName}.`;

    // Lgica Condicional para Atualizao de Status
    if (eventType === 'connection.update' && payload.data?.state === 'open') {
      console.log(`Evolution Webhook: Connection update event with state 'open' detected for instance ${instanceName}.`);

      // Service role bypasses RLS, but we still filter by user_id to ensure data integrity.
      const { error: updateError } = await supabaseAdmin
        .from('user_instances')
        .update({ status: 'connected', qr_code_base64: null })
        .eq('instance_name', instanceName)
        .eq('user_id', userId); // Filter by user_id

      if (updateError) {
        console.error('Evolution Webhook: Error updating user_instances to connected:', updateError);
        finalStatus = 500; // Erro interno do servidor para falha na atualizao do DB
        finalMessage += ` (Internal update error: ${updateError.message})`;
      } else {
        console.log(`Evolution Webhook: user_instances for ${instanceName} updated to 'connected'.`);
      }

      // Service role bypasses RLS, but we still filter by user_id to ensure data integrity.
      const { error: statusError } = await supabaseAdmin
        .from('connection_status')
        .upsert({
          user_id: userId,
          instance_name: instanceName,
          status: 'connected',
          qr_code_base64: null,
          last_updated: new Date().toISOString(),
        }, {
          onConflict: 'user_id,instance_name'
        });

      if (statusError) {
        console.error('Evolution Webhook: Error updating connection_status to connected:', statusError);
        finalStatus = 500; // Erro interno do servidor para falha na atualizao do DB
        finalMessage += ` (Internal connection_status update error: ${statusError.message})`;
      } else {
        console.log(`Evolution Webhook: connection_status for ${instanceName} updated to 'connected'.`);
      }
    } else if (eventType === 'connection.update' && payload.data?.state === 'close') { // NOVO: Lgica para 'close'
      console.log(`Evolution Webhook: Connection update event with state 'close' detected for instance ${instanceName}.`);

      // Service role bypasses RLS, but we still filter by user_id to ensure data integrity.
      const { error: updateError } = await supabaseAdmin
        .from('user_instances')
        .update({ status: 'disconnected', qr_code_base64: null })
        .eq('instance_name', instanceName)
        .eq('user_id', userId); // Filter by user_id

      if (updateError) {
        console.error('Evolution Webhook: Error updating user_instances to disconnected:', updateError);
        finalStatus = 500;
        finalMessage += ` (Internal update error: ${updateError.message})`;
      } else {
        console.log(`Evolution Webhook: user_instances for ${instanceName} updated to 'disconnected'.`);
      }

      // Service role bypasses RLS, but we still filter by user_id to ensure data integrity.
      const { error: statusError } = await supabaseAdmin
        .from('connection_status')
        .upsert({
          user_id: userId,
          instance_name: instanceName,
          status: 'disconnected',
          qr_code_base64: null,
          last_updated: new Date().toISOString(),
        }, {
          onConflict: 'user_id,instance_name'
        });

      if (statusError) {
        console.error('Evolution Webhook: Error updating connection_status to disconnected:', statusError);
        finalStatus = 500;
        finalMessage += ` (Internal connection_status update error: ${statusError.message})`;
      } else {
        console.log(`Evolution Webhook: connection_status for ${instanceName} updated to 'disconnected'.`);
      }
    } else {
      finalMessage += ` No status change applied.`;
    }

    // Atualiza a entrada do histrico com o status e mensagem finais
    if (historyEntryId) {
      await supabaseAdmin
        .from('evolution_api_history')
        .update({ status_code: finalStatus, response_payload: { message: finalMessage } })
        .eq('id', historyEntryId);
    }

    return new Response(
      JSON.stringify({ success: finalStatus === 200, message: finalMessage }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: finalStatus }
    );

  } catch (error: any) {
    console.error('Evolution Webhook: Unhandled error:', error.message);
    const errorStatus = 500;
    const errorMessage = error.message || 'Unknown error in Evolution Webhook.';

    // Se uma entrada inicial do histrico foi criada, atualiza. Caso contrrio, cria uma nova.
    if (historyEntryId && userId) {
      await supabaseAdmin
        .from('evolution_api_history')
        .update({ status_code: errorStatus, response_payload: { error: errorMessage } })
        .eq('id', historyEntryId);
    } else if (userId && payload && eventType) {
      await supabaseAdmin
        .from('evolution_api_history')
        .insert({
          user_id: userId,
          webhook_type: eventType || 'evolution_inbound_unknown',
          payload: payload,
          request_payload: payload,
          response_payload: { error: errorMessage },
          status_code: errorStatus,
        });
    } else {
      console.error('Evolution Webhook: Could not log error to evolution_api_history, missing userId, payload or eventType.');
    }

    return new Response(
      JSON.stringify({ error: errorMessage }),
      { status: errorStatus, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
--- Contedo de: supabase/functions/financial-analysis/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

// @ts-ignore
import { DateTime } from 'https://esm.sh/luxon@3.4.4'; // Use Luxon

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Interfaces para tipagem dos dados do Supabase
interface FinancialEntry {
  value: number;
  created_at: string;
}

// Removed: interface ClientWithPlan {
// Removed:   value: number;
// Removed:   next_billing_date: string;
// Removed:   created_at: string;
// Removed:   status: string;
// Removed:   plans: { name: string; id: string; value: number }[] | { name: string; id: string; value: number } | null;
// Removed: }

// Removed: interface LostClient {
// Removed:   id: string;
// Removed:   value: number | null;
// Removed:   plans: { name: string }[] | { name: string } | null;
// Removed: }

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    const userId = user.id;

    // Fetch user role
    const { data: userRoleData, error: userRoleError } = await supabase
      .from('user_roles')
      .select('role')
      .eq('user_id', userId)
      .single();

    if (userRoleError && userRoleError.code !== 'PGRST116') { // PGRST116 = No rows found
      console.error('Edge Function: Error fetching user role:', userRoleError.message);
      throw userRoleError;
    }
    const userRole = userRoleData?.role || 'user'; // Default to 'user' if no role found

    // Conditionally apply user_id filter
    const applyUserIdFilter = (query: any) => {
      return userRole === 'admin' ? query : query.eq('user_id', userId);
    };
    
    const now = DateTime.local(); // Current local time

    const monthStart = now.startOf('month');
    const monthEnd = monthStart.plus({ months: 1 }).startOf('day'); // Exclusive end: start of next month

    const previousMonthStart = now.minus({ months: 1 }).startOf('month');
    const previousMonthEnd = previousMonthStart.plus({ months: 1 }).startOf('day'); // Exclusive end: start of current month

    // --- Valores Recebidos (financial_entries) ---
    const { data: financialEntries, error: financialError } = await applyUserIdFilter(
      supabase
        .from('financial_entries')
        .select('value, created_at')
    )
      .eq('type', 'credit');

    if (financialError) throw financialError;
    console.log('Edge Function: financialEntries fetched, count:', financialEntries?.length || 0);

    let receivedThisMonth = 0; // Para currentMonthRevenue
    let receivedPreviousMonth = 0; // Para previousMonthRevenue

    (financialEntries as FinancialEntry[] || []).forEach((entry: FinancialEntry) => {
      const entryDateTime = DateTime.fromISO(entry.created_at, { zone: 'utc' }).toLocal(); // Convert to local for comparison
      if (entryDateTime >= monthStart && entryDateTime < monthEnd) {
        receivedThisMonth += entry.value;
      } else if (entryDateTime >= previousMonthStart && entryDateTime < previousMonthEnd) {
        receivedPreviousMonth += entry.value;
      }
    });

    // --- Previso de Recebveis (clients) ---
    const { data: clients, error: clientsError } = await applyUserIdFilter(
      supabase
        .from('clients')
        .select('value, next_billing_date, created_at, status, plans(name, id, value)')
    );

    if (clientsError) throw clientsError;
    console.log('Edge Function: clients fetched, count:', clients?.length || 0);

    let newClientsThisMonth = 0;
    let activeClients = 0;
    let receivableThisMonth = 0; // Para revenueForecast

    const clientCreationMonthStart = now.startOf('month');
    const clientCreationMonthEnd = clientCreationMonthStart.plus({ months: 1 }).startOf('day'); // Exclusive end

    (clients || []).forEach((client: any) => {
      // Removed: const planData = Array.isArray(client.plans) ? client.plans[0] : client.plans;
      const clientCreationDateTime = DateTime.fromISO(client.created_at, { zone: 'utc' }).toLocal(); // Convert to local for comparison
      if (clientCreationDateTime >= clientCreationMonthStart && clientCreationDateTime < clientCreationMonthEnd) {
        newClientsThisMonth++;
      }
      if (client.status === 'active') {
        activeClients++;
        if (client.next_billing_date) {
          const dueDate = DateTime.fromISO(client.next_billing_date, { zone: 'local' }).startOf('day'); // Treat as local date, start of day
          if (dueDate >= monthStart && dueDate < monthEnd) {
            receivableThisMonth += client.value;
          }
        }
      }
    });

    // --- KPIs Calculation ---
    const currentMonthRevenue = receivedThisMonth;
    const previousMonthRevenue = receivedPreviousMonth;

    const monthlyGrowthPercentage = previousMonthRevenue > 0
      ? ((currentMonthRevenue / previousMonthRevenue) - 1) * 100
      : (currentMonthRevenue > 0 ? 100 : 0);

    const revenueForecast = currentMonthRevenue + receivableThisMonth;

    const kpis = {
      currentMonthRevenue,
      previousMonthRevenue,
      monthlyGrowthPercentage,
      newClientsThisMonth,
      activeClients,
      revenueForecast,
    };

    // --- Churn Analysis Calculation (for Analise page) ---
    const { data: lostClientsData, error: lostClientsError } = await applyUserIdFilter(
      supabase
        .from('clients')
        .select(`
          id,
          value,
          plans ( name )
        `)
    )
      .in('status', ['inactive', 'overdue'])
      .gte('next_billing_date', monthStart.toISODate())
      .lt('next_billing_date', monthEnd.toISODate()); // Use lt for exclusive end

    if (lostClientsError) throw lostClientsError;

    let lostClientsThisMonth = 0;
    let lostRevenueThisMonth = 0;
    const churnByPlanMap = new Map<string, { planName: string; lostCount: number }>();

    (lostClientsData || []).forEach((client: any) => {
      const planData = Array.isArray(client.plans) ? client.plans[0] : client.plans;
      const planName = planData?.name || 'Plano Desconhecido';
      const clientValue = client.value || 0;

      if (!churnByPlanMap.has(planName)) {
        churnByPlanMap.set(planName, { planName, lostCount: 0 });
      }
      churnByPlanMap.get(planName)!.lostCount++;

      lostClientsThisMonth++;
      lostRevenueThisMonth += clientValue;
    });

    const churnByPlan = Array.from(churnByPlanMap.values()).sort((a, b) => b.lostCount - a.lostCount);

    const totalClientsForChurn = activeClients + lostClientsThisMonth; // Corrected calculation for churn rate denominator
    const churnRate = totalClientsForChurn > 0
      ? (lostClientsThisMonth / totalClientsForChurn) * 100
      : 0;

    const churnAnalysis = {
      lostClientsThisMonth,
      lostRevenueThisMonth,
      churnRate,
      churnByPlan,
    };

    // --- Revenue Last 30 Days ---
    const revenueLast30DaysMap = new Map<string, number>();
    const thirtyDaysAgo = now.minus({ days: 29 }).startOf('day'); // Start of day 29 days ago
    
    for (let d = thirtyDaysAgo; d <= now.endOf('day'); d = d.plus({ days: 1 })) { // Iterate up to end of today
      revenueLast30DaysMap.set(d.toISODate(), 0);
    }

    (financialEntries as FinancialEntry[] || []).forEach((entry: FinancialEntry) => {
      const entryDateTime = DateTime.fromISO(entry.created_at, { zone: 'utc' }).toLocal();
      const entryDateStr = entryDateTime.toISODate();
      if (revenueLast30DaysMap.has(entryDateStr)) {
        revenueLast30DaysMap.set(entryDateStr, revenueLast30DaysMap.get(entryDateStr)! + entry.value);
      }
    });

    // --- Weekly Revenue Comparison ---
    const weeklyRevenueComparison: { [key: string]: { currentMonth: number; previousMonth: number } } = {};

    const getWeekNumber = (date: DateTime) => {
      // Luxon's week number is 1-indexed, relative to the start of the year.
      // We need to ensure consistency with how weeks are defined.
      // For simplicity, let's use Luxon's default week number for the year.
      return date.weekNumber;
    };

    const processWeeklyRevenue = (entries: FinancialEntry[] | null, start: DateTime, end: DateTime, targetObject: any, monthKey: 'currentMonth' | 'previousMonth') => {
      const monthEntries = (entries || []).filter((entry: FinancialEntry) => {
        const entryDateTime = DateTime.fromISO(entry.created_at, { zone: 'utc' }).toLocal();
        return entryDateTime >= start && entryDateTime < end;
      });

      monthEntries.forEach((entry: FinancialEntry) => {
        const entryDateTime = DateTime.fromISO(entry.created_at, { zone: 'utc' }).toLocal();
        const weekNum = getWeekNumber(entryDateTime);
        const weekKey = `week${weekNum}`;

        if (!targetObject[weekKey]) {
          targetObject[weekKey] = { currentMonth: 0, previousMonth: 0 };
        }
        targetObject[weekKey][monthKey] += entry.value;
      });
    };

    processWeeklyRevenue(financialEntries, monthStart, monthEnd, weeklyRevenueComparison, 'currentMonth');
    processWeeklyRevenue(financialEntries, previousMonthStart, previousMonthEnd, weeklyRevenueComparison, 'previousMonth');

    const allWeekKeys = new Set<string>();
    Object.keys(weeklyRevenueComparison).forEach(key => allWeekKeys.add(key));
    for (const key of allWeekKeys) {
      if (!weeklyRevenueComparison[key].currentMonth) weeklyRevenueComparison[key].currentMonth = 0;
      if (!weeklyRevenueComparison[key].previousMonth) weeklyRevenueComparison[key].previousMonth = 0; // Fix: ensure previousMonth is also initialized
    }

    // --- Revenue by Plan (Current Month) ---
    const revenueByPlanData: { planName: string; totalRevenue: number }[] = [];
    const tempRevenueByPlan = new Map<string, number>();

    (clients || []).forEach((client: any) => {
      const planData = Array.isArray(client.plans) ? client.plans[0] : client.plans;
      if (client.status === 'active' && planData?.name && planData?.id) {
        const planName = planData.name;
        const planValue = client.value || 0; // Use client.value for revenue by plan
        tempRevenueByPlan.set(planName, (tempRevenueByPlan.get(planName) || 0) + planValue);
      }
    });

    tempRevenueByPlan.forEach((totalRevenue, planName) => {
      revenueByPlanData.push({ planName, totalRevenue });
    });

    // --- Monthly Revenue History (Last 12 Months) ---
    const twelveMonthsAgoStart = now.minus({ months: 11 }).startOf('month'); // Start of month 11 months ago
    const currentMonthEndForHistory = now.endOf('month'); // End of current month for history range

    const { data: monthlyEntriesHistory, error: monthlyEntriesHistoryError } = await applyUserIdFilter(
      supabase
        .from('financial_entries')
        .select('value, created_at')
    )
      .eq('type', 'credit')
      .gte('created_at', twelveMonthsAgoStart.toUTC().toISO()) // Use UTC for DB query
      .lt('created_at', currentMonthEndForHistory.plus({ days: 1 }).toUTC().toISO()); // Use UTC for DB query, exclusive end

    if (monthlyEntriesHistoryError) throw monthlyEntriesHistoryError;
    console.log('Edge Function: monthlyEntriesHistory fetched, count:', monthlyEntriesHistory?.length || 0);

    const monthlyRevenueHistoryMap = new Map<string, number>();
    (monthlyEntriesHistory as FinancialEntry[] || []).forEach((entry: FinancialEntry) => {
      const entryDateTime = DateTime.fromISO(entry.created_at, { zone: 'utc' }).toLocal(); // Convert to local for grouping
      const monthKey = entryDateTime.toFormat('yyyy-MM');
      monthlyRevenueHistoryMap.set(monthKey, (monthlyRevenueHistoryMap.get(monthKey) || 0) + entry.value);
    });

    const monthlyRevenueHistory: { month: string; revenue: number }[] = [];
    let currentMonthIterator = twelveMonthsAgoStart.startOf('month');
    while (currentMonthIterator <= now.startOf('month')) { // Iterate up to start of current month
      const monthKey = currentMonthIterator.toFormat('yyyy-MM');
      const monthLabel = currentMonthIterator.toFormat('MMM/yy');
      monthlyRevenueHistory.push({
        month: monthLabel,
        revenue: monthlyRevenueHistoryMap.get(monthKey) || 0,
      });
      currentMonthIterator = currentMonthIterator.plus({ months: 1 });
    }

    console.log('Edge Function: Financial analysis data prepared successfully.');

    return new Response(
      JSON.stringify({
        kpis,
        revenueLast30Days: Array.from(revenueLast30DaysMap.entries()).map(([date, revenue]) => ({ date, revenue })),
        weeklyRevenueComparison,
        revenueByPlan: revenueByPlanData,
        churnAnalysis,
        monthlyRevenueHistory,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error: any) {
    console.error('Edge Function: Error fetching financial analysis:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred in the financial analysis function.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/financial-summary/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

// @ts-ignore
import { DateTime } from 'https://esm.sh/luxon@3.4.4'; // Use Luxon

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Interfaces para tipagem dos dados do Supabase
interface FinancialEntry {
  value: number;
  created_at: string;
}

interface ClientSummary {
  value: number;
  next_billing_date: string;
}

interface ChurnClient {
  value: number | null;
}

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    const userId = user.id;

    // Fetch user role
    const { data: userRoleData, error: userRoleError } = await supabase
      .from('user_roles')
      .select('role')
      .eq('user_id', userId)
      .single();

    if (userRoleError && userRoleError.code !== 'PGRST116') { // PGRST116 = No rows found
      console.error('Edge Function: Error fetching user role:', userRoleError.message);
      throw userRoleError;
    }
    const userRole = userRoleData?.role || 'user'; // Default to 'user' if no role found

    // Conditionally apply user_id filter
    const applyUserIdFilter = (query: any) => {
      return userRole === 'admin' ? query : query.eq('user_id', userId);
    };
    
    const now = DateTime.local(); // Current local time
    const todayStart = now.startOf('day');
    const todayEnd = now.plus({ days: 1 }).startOf('day'); // Exclusive end: start of tomorrow

    // Luxon's startOf('week') defaults to Monday. To match date-fns weekStartsOn: 0 (Sunday),
    // we need to set locale or explicitly adjust. 'en-US' starts on Sunday.
    const weekStart = now.setLocale('en-US').startOf('week');
    const weekEnd = weekStart.plus({ weeks: 1 }).startOf('day'); // Exclusive end: start of next week

    const monthStart = now.startOf('month');
    const monthEnd = monthStart.plus({ months: 1 }).startOf('day'); // Exclusive end: start of next month

    // --- Valores Recebidos (financial_entries) ---
    const { data: financialEntries, error: financialError } = await applyUserIdFilter(
      supabase
        .from('financial_entries')
        .select('value, created_at')
    )
      .eq('type', 'credit');

    if (financialError) throw financialError;
    console.log('Edge Function: financialEntries fetched, count:', financialEntries?.length || 0);

    let receivedToday = 0;
    let receivedThisWeek = 0;
    let receivedThisMonth = 0;

    (financialEntries as FinancialEntry[] || []).forEach((entry: FinancialEntry) => {
      const entryDateTime = DateTime.fromISO(entry.created_at, { zone: 'utc' }).toLocal(); // Convert to local for comparison
      if (entryDateTime >= todayStart && entryDateTime < todayEnd) {
        receivedToday += entry.value;
      }
      if (entryDateTime >= weekStart && entryDateTime < weekEnd) {
        receivedThisWeek += entry.value;
      }
      if (entryDateTime >= monthStart && entryDateTime < monthEnd) {
        receivedThisMonth += entry.value;
      }
    });

    // --- Previso de Recebveis (clients) ---
    const { data: clients, error: clientsError } = await applyUserIdFilter(
      supabase
        .from('clients')
        .select('value, next_billing_date')
    )
      .eq('status', 'active');

    if (clientsError) throw clientsError;
    console.log('Edge Function: clients fetched, count:', clients?.length || 0);

    let receivableToday = 0;
    let receivableTomorrow = 0;
    let receivableThisWeek = 0;
    let receivableThisMonth = 0;

    const tomorrowStart = now.plus({ days: 1 }).startOf('day');
    const tomorrowEnd = now.plus({ days: 2 }).startOf('day'); // Exclusive end: start of day after tomorrow

    (clients as ClientSummary[] || []).forEach((client: ClientSummary) => {
      if (!client.next_billing_date) return;
      const dueDate = DateTime.fromISO(client.next_billing_date, { zone: 'local' }).startOf('day'); // Treat as local date, start of day

      if (dueDate >= todayStart && dueDate < todayEnd) {
        receivableToday += client.value;
      }
      if (dueDate >= tomorrowStart && dueDate < tomorrowEnd) {
        receivableTomorrow += client.value;
      }
      if (dueDate >= weekStart && dueDate < weekEnd) {
        receivableThisWeek += client.value;
      }
      if (dueDate >= monthStart && dueDate < monthEnd) {
        receivableThisMonth += client.value;
      }
    });

    // --- Valores Perdidos (Churn) ---
    const { data: churnClientsToday, error: churnClientsTodayError } = await applyUserIdFilter(
      supabase
        .from('clients')
        .select('value')
    )
      .in('status', ['inactive', 'overdue'])
      .gte('next_billing_date', todayStart.toISODate())
      .lt('next_billing_date', todayEnd.toISODate()); // Use lt for exclusive end
    if (churnClientsTodayError) throw churnClientsTodayError;
    const lostValueToday = (churnClientsToday as ChurnClient[] || []).reduce((sum: number, client: ChurnClient) => sum + (client.value || 0), 0);
    console.log('Edge Function: lostValueToday calculated:', lostValueToday);

    const { data: churnClientsThisWeek, error: churnClientsThisWeekError } = await applyUserIdFilter(
      supabase
        .from('clients')
        .select('value')
    )
      .in('status', ['inactive', 'overdue'])
      .gte('next_billing_date', weekStart.toISODate())
      .lt('next_billing_date', weekEnd.toISODate()); // Use lt for exclusive end
    if (churnClientsThisWeekError) throw churnClientsThisWeekError;
    const lostValueThisWeek = (churnClientsThisWeek as ChurnClient[] || []).reduce((sum: number, client: ChurnClient) => sum + (client.value || 0), 0);
    console.log('Edge Function: lostValueThisWeek calculated:', lostValueThisWeek);

    const { data: churnClientsThisMonth, error: churnClientsThisMonthError } = await applyUserIdFilter(
      supabase
        .from('clients')
        .select('value')
    )
      .in('status', ['inactive', 'overdue'])
      .gte('next_billing_date', monthStart.toISODate())
      .lt('next_billing_date', monthEnd.toISODate()); // Use lt for exclusive end
    if (churnClientsThisMonthError) throw churnClientsThisMonthError;
    const lostValueThisMonth = (churnClientsThisMonth as ChurnClient[] || []).reduce((sum: number, client: ChurnClient) => sum + (client.value || 0), 0);
    console.log('Edge Function: lostValueThisMonth calculated:', lostValueThisMonth);

    console.log('Edge Function: Financial summary data prepared successfully.');

    return new Response(
      JSON.stringify({
        receivedToday,
        receivedThisWeek,
        receivedThisMonth,
        receivableToday,
        receivableTomorrow,
        receivableThisWeek,
        receivableThisMonth,
        lostValueToday,
        lostValueThisWeek,
        lostValueThisMonth,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error: any) {
    console.error('Edge Function: Error fetching financial summary:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred in the financial summary function.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/list-all-users/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    // Fetch all profiles and their roles, subscriptions, and user_instances
    const { data: usersData, error: usersError } = await supabaseAdmin
      .from('profiles')
      .select(`
        id,
        name,
        email,
        phone,
        created_at,
        user_roles(role),
        subscriptions(id, plan_name, price, status, next_billing_date),
        user_instances(id, instance_name, status)
      `)
      .order('created_at', { ascending: true });

    if (usersError) throw usersError;
    console.log('Edge Function: Users data fetched, count:', usersData?.length || 0);

    const formattedUsers = (usersData || []).map((profile: any) => {
      const role = Array.isArray(profile.user_roles) ? profile.user_roles[0]?.role : profile.user_roles?.role;
      const subscription = Array.isArray(profile.subscriptions) ? profile.subscriptions[0] : profile.subscriptions;
      const instance = Array.isArray(profile.user_instances) ? profile.user_instances[0] : profile.user_instances;

      return {
        id: profile.id,
        name: profile.name,
        email: profile.email,
        phone: profile.phone, // Adicionado o telefone
        created_at: profile.created_at,
        role: role || 'user', // Default to 'user' if no role found
        subscription: subscription ? {
          id: subscription.id,
          plan_name: subscription.plan_name,
          price: subscription.price,
          status: subscription.status,
          next_billing_date: subscription.next_billing_date,
        } : null,
        instance: instance ? {
          id: instance.id,
          instance_name: instance.instance_name,
          status: instance.status,
        } : null,
      };
    });

    return new Response(JSON.stringify(formattedUsers), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (error: any) {
    console.error('Edge Function: Error in list-all-users:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/log-n8n-qr-interaction/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseAdmin = createClient(
    // @ts-ignore
    Deno.env.get('SUPABASE_URL') ?? '',
    // @ts-ignore
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    const { requestPayload, responsePayload, statusCode, errorMessage, instanceName } = await req.json();

    // Service role bypasses RLS, so no explicit user_id filter needed here.
    const { error: insertError } = await supabaseAdmin
      .from('n8n_qr_code_history')
      .insert({
        user_id: user.id,
        webhook_type: 'n8n_outbound_qr',
        payload: { instanceName, requestPayload, responsePayload, errorMessage }, // Consolidar payload
        request_payload: requestPayload,
        response_payload: responsePayload,
        status_code: statusCode,
      });

    if (insertError) {
      console.error('log-n8n-qr-interaction: Error inserting into n8n_qr_code_history:', insertError.message);
      throw new Error(`Failed to log QR interaction: ${insertError.message}`);
    }

    return new Response(JSON.stringify({ success: true, message: 'QR interaction logged successfully.' }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });

  } catch (error: any) {
    console.error('log-n8n-qr-interaction: Unhandled error:', error.message);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/mercado-pago-create-charge/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseAdmin = createClient(
    // @ts-ignore
    Deno.env.get('SUPABASE_URL') ?? '',
    // @ts-ignore
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  try {
    console.log('mercado-pago-create-charge: Function started.');

    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      console.error('mercado-pago-create-charge: Unauthorized - Missing Authorization header.');
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      console.error('mercado-pago-create-charge: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    const userId = user.id;
    console.log('mercado-pago-create-charge: User authenticated, userId:', userId);

    const { subscription_id, amount } = await req.json();
    console.log(`mercado-pago-create-charge: Received payload: subscription_id=${subscription_id}, amount=${amount}`);

    if (!subscription_id || !amount) {
      console.error('mercado-pago-create-charge: Missing subscription_id or amount in payload.');
      return new Response(JSON.stringify({ error: 'Missing subscription_id or amount.' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    // 1. Fetch Mercado Pago credentials
    console.log('mercado-pago-create-charge: Fetching Mercado Pago configs...');
    const { data: mpConfig, error: configError } = await supabaseAdmin
      .from('mercado_pago_configs')
      .select('mercado_pago_access_token')
      .eq('id', 1)
      .single();

    if (configError || !mpConfig) {
      console.error('mercado-pago-create-charge: Mercado Pago config not found:', configError?.message);
      return new Response(JSON.stringify({ error: 'Mercado Pago configuration not found. Please contact support.' }), {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('mercado-pago-create-charge: Mercado Pago config fetched successfully.');

    const mercadoPagoAccessToken = mpConfig.mercado_pago_access_token;
    const mercadoPagoApiUrl = 'https://api.mercadopago.com/v1/payments'; // Mercado Pago Payments API

    // 2. Fetch subscription details to get plan_name for description
    console.log('mercado-pago-create-charge: Fetching subscription details...');
    const { data: subscription, error: subscriptionError } = await supabaseAdmin
      .from('subscriptions')
      .select('plan_name')
      .eq('id', subscription_id)
      .single();

    if (subscriptionError || !subscription) {
      console.error('mercado-pago-create-charge: Subscription not found:', subscriptionError?.message);
      return new Response(JSON.stringify({ error: 'Subscription not found for the provided ID.' }), {
        status: 404,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('mercado-pago-create-charge: Subscription details fetched successfully. Plan Name:', subscription.plan_name);

    // 2.1. Fetch customer data from profiles (including email, phone, tax_id)
    console.log('mercado-pago-create-charge: Fetching customer profile...');
    const { data: profile, error: profileError } = await supabaseAdmin
      .from('profiles')
      .select('name, email, phone, tax_id')
      .eq('id', userId)
      .single();

    if (profileError || !profile) {
      console.error('mercado-pago-create-charge: Customer profile not found for userId:', userId, profileError?.message);
      return new Response(JSON.stringify({ error: 'Perfil do usurio no encontrado.' }), {
        status: 404,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('mercado-pago-create-charge: Customer profile fetched successfully. Name:', profile.name);

    // Validao e limpeza do tax_id do perfil
    const cleanedTaxId = profile.tax_id?.replace(/\D/g, '');
    if (!cleanedTaxId || (cleanedTaxId.length !== 11 && cleanedTaxId.length !== 14)) {
      console.error('mercado-pago-create-charge: Invalid or missing CPF/CNPJ in user profile:', profile.tax_id);
      return new Response(JSON.stringify({ error: 'CPF/CNPJ invlido ou ausente no perfil do usurio. Por favor, atualize seu perfil.' }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // 3. Build Mercado Pago API Payload for PIX payment
    const mpRequestBody: any = {
      transaction_amount: amount,
      description: `Renovao de Assinatura ${subscription.plan_name}`,
      payment_method_id: 'pix',
      payer: {
        email: profile.email,
        first_name: profile.name.split(' ')[0],
        last_name: profile.name.split(' ').slice(1).join(' ') || '',
        identification: {
          type: cleanedTaxId.length === 11 ? 'CPF' : 'CNPJ',
          number: cleanedTaxId,
        },
        // phone: { // Mercado Pago often requires phone for certain payment methods, but not strictly for PIX
        //   area_code: profile.phone?.substring(2, 4) || '',
        //   number: profile.phone?.substring(4) || '',
        // },
      },
      external_reference: `sub-${subscription_id}-${Date.now()}`, // Unique reference for tracking
      notification_url: `${Deno.env.get('SUPABASE_URL')}/functions/v1/mercado-pago-webhook-receiver`, // Webhook para receber atualizaes
    };

    // Gerar um X-Idempotency-Key nico
    const idempotencyKey = `mp-charge-${subscription_id}-${Date.now()}`;
    console.log(`mercado-pago-create-charge: Using X-Idempotency-Key: ${idempotencyKey}`);

    console.log('mercado-pago-create-charge: Sending request to Mercado Pago API with body:', JSON.stringify(mpRequestBody, null, 2));

    const mpResponse = await fetch(mercadoPagoApiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${mercadoPagoAccessToken}`,
        'X-Idempotency-Key': idempotencyKey, // Adicionado o cabealho de idempotncia
      },
      body: JSON.stringify(mpRequestBody),
    });

    const mpResponseData = await mpResponse.json();
    console.log('mercado-pago-create-charge: Mercado Pago API raw response:', JSON.stringify(mpResponseData, null, 2));

    if (!mpResponse.ok) {
      console.error('mercado-pago-create-charge: Mercado Pago API error response:', mpResponseData);
      const errorMessage = mpResponseData.message || mpResponseData.error_messages?.[0]?.message || `Falha ao criar cobrana PIX no Mercado Pago: ${mpResponse.statusText}`;
      throw new Error(errorMessage);
    }

    // 4. Extract data from Mercado Pago response
    const mercadoPagoPaymentId = mpResponseData.id;
    const qrCodeImageUrl = mpResponseData.point_of_interaction?.transaction_data?.qr_code_base64 
                           ? `data:image/png;base64,${mpResponseData.point_of_interaction.transaction_data.qr_code_base64}`
                           : null;
    const qrCodeText = mpResponseData.point_of_interaction?.transaction_data?.qr_code;

    if (!mercadoPagoPaymentId || !qrCodeImageUrl || !qrCodeText) {
      console.error('mercado-pago-create-charge: Missing required data in Mercado Pago response:', mpResponseData);
      throw new Error('Dados essenciais (ID do pagamento, QR Code) no encontrados na resposta do Mercado Pago.');
    }
    console.log('mercado-pago-create-charge: Mercado Pago response parsed successfully. Payment ID:', mercadoPagoPaymentId);

    // 5. Save charge details to mercado_pago_charges
    console.log('mercado-pago-create-charge: Inserting charge into mercado_pago_charges...');
    const { data: newCharge, error: insertError } = await supabaseAdmin
      .from('mercado_pago_charges')
      .insert({
        user_id: userId,
        subscription_id: subscription_id,
        mercado_pago_payment_id: String(mercadoPagoPaymentId), // Ensure it's a string
        status: 'pending', // Initial status
        value: amount,
      })
      .select()
      .single();

    if (insertError) {
      console.error('mercado-pago-create-charge: Error inserting Mercado Pago charge:', insertError.message);
      throw new Error(`Failed to record Mercado Pago charge: ${insertError.message}`);
    }
    console.log('mercado-pago-create-charge: Charge inserted successfully, newChargeId:', newCharge.id);

    const responsePayload = {
      mercado_pago_payment_id: newCharge.mercado_pago_payment_id,
      qr_code_image_url: qrCodeImageUrl,
      qr_code_text: qrCodeText,
      value: amount,
    };
    console.log('mercado-pago-create-charge: Returning response:', JSON.stringify(responsePayload));

    return new Response(JSON.stringify(responsePayload), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });

  } catch (error: any) {
    console.error('mercado-pago-create-charge: Unhandled error in Edge Function:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/mercado-pago-webhook-receiver/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';
// @ts-ignore
import { DateTime } from 'https://esm.sh/luxon@3.4.4';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseAdmin = createClient(
    // @ts-ignore
    Deno.env.get('SUPABASE_URL') ?? '',
    // @ts-ignore
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  try {
    const payload = await req.json();
    console.log('Mercado Pago Webhook received payload:', JSON.stringify(payload, null, 2));

    // Mercado Pago sends different event types. We are interested in 'payment' events.
    // The actual payment ID is usually in payload.data.id for payment events.
    const eventType = payload.type;
    const paymentId = payload.data?.id; // This is the Mercado Pago payment ID

    if (eventType !== 'payment' || !paymentId) {
      console.warn('Mercado Pago Webhook: Not a payment event or missing payment ID. Skipping.');
      return new Response(JSON.stringify({ message: 'Not a relevant event type or missing payment ID.' }), {
        status: 200, // Return 200 to acknowledge receipt, even if not processed
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // 1. Fetch payment details from Mercado Pago API to get the full status
    console(`Mercado Pago Webhook: Fetching payment details for ID: ${paymentId}`);
    const { data: mpConfig, error: configError } = await supabaseAdmin
      .from('mercado_pago_configs')
      .select('mercado_pago_access_token')
      .eq('id', 1)
      .single();

    if (configError || !mpConfig) {
      console.error('Mercado Pago Webhook: Mercado Pago config not found:', configError?.message);
      throw new Error('Mercado Pago configuration not found. Please contact support.');
    }
    const mercadoPagoAccessToken = mpConfig.mercado_pago_access_token;
    const paymentApiUrl = `https://api.mercadopago.com/v1/payments/${paymentId}`;

    const mpResponse = await fetch(paymentApiUrl, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${mercadoPagoAccessToken}`,
      },
    });

    const mpPaymentData = await mpResponse.json();
    console.log('Mercado Pago Webhook: Fetched payment data:', JSON.stringify(mpPaymentData, null, 2));

    if (!mpResponse.ok) {
      console.error('Mercado Pago Webhook: Error fetching payment details from MP API:', mpPaymentData);
      throw new Error(`Failed to fetch payment details from Mercado Pago: ${mpPaymentData.message || mpResponse.statusText}`);
    }

    const mpPaymentStatus = mpPaymentData.status; // e.g., 'approved', 'pending', 'rejected', 'cancelled'
    const externalReference = mpPaymentData.external_reference; // Our reference_id
    const transactionAmount = mpPaymentData.transaction_amount;

    if (!externalReference) {
      console.error('Mercado Pago Webhook: Missing external_reference in payment data.');
      return new Response(JSON.stringify({ error: 'Missing external_reference in payment data.' }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // Extract subscription_id from external_reference (e.g., "sub-UUID-TIMESTAMP")
    const subscriptionIdMatch = externalReference.match(/sub-([a-f0-9-]+)-\d+/);
    const subscription_id = subscriptionIdMatch ? subscriptionIdMatch[1] : null;

    if (!subscription_id) {
      console.error('Mercado Pago Webhook: Could not extract subscription_id from external_reference:', externalReference);
      return new Response(JSON.stringify({ error: 'Could not extract subscription_id from external_reference.' }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // 2. Find the corresponding charge in mercado_pago_charges
    const { data: charge, error: chargeError } = await supabaseAdmin
      .from('mercado_pago_charges')
      .select('id, user_id, subscription_id, status, value')
      .eq('mercado_pago_payment_id', String(paymentId))
      .eq('subscription_id', subscription_id)
      .single();

    if (chargeError || !charge) {
      console.error(`Mercado Pago Webhook: Charge ${paymentId} not found in DB or error:`, chargeError?.message);
      return new Response(JSON.stringify({ error: `Charge ${paymentId} not found.` }), {
        status: 404,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // 3. Process if status is 'approved' and current DB status is 'pending'
    if (mpPaymentStatus === 'approved' && charge.status === 'pending') {
      console.log(`Mercado Pago Webhook: Processing 'approved' status for charge ${paymentId}.`);

      // Update status in mercado_pago_charges
      const { error: updateChargeError } = await supabaseAdmin
        .from('mercado_pago_charges')
        .update({ status: 'approved' })
        .eq('id', charge.id);

      if (updateChargeError) {
        console.error('Mercado Pago Webhook: Error updating mercado_pago_charges status:', updateChargeError.message);
        throw new Error(`Failed to update charge status: ${updateChargeError.message}`);
      }

      // Get subscription details
      const { data: subscription, error: subError } = await supabaseAdmin
        .from('subscriptions')
        .select('id, user_id, plan_name, price, next_billing_date, subscriber_plans(period_days)')
        .eq('id', charge.subscription_id)
        .single();

      if (subError || !subscription) {
        console.error('Mercado Pago Webhook: Subscription not found or error:', subError?.message);
        throw new Error(`Subscription ${charge.subscription_id} not found.`);
      }

      const planData = Array.isArray(subscription.subscriber_plans) ? subscription.subscriber_plans[0] : subscription.subscriber_plans;
      const periodDays = planData?.period_days;

      if (!periodDays) {
        console.error('Mercado Pago Webhook: Plan period_days not found for subscription:', subscription.id);
        throw new Error(`Plan period_days not found for subscription ${subscription.id}.`);
      }

      // Calculate new next_billing_date
      const currentDueDate = DateTime.fromISO(subscription.next_billing_date, { zone: 'local' }).startOf('day');
      const newNextBillingDate = currentDueDate.plus({ days: periodDays }).toISODate();

      // Update subscription
      const { error: updateSubError } = await supabaseAdmin
        .from('subscriptions')
        .update({ next_billing_date: newNextBillingDate, status: 'active' })
        .eq('id', subscription.id);

      if (updateSubError) {
        console.error('Mercado Pago Webhook: Error updating subscription:', updateSubError.message);
        throw new Error(`Failed to update subscription: ${updateSubError.message}`);
      }

      // Get admin_user_id from mercado_pago_configs (assuming the admin who set it up is the one to log revenue)
      const { data: adminConfig, error: adminConfigError } = await supabaseAdmin
        .from('mercado_pago_configs')
        .select('id') // Just need any ID to represent the admin
        .eq('id', 1)
        .single();

      if (adminConfigError || !adminConfig) {
        console.warn('Mercado Pago Webhook: Admin Mercado Pago config not found for logging financial entry. Using generic admin ID.');
      }
      const adminUserId = adminConfig?.id ? String(adminConfig.id) : '00000000-0000-0000-0000-000000000000'; // Fallback to a generic ID

      // Create new entry in admin_financial_entries
      const { error: financialEntryError } = await supabaseAdmin
        .from('admin_financial_entries')
        .insert({
          admin_user_id: adminUserId, // The admin who owns the platform
          subscriber_id: charge.user_id, // The user who paid
          description: `Pagamento PIX - Renovao de Assinatura (${subscription.plan_name})`,
          value: transactionAmount, // Use transactionAmount from MP response
          type: 'credit',
        });

      if (financialEntryError) {
        console.error('Mercado Pago Webhook: Error creating admin financial entry:', financialEntryError.message);
        // Do not throw, as the core payment processing is done
      }

      console.log(`Mercado Pago Webhook: Subscription ${subscription.id} renewed and financial entry created.`);
    } else if (mpPaymentStatus === 'rejected' || mpPaymentStatus === 'cancelled' || mpPaymentStatus === 'refunded') {
      console.log(`Mercado Pago Webhook: Processing ${mpPaymentStatus} status for charge ${paymentId}.`);
      const { error: updateChargeError } = await supabaseAdmin
        .from('mercado_pago_charges')
        .update({ status: mpPaymentStatus })
        .eq('id', charge.id);

      if (updateChargeError) {
        console.error(`Mercado Pago Webhook: Error updating mercado_pago_charges status to ${mpPaymentStatus}:`, updateChargeError.message);
      }
    } else {
      console.log(`Mercado Pago Webhook: Charge ${paymentId} status is ${charge.status} in DB, received ${mpPaymentStatus}. No action taken.`);
    }

    return new Response(JSON.stringify({ success: true, message: 'Webhook processed.' }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });

  } catch (error: any) {
    console.error('Edge Function: Error in mercado-pago-webhook-receiver:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/pagbank-create-charge/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseAdmin = createClient(
    // @ts-ignore
    Deno.env.get('SUPABASE_URL') ?? '',
    // @ts-ignore
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  try {
    console.log('pagbank-create-charge: Function started.');

    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      console.error('pagbank-create-charge: Unauthorized - Missing Authorization header.');
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      console.error('pagbank-create-charge: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    const userId = user.id;
    console.log('pagbank-create-charge: User authenticated, userId:', userId);

    const { subscription_id, amount } = await req.json();
    console.log(`pagbank-create-charge: Received payload: subscription_id=${subscription_id}, amount=${amount}`);

    if (!subscription_id || !amount) {
      console.error('pagbank-create-charge: Missing subscription_id or amount in payload.');
      return new Response(JSON.stringify({ error: 'Missing subscription_id or amount.' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    // 1. Fetch PagBank credentials and environment
    console.log('pagbank-create-charge: Fetching PagBank configs...');
    const { data: pagbankConfig, error: configError } = await supabaseAdmin
      .from('pagbank_configs')
      .select('pagbank_email, pagbank_token, pagbank_pix_key, environment') // NOVO: Incluir 'environment'
      .eq('id', 1)
      .single();

    if (configError || !pagbankConfig) {
      console.error('pagbank-create-charge: PagBank config not found:', configError?.message);
      return new Response(JSON.stringify({ error: 'PagBank configuration not found. Please contact support.' }), {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('pagbank-create-charge: PagBank config fetched successfully. Environment:', pagbankConfig.environment); // NOVO: Log do ambiente

    // NOVO: Definir a URL base da API PagBank com base no ambiente
    const baseUrl = pagbankConfig.environment === 'production'
      ? 'https://api.pagseguro.com'
      : 'https://sandbox.api.pagseguro.com';
    const pagbankApiUrl = `${baseUrl}/orders`; // Usar a baseUrl dinmica
    console.log('pagbank-create-charge: Using PagBank API URL:', pagbankApiUrl);


    // 2. Fetch subscription details to get plan_name for description
    console.log('pagbank-create-charge: Fetching subscription details...');
    const { data: subscription, error: subscriptionError } = await supabaseAdmin
      .from('subscriptions')
      .select('plan_name')
      .eq('id', subscription_id)
      .single();

    if (subscriptionError || !subscription) {
      console.error('pagbank-create-charge: Subscription not found:', subscriptionError?.message);
      return new Response(JSON.stringify({ error: 'Subscription not found for the provided ID.' }), {
        status: 404,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('pagbank-create-charge: Subscription details fetched successfully. Plan Name:', subscription.plan_name);

    // 2.1. Fetch customer data from profiles (including phone and new tax_id)
    console.log('pagbank-create-charge: Fetching customer profile...');
    const { data: profile, error: profileError } = await supabaseAdmin
      .from('profiles')
      .select('name, email, phone, tax_id') // Includo o novo campo tax_id
      .eq('id', userId)
      .single();

    if (profileError || !profile) {
      console.error('pagbank-create-charge: Customer profile not found for userId:', userId, profileError?.message);
      return new Response(JSON.stringify({ error: 'Perfil do usurio no encontrado.' }), {
        status: 404,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('pagbank-create-charge: Customer profile fetched successfully. Name:', profile.name);

    // Validao e limpeza do tax_id do perfil
    const cleanedTaxId = profile.tax_id?.replace(/\D/g, '');
    if (!cleanedTaxId || (cleanedTaxId.length !== 11 && cleanedTaxId.length !== 14)) {
      console.error('pagbank-create-charge: Invalid or missing CPF/CNPJ in user profile:', profile.tax_id);
      return new Response(JSON.stringify({ error: 'CPF/CNPJ invlido ou ausente no perfil do usurio. Por favor, atualize seu perfil.' }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // 3. Build CORRECT PagBank API Payload (based on Pedido.pdf)
    const amountInCents = Math.round(amount * 100); // PagBank expects amount in cents

    const pagbankRequestBody: any = {
      reference_id: `sub-${subscription_id}-${Date.now()}`, // Unique reference for tracking
      customer: {
        name: profile.name,
        email: profile.email,
        tax_id: cleanedTaxId, // Usando o tax_id limpo e validado do perfil
      },
      items: [
        {
          name: `Assinatura ${subscription.plan_name}`,
          quantity: 1,
          unit_amount: amountInCents,
        },
      ],
      qr_codes: [
        {
          amount: {
            value: amountInCents,
          },
          expiration_date: new Date(Date.now() + 3600 * 1000).toISOString(), // 1 hour expiration
        },
      ],
      notification_urls: [
        // @ts-ignore
        `${Deno.env.get('SUPABASE_URL')}/functions/v1/pagbank-webhook-receiver` // CORRIGIDO: Usando SUPABASE_URL
      ],
    };

    // Populate customer phones conditionally
    const cleanedPhone = profile.phone?.replace(/\D/g, '');
    if (cleanedPhone && cleanedPhone.length >= 10 && cleanedPhone.startsWith('55')) { // Basic validation for BR phone
      const areaCode = cleanedPhone.substring(2, 4); // Assuming 55DD
      const phoneNumber = cleanedPhone.substring(4); // Rest of the number
      pagbankRequestBody.customer.phones = [
        {
          country: "55",
          area: areaCode,
          number: phoneNumber,
          type: "MOBILE" // Assuming mobile phone
        }
      ];
    }

    console.log('pagbank-create-charge: Sending request to PagBank API with body:', JSON.stringify(pagbankRequestBody, null, 2));

    const pagbankResponse = await fetch(pagbankApiUrl, { // Usar pagbankApiUrl dinmica
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${pagbankConfig.pagbank_token}`,
        'x-api-version': '2024-03-01' // As suggested, or check latest PagBank docs
      },
      body: JSON.stringify(pagbankRequestBody),
    });

    const pagbankResponseData = await pagbankResponse.json();
    console.log('pagbank-create-charge: PagBank API raw response:', JSON.stringify(pagbankResponseData, null, 2));

    if (!pagbankResponse.ok) {
      console.error('pagbank-create-charge: PagBank API error response:', pagbankResponseData);
      const errorMessage = pagbankResponseData.message || pagbankResponseData.error_messages?.[0]?.description || `Falha ao criar cobrana PIX no PagBank: ${pagbankResponse.statusText}`;
      throw new Error(errorMessage);
    }

    // 4. Extract data from PagBank response (for /orders endpoint)
    const pagbankChargeId = pagbankResponseData.id;
    // CORRIGIDO: Extrao da URL da imagem do QR Code
    const qrCodeImageUrl = pagbankResponseData.qr_codes?.[0]?.links?.find((link: any) => link.rel === 'QRCODE.PNG')?.href;
    const qrCodeText = pagbankResponseData.qr_codes?.[0]?.text;

    if (!pagbankChargeId || !qrCodeImageUrl || !qrCodeText) {
      console.error('pagbank-create-charge: Missing required data in PagBank response:', pagbankResponseData);
      throw new Error('Dados essenciais (ID da cobrana, QR Code) no encontrados na resposta do PagBank.');
    }
    console.log('pagbank-create-charge: PagBank response parsed successfully. Charge ID:', pagbankChargeId);

    // 5. Save charge details to pagbank_charges
    console.log('pagbank-create-charge: Inserting charge into pagbank_charges...');
    const { data: newCharge, error: insertError } = await supabaseAdmin
      .from('pagbank_charges')
      .insert({
        user_id: userId,
        subscription_id: subscription_id,
        pagbank_charge_id: pagbankChargeId,
        status: 'PENDING',
        value: amount,
      })
      .select()
      .single();

    if (insertError) {
      console.error('pagbank-create-charge: Error inserting PagBank charge:', insertError.message);
      throw new Error(`Failed to record PagBank charge: ${insertError.message}`);
    }
    console.log('pagbank-create-charge: Charge inserted successfully, newChargeId:', newCharge.id);

    const responsePayload = {
      pagbank_charge_id: newCharge.pagbank_charge_id,
      qr_code_image_url: qrCodeImageUrl,
      qr_code_text: qrCodeText,
      value: amount,
    };
    console.log('pagbank-create-charge: Returning response:', JSON.stringify(responsePayload));

    return new Response(JSON.stringify(responsePayload), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });

  } catch (error: any) {
    console.error('pagbank-create-charge: Unhandled error in Edge Function:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/pagbank-webhook-receiver/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';
// @ts-ignore
import { DateTime } from 'https://esm.sh/luxon@3.4.4';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseAdmin = createClient(
    // @ts-ignore
    Deno.env.get('SUPABASE_URL') ?? '',
    // @ts-ignore
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  try {
    const payload = await req.json();
    console.log('PagBank Webhook received payload:', JSON.stringify(payload, null, 2));

    // Mock PagBank payload structure for demonstration
    // In a real scenario, you would parse the actual PagBank webhook payload
    const pagbankChargeId = payload.charge_id || payload.id; // Assuming charge_id or id is present
    const pagbankStatus = payload.status; // Assuming status is 'PAID', 'PENDING', 'EXPIRED'

    if (!pagbankChargeId || !pagbankStatus) {
      console.error('PagBank Webhook: Missing charge_id or status in payload.');
      return new Response(JSON.stringify({ error: 'Missing charge_id or status in payload.' }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // 1. Find the corresponding charge in pagbank_charges
    const { data: charge, error: chargeError } = await supabaseAdmin
      .from('pagbank_charges')
      .select('id, user_id, subscription_id, status, value')
      .eq('pagbank_charge_id', pagbankChargeId)
      .single();

    if (chargeError || !charge) {
      console.error(`PagBank Webhook: Charge ${pagbankChargeId} not found in DB or error:`, chargeError?.message);
      return new Response(JSON.stringify({ error: `Charge ${pagbankChargeId} not found.` }), {
        status: 404,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // 2. Process if status is PAID and current DB status is PENDING
    if (pagbankStatus === 'PAID' && charge.status === 'PENDING') {
      console.log(`PagBank Webhook: Processing PAID status for charge ${pagbankChargeId}.`);

      // Update status in pagbank_charges
      const { error: updateChargeError } = await supabaseAdmin
        .from('pagbank_charges')
        .update({ status: 'PAID' })
        .eq('id', charge.id);

      if (updateChargeError) {
        console.error('PagBank Webhook: Error updating pagbank_charges status:', updateChargeError.message);
        throw new Error(`Failed to update charge status: ${updateChargeError.message}`);
      }

      // Get subscription details
      const { data: subscription, error: subError } = await supabaseAdmin
        .from('subscriptions')
        .select('id, user_id, plan_name, price, next_billing_date, subscriber_plans(period_days)')
        .eq('id', charge.subscription_id)
        .single();

      if (subError || !subscription) {
        console.error('PagBank Webhook: Subscription not found or error:', subError?.message);
        throw new Error(`Subscription ${charge.subscription_id} not found.`);
      }

      const planData = Array.isArray(subscription.subscriber_plans) ? subscription.subscriber_plans[0] : subscription.subscriber_plans;
      const periodDays = planData?.period_days;

      if (!periodDays) {
        console.error('PagBank Webhook: Plan period_days not found for subscription:', subscription.id);
        throw new Error(`Plan period_days not found for subscription ${subscription.id}.`);
      }

      // Calculate new next_billing_date
      const currentDueDate = DateTime.fromISO(subscription.next_billing_date, { zone: 'local' }).startOf('day');
      const newNextBillingDate = currentDueDate.plus({ days: periodDays }).toISODate();

      // Update subscription
      const { error: updateSubError } = await supabaseAdmin
        .from('subscriptions')
        .update({ next_billing_date: newNextBillingDate, status: 'active' })
        .eq('id', subscription.id);

      if (updateSubError) {
        console.error('PagBank Webhook: Error updating subscription:', updateSubError.message);
        throw new Error(`Failed to update subscription: ${updateSubError.message}`);
      }

      // Get admin_user_id from pagbank_configs (assuming the admin who set it up is the one to log revenue)
      const { data: adminConfig, error: adminConfigError } = await supabaseAdmin
        .from('pagbank_configs')
        .select('id') // Just need any ID to represent the admin
        .eq('id', 1)
        .single();

      if (adminConfigError || !adminConfig) {
        console.warn('PagBank Webhook: Admin PagBank config not found for logging financial entry. Using generic admin ID.');
      }
      const adminUserId = adminConfig?.id ? String(adminConfig.id) : '00000000-0000-0000-0000-000000000000'; // Fallback to a generic ID

      // Create new entry in admin_financial_entries
      const { error: financialEntryError } = await supabaseAdmin
        .from('admin_financial_entries')
        .insert({
          admin_user_id: adminUserId, // The admin who owns the platform
          subscriber_id: charge.user_id, // The user who paid
          description: `Pagamento PIX - Renovao de Assinatura (${subscription.plan_name})`,
          value: charge.value,
          type: 'credit',
        });

      if (financialEntryError) {
        console.error('PagBank Webhook: Error creating admin financial entry:', financialEntryError.message);
        // Do not throw, as the core payment processing is done
      }

      console.log(`PagBank Webhook: Subscription ${subscription.id} renewed and financial entry created.`);
    } else if (pagbankStatus === 'EXPIRED' && charge.status === 'PENDING') {
      console.log(`PagBank Webhook: Processing EXPIRED status for charge ${pagbankChargeId}.`);
      const { error: updateChargeError } = await supabaseAdmin
        .from('pagbank_charges')
        .update({ status: 'EXPIRED' })
        .eq('id', charge.id);

      if (updateChargeError) {
        console.error('PagBank Webhook: Error updating pagbank_charges status to EXPIRED:', updateChargeError.message);
      }
    } else {
      console.log(`PagBank Webhook: Charge ${pagbankChargeId} status is ${charge.status} in DB, received ${pagbankStatus}. No action taken.`);
    }

    return new Response(JSON.stringify({ success: true, message: 'Webhook processed.' }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });

  } catch (error: any) {
    console.error('Edge Function: Error in pagbank-webhook-receiver:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/populate-send-queue/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

// @ts-ignore
import { addDays, format, startOfDay } from 'https://esm.sh/date-fns@3.6.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Define the type for the client rows fetched from the database
interface ClientRow {
  id: string;
  user_id: string;
  next_billing_date: string;
  status: 'active' | 'inactive' | 'overdue'; // Assuming these are the enum values
}

// Define the type for automation rows fetched from the database
interface AutomationRow {
  id: string;
  user_id: string;
  days_offset: number;
  template_id: string;
  client_ids: string[];
  created_at: string;
  updated_at: string;
}

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    console.log('Edge Function: populate-send-queue started.');

    const today = startOfDay(new Date());
    // Removed: const todayFormatted = format(today, 'yyyy-MM-dd');

    // 1. Buscar todas as regras de automao
    // This function is called by a cron job, so it needs to process all users' automations.
    // RLS on automations table will ensure only admins can see all, but the service role bypasses RLS.
    const { data: automationsData, error: automationsError } = await supabaseAdmin
      .from('automations')
      .select('*');

    if (automationsError) throw automationsError;
    console.log(`Edge Function: Found ${automationsData?.length || 0} automations.`);

    if (!automationsData || automationsData.length === 0) {
      return new Response(JSON.stringify({ message: 'No automations found to process.' }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      });
    }

    const automations: AutomationRow[] = automationsData as AutomationRow[];

    // 2. Buscar todos os clientes ativos ou vencidos
    // This function is called by a cron job, so it needs to process all users' clients.
    // RLS on clients table will ensure only admins can see all, but the service role bypasses RLS.
    const { data: clientsData, error: clientsError } = await supabaseAdmin
      .from('clients')
      .select('id, user_id, next_billing_date, status');

    if (clientsError) throw clientsError;
    console.log(`Edge Function: Found ${clientsData?.length || 0} clients.`);

    // Cast clientsData to the defined ClientRow type
    const clients: ClientRow[] = clientsData as ClientRow[];
    const clientsMap = new Map(clients.map(c => [c.id, c]));

    const pendingSendsToInsert: any[] = [];

    // 3. Processar Regras
    for (const automation of automations) {
      for (const clientId of automation.client_ids) {
        const client = clientsMap.get(clientId);

        // Ensure the client belongs to the automation's user_id
        if (!client || client.user_id !== automation.user_id || (client.status !== 'active' && client.status !== 'overdue')) {
          // Ignorar clientes no encontrados, no pertencentes ao usurio da automao, ou inativos
          continue;
        }

        const nextBillingDate = new Date(client.next_billing_date + 'T00:00:00'); // Tratar como data local
        const scheduledFor = addDays(nextBillingDate, automation.days_offset);
        const scheduledForFormatted = format(scheduledFor, 'yyyy-MM-dd');

        // Condio: Se a scheduled_for calculada for hoje ou uma data no futuro
        if (scheduledFor >= today) {
          pendingSendsToInsert.push({
            user_id: client.user_id,
            client_id: client.id,
            automation_id: automation.id,
            template_id: automation.template_id,
            scheduled_for: scheduledForFormatted,
          });
        }
      }
    }

    if (pendingSendsToInsert.length > 0) {
      const { error: insertError } = await supabaseAdmin
        .from('pending_sends')
        .upsert(pendingSendsToInsert, { 
          onConflict: 'client_id,automation_id,scheduled_for',
          ignoreDuplicates: true 
        });

      if (insertError) throw insertError;
      console.log(`Edge Function: Successfully inserted/skipped ${pendingSendsToInsert.length} pending sends.`);
    } else {
      console.log('Edge Function: No new pending sends to insert.');
    }

    return new Response(JSON.stringify({ message: 'Send queue populated successfully.' }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (error: any) {
    console.error('Edge Function: Error populating send queue:', error.message);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred in populate-send-queue.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/process-queue-and-send/index.ts ---
// @ts-ignore
/// <reference lib="deno.ns" />
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

// @ts-ignore
import { DateTime } from 'https://esm.sh/luxon@3.4.4'; // Use Luxon

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Definindo a interface para o objeto de notificao
interface NotificationItem {
  id: string;
  user_id: string; // Adicionado para logs
}

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  // 1. Segurana: Verificar o segredo do cron
  // @ts-ignore
  const cronSecret = Deno.env.get('CRON_SECRET');
  const authHeader = req.headers.get('Authorization');
  if (!cronSecret || authHeader !== `Bearer ${cronSecret}`) {
    console.warn('process-queue-and-send: Unauthorized access attempt.');
    return new Response('Unauthorized', { status: 401, headers: corsHeaders });
  }

  try {
    console.log('process-queue-and-send: Function started.');
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    // POLTICA DE TIMEZONE: Sempre trabalhar em UTC no backend
    const currentTime = DateTime.now().toUTC(); // Use Luxon for current UTC time
    const currentTimeISO = currentTime.toISO();
    console.log(`process-queue-and-send: Current UTC time for comparison: ${currentTimeISO}`);
    console.log(`process-queue-and-send: Current UTC timestamp: ${currentTime.toMillis()}`);

    // 2. Buscar notificaes pendentes que j devem ser enviadas
    // IMPORTANTE: send_at j est em UTC (salvo pelo frontend via Luxon)
    // This function is called by a cron job, so it needs to process all users' scheduled notifications.
    // RLS on scheduled_notifications table will ensure only admins can see all, but the service role bypasses RLS.
    const { data: notifications, error } = await supabaseAdmin
      .from('scheduled_notifications')
      .select('id, user_id, send_at, client_id, clients(name)') // Adiciona client info para logs
      .eq('status', 'pending')
      .lte('send_at', currentTimeISO)
      .order('send_at', { ascending: true });

    if (error) {
      console.error('process-queue-and-send: Error fetching pending notifications:', error.message);
      throw error;
    }
    
    console.log(`process-queue-and-send: Found ${notifications?.length || 0} notifications where send_at <= ${currentTimeISO}`);
    
    if (notifications && notifications.length > 0) {
      notifications.forEach((n: any) => { 
        const sendAtDateTime = DateTime.fromISO(n.send_at, { zone: 'utc' }); // Parse send_at as UTC
        const clientData = Array.isArray(n.clients) ? n.clients[0] : n.clients;
        const clientName = clientData?.name || 'Unknown';
        const delayMinutes = Math.round((currentTime.diff(sendAtDateTime, 'minutes').minutes)); // Luxon diff
        console.log(`  - ID: ${n.id}, Client: ${clientName}, User: ${n.user_id}, Send at: ${n.send_at} UTC (${delayMinutes} minutes ago)`);
      });
    }
    
    if (!notifications || notifications.length === 0) {
      console.log('process-queue-and-send: No notifications to process at this time.');
      return new Response(JSON.stringify({ message: 'No notifications to process.' }), {
        status: 200,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // 3. Invocar a funo de envio para cada notificao
    const sendPromises = notifications.map(async (notification: NotificationItem) => {
      const notifStartTime = DateTime.now().toUTC().toISO(); // Use Luxon
      console.log(`\n process-queue-and-send: Starting to process notification ID: ${notification.id}`);
      console.log(`   User: ${notification.user_id}, Started at: ${notifStartTime}`);
      
      // Atualizar status para 'processing'
      const { error: updateError } = await supabaseAdmin
        .from('scheduled_notifications')
        .update({ status: 'processing' })
        .eq('id', notification.id);

      if (updateError) {
        console.error(` process-queue-and-send: Error updating status to 'processing' for ID ${notification.id}:`, updateError.message);
        // Continuar mesmo com erro de update, para tentar invocar a funo de envio
      } else {
        console.log(` process-queue-and-send: Notification ID ${notification.id} status updated to 'processing'`);
      }
      
      // Invocar a outra Edge Function
      console.log(` process-queue-and-send: Invoking send-scheduled-notification for ID ${notification.id}...`);
      const invokeStartTime = DateTime.now(); // Use Luxon
      
      const { data: invokeData, error: invokeError } = await supabaseAdmin.functions.invoke('send-scheduled-notification', {
        body: { id: notification.id },
      });

      const invokeEndTime = DateTime.now(); // Use Luxon
      const invokeDuration = invokeEndTime.diff(invokeStartTime, 'milliseconds').milliseconds; // Luxon diff

      if (invokeError) {
        console.error(` process-queue-and-send: Error invoking send-scheduled-notification for ID ${notification.id}:`);
        console.error(`   Error message: ${invokeError.message}`);
        console.error(`   Duration: ${invokeDuration}ms`);
        // A funo send-scheduled-notification j lida com a atualizao para 'failed' e loga o erro.
      } else {
        console.log(` process-queue-and-send: Successfully invoked send-scheduled-notification for ID ${notification.id}`);
        console.log(`   Duration: ${invokeDuration}ms`);
        console.log(`   Response:`, JSON.stringify(invokeData));
      }
    });

    await Promise.all(sendPromises);
    console.log(`process-queue-and-send: Finished processing ${notifications.length} notifications.`);

    return new Response(JSON.stringify({ message: `Processed ${notifications.length} notifications.` }), {
      status: 200,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });

  } catch (err: any) {
    console.error('process-queue-and-send: Unhandled error in Edge Function:', err.message);
    return new Response(JSON.stringify({ error: err.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/renew-subscriber-subscription/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

// @ts-ignore
import { DateTime } from 'https://esm.sh/luxon@3.4.4';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: adminRoleData, error: adminRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (adminRoleError || adminRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const { subscriptionId, targetUserId, planName, currentNextBillingDate, price } = await req.json();

    if (!subscriptionId || !targetUserId || !planName || !currentNextBillingDate || price === undefined) {
      return new Response(JSON.stringify({ error: 'Missing required fields for subscription renewal.' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    // 1. Fetch subscriber plan details to get period_days
    const { data: planData, error: planError } = await supabaseAdmin
      .from('subscriber_plans')
      .select('period_days')
      .eq('name', planName)
      .single();

    if (planError || !planData) {
      console.error('Edge Function: Error fetching subscriber plan:', planError?.message || 'Plan not found');
      throw new Error(`Subscriber plan "${planName}" not found.`);
    }

    const periodDays = planData.period_days;

    // 2. Calculate new next_billing_date using Luxon
    const currentDueDate = DateTime.fromISO(currentNextBillingDate, { zone: 'local' }).startOf('day');
    const newNextBillingDate = currentDueDate.plus({ days: periodDays }).toISODate();

    // 3. Update subscription
    const { data: updatedSubscription, error: updateError } = await supabaseAdmin
      .from('subscriptions')
      .update({ next_billing_date: newNextBillingDate, status: 'active' })
      .eq('id', subscriptionId)
      .eq('user_id', targetUserId)
      .select()
      .single();

    if (updateError) throw updateError;

    // NOVO: Buscar o nome do assinante
    const { data: subscriberProfile, error: profileError } = await supabaseAdmin
      .from('profiles')
      .select('name')
      .eq('id', targetUserId)
      .single();

    const subscriberName = subscriberProfile?.name || 'Assinante Desconhecido';

    // 4. Record financial entry
    const { error: financialEntryError } = await supabaseAdmin
      .from('admin_financial_entries')
      .insert({
        admin_user_id: user.id,
        subscriber_id: targetUserId,
        description: `Renovao de Assinatura - ${planName} (${subscriberName})`, // Descrio atualizada
        value: price,
        type: 'credit',
      });

    if (financialEntryError) {
      console.error('Edge Function: Error recording financial entry:', financialEntryError.message);
      // Do not throw, as subscription update is more critical
    }

    return new Response(JSON.stringify({ success: true, data: updatedSubscription }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (error: any) {
    console.error('Edge Function: Error in renew-subscriber-subscription:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/schedule-notifications-for-rule/index.ts ---
// @ts-ignore
/// <reference lib="deno.ns" />
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Define a interface para o payload que a Edge Function espera
interface EdgeFunctionPayload {
  automationId: string;
  notifications: {
    user_id: string; // Adicionado para consistncia com o frontend
    client_id: string;
    template_id: string;
    automation_id: string;
    send_at: string; // ISO string UTC, j calculada pelo frontend
    status: 'pending'; // Sempre 'pending' ao inserir
  }[];
}

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseAdmin = createClient(
    // @ts-ignore
    Deno.env.get('SUPABASE_URL') ?? '',
    // @ts-ignore
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  let userId: string | null = null; // Para logs e RLS
  let automationIdForLog: string | null = null;

  try {
    console.log('schedule-notifications-for-rule: Function started.');

    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      console.error('schedule-notifications-for-rule: Unauthorized - Missing Authorization header.');
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    // Usar o cliente Supabase com o token do usurio para obter o user.id
    const supabaseClientForUser = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabaseClientForUser.auth.getUser();
    if (userError || !user) {
      console.error('schedule-notifications-for-rule: User authentication failed:', userError?.message);
      throw new Error(userError?.message || 'User not authenticated');
    }
    userId = user.id;
    console.log(`schedule-notifications-for-rule: Authenticated user: ${userId}`);

    const { automationId, notifications }: EdgeFunctionPayload = await req.json();
    automationIdForLog = automationId;
    console.log(`schedule-notifications-for-rule: Received request for automationId: ${automationId} with ${notifications?.length || 0} notifications.`);

    if (!automationId || !notifications) {
      console.error('schedule-notifications-for-rule: automationId and notifications array are required.');
      throw new Error('automationId and notifications array are required.');
    }

    //  POLTICA UTC: Validar que todas as datas esto em formato UTC vlido
    const nowUtc = new Date();
    for (const notification of notifications) {
      const sendAtDate = new Date(notification.send_at);
      
      // Verificar se  uma data vlida
      if (isNaN(sendAtDate.getTime())) {
        console.error(`schedule-notifications-for-rule: Invalid send_at date: ${notification.send_at}`);
        throw new Error(`Invalid send_at date for client ${notification.client_id}`);
      }
      
      // Verificar se est no futuro (com margem de 1 minuto para evitar descartes por latncia de rede)
      if (sendAtDate.getTime() < nowUtc.getTime() - 60000) {
        console.warn(`schedule-notifications-for-rule: Skipping past notification: ${notification.send_at} (now: ${nowUtc.toISOString()}) for client ${notification.client_id}`);
      }
    }
    
    console.log(`schedule-notifications-for-rule: Scheduling ${notifications.length} notifications for automation ${automationId}:`);
    notifications.forEach(n => {
      console.log(`   Client ${n.client_id}: send_at=${n.send_at} UTC`);
    });

    // 1. Delete existing pending scheduled notifications for this automation and user
    console.log(`schedule-notifications-for-rule: Attempting to delete existing pending notifications for automation ${automationId}.`);
    // Service role bypasses RLS, but we still filter by user_id to ensure data integrity.
    const { error: deleteError } = await supabaseAdmin
      .from('scheduled_notifications')
      .delete()
      .eq('automation_id', automationId)
      .eq('user_id', userId) // Garante que o usurio s delete seus prprios agendamentos
      .eq('status', 'pending');

    if (deleteError) {
      console.error(`schedule-notifications-for-rule: Failed to delete existing pending notifications: ${deleteError.message}`);
      throw new Error(`Failed to delete existing pending notifications: ${deleteError.message}`);
    }
    console.log(`schedule-notifications-for-rule: Successfully deleted existing pending notifications for automation ${automationId}.`);

    // 2. Insert new scheduled notifications
    if (notifications.length > 0) {
      // Adiciona o status 'pending' e o user_id a cada notificao antes de inserir
      const notificationsToInsert = notifications.map(n => ({
        ...n,
        user_id: userId, // Garante que o user_id est correto
        automation_id: automationId, // Garante que o automation_id est correto
        status: 'pending',
      }));

      // Service role bypasses RLS, but we still ensure user_id is set correctly.
      const { error: insertError } = await supabaseAdmin
        .from('scheduled_notifications')
        .insert(notificationsToInsert);

      if (insertError) {
        console.error(`schedule-notifications-for-rule: Failed to insert scheduled notifications: ${insertError.message}`);
        throw new Error(`Failed to insert scheduled notifications: ${insertError.message}`);
      }
      console.log(`schedule-notifications-for-rule: Successfully inserted ${notificationsToInsert.length} scheduled notifications.`);
    } else {
      console.log('schedule-notifications-for-rule: No new notifications to insert.');
    }

    return new Response(JSON.stringify({ success: true, message: 'Notifications scheduled successfully.', count: notifications.length }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });

  } catch (error: any) {
    console.error(`schedule-notifications-for-rule: An unexpected error occurred for automation ${automationIdForLog || 'N/A'}: ${error.message}`);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/schedule-subscriber-notifications/index.ts ---
// @ts-ignore
/// <reference lib="deno.ns" />
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

// @ts-ignore
import { DateTime } from 'https://esm.sh/luxon@3.4.4'; // Import Luxon for timezone handling

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Define a interface para o payload que a Edge Function espera
interface EdgeFunctionPayload {
  automationId: string;
  notifications: {
    user_id: string; // ID do assinante (user_id da tabela auth.users)
    subscriber_template_id: string;
    send_at: string; // ISO string UTC
    status: 'pending'; // Sempre 'pending' ao inserir
  }[];
}

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseAdmin = createClient(
    // @ts-ignore
    Deno.env.get('SUPABASE_URL') ?? '',
    // @ts-ignore
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  let adminUserId: string | null = null; // Para logs e RLS
  let automationIdForLog: string | null = null;

  try {
    console.log('schedule-subscriber-notifications: Function started.');

    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      console.error('schedule-subscriber-notifications: Unauthorized - Missing Authorization header.');
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    // Usar o cliente Supabase com o token do usurio para obter o user.id
    const supabaseClientForUser = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabaseClientForUser.auth.getUser();
    if (userError || !user) {
      console.error('schedule-subscriber-notifications: User authentication failed:', userError?.message);
      throw new Error(userError?.message || 'User not authenticated');
    }
    adminUserId = user.id;
    console.log(`schedule-subscriber-notifications: Authenticated admin user: ${adminUserId}`);

    // Verify admin role
    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', adminUserId)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', adminUserId);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');


    const { automationId, notifications }: EdgeFunctionPayload = await req.json();
    automationIdForLog = automationId;
    console.log(`schedule-subscriber-notifications: Received request for automationId: ${automationId} with ${notifications?.length || 0} notifications.`);

    if (!automationId || !notifications) {
      console.error('schedule-subscriber-notifications: automationId and notifications array are required.');
      throw new Error('automationId and notifications array are required.');
    }

    // Validar que todas as datas esto em formato UTC vlido
    const nowUtc = DateTime.now().toUTC();
    for (const notification of notifications) {
      const sendAtDateTime = DateTime.fromISO(notification.send_at, { zone: 'utc' });
      
      if (!sendAtDateTime.isValid) {
        console.error(`schedule-subscriber-notifications: Invalid send_at date: ${notification.send_at}`);
        throw new Error(`Invalid send_at date for subscriber ${notification.user_id}`);
      }
      
      // Adicionar margem de 1 minuto para evitar descartes por latncia de rede
      if (sendAtDateTime < nowUtc.minus({ minutes: 1 })) {
        console.warn(`schedule-subscriber-notifications: Skipping past notification: ${notification.send_at} (now: ${nowUtc.toISO()}) for subscriber ${notification.user_id}`);
      }
    }
    
    console.log(`schedule-subscriber-notifications: Scheduling ${notifications.length} notifications for subscriber automation ${automationId}:`);
    notifications.forEach(n => {
      console.log(`   Subscriber ${n.user_id}: send_at=${n.send_at} UTC`);
    });

    // 1. Delete existing pending scheduled notifications for this automation and type
    console.log(`schedule-subscriber-notifications: Attempting to delete existing pending subscriber notifications for automation ${automationId}.`);
    const { error: deleteError } = await supabaseAdmin
      .from('scheduled_notifications')
      .delete()
      .eq('automation_id', automationId)
      .eq('type', 'subscriber_notification') // Filter by the new type
      .eq('user_id', adminUserId) // Ensure admin only deletes their own subscriber automations
      .eq('status', 'pending');

    if (deleteError) {
      console.error(`schedule-subscriber-notifications: Failed to delete existing pending notifications: ${deleteError.message}`);
      throw new Error(`Failed to delete existing pending notifications: ${deleteError.message}`);
    }
    console.log(`schedule-subscriber-notifications: Successfully deleted existing pending subscriber notifications for automation ${automationId}.`);

    // 2. Insert new scheduled notifications
    if (notifications.length > 0) {
      const notificationsToInsert = notifications.map(n => ({
        user_id: n.user_id, // This is the subscriber's user_id
        client_id: n.user_id, // For subscriber notifications, client_id is the subscriber's user_id
        template_id: n.subscriber_template_id,
        automation_id: automationId,
        send_at: n.send_at,
        status: 'pending',
        type: 'subscriber_notification', // Set the new type
      }));

      const { error: insertError } = await supabaseAdmin
        .from('scheduled_notifications')
        .insert(notificationsToInsert);

      if (insertError) {
        console.error(`schedule-subscriber-notifications: Failed to insert scheduled notifications: ${insertError.message}`);
        throw new Error(`Failed to insert scheduled notifications: ${insertError.message}`);
      }
      console.log(`schedule-subscriber-notifications: Successfully inserted ${notificationsToInsert.length} scheduled notifications.`);
    } else {
      console.log('schedule-subscriber-notifications: No new notifications to insert.');
    }

    return new Response(JSON.stringify({ success: true, message: 'Subscriber notifications scheduled successfully.', count: notifications.length }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });

  } catch (error: any) {
    console.error(`schedule-subscriber-notifications: An unexpected error occurred for automation ${automationIdForLog || 'N/A'}: ${error.message}`);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/send-scheduled-notification/index.ts ---
// @ts-ignore
/// <reference lib="deno.ns" />
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseAdmin = createClient(
    // @ts-ignore
    Deno.env.get('SUPABASE_URL') ?? '',
    // @ts-ignore
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  let scheduledNotificationId: string | null = null;
  let userId: string | null = null;
  let clientId: string | null = null;
  let templateId: string | null = null;
  let n8nWebhookUrl: string | null = null;
  let statusCode: number | null = null;
  let errorMessage: string = 'An unknown error occurred.';
  let requestBody: any = {};
  let responseBody: any = null;
  let clientNameForLog: string = 'Unknown Client';
  let instanceName: string | null = null; // Varivel para armazenar o instanceName

  try {
    const currentTimeStart = new Date().toISOString();
    console.log(`send-scheduled-notification: Function started at ${currentTimeStart}`);
    const { id } = await req.json();
    scheduledNotificationId = id;
    console.log(`send-scheduled-notification: Received request for scheduledNotificationId: ${scheduledNotificationId}`);

    if (!scheduledNotificationId) {
      errorMessage = 'Scheduled notification ID is required.';
      console.error(`send-scheduled-notification: ${errorMessage}`);
      throw new Error(errorMessage);
    }

    // Fetch scheduled notification details
    // Service role bypasses RLS, so no explicit user_id filter needed here.
    const { data: notification, error: notificationError } = await supabaseAdmin
      .from('scheduled_notifications')
      .select(`
        user_id,
        client_id,
        template_id,
        clients(name, phone, value, next_billing_date, plans(name)),
        templates(name, content)
      `)
      .eq('id', scheduledNotificationId)
      .single();

    if (notificationError || !notification) {
      errorMessage = `Failed to fetch scheduled notification: ${notificationError?.message || 'Not found'}`;
      console.error(`send-scheduled-notification: ${errorMessage}`);
      throw new Error(errorMessage);
    }

    userId = notification.user_id;
    clientId = notification.client_id;
    templateId = notification.template_id;
    const client = Array.isArray(notification.clients) ? notification.clients[0] : notification.clients;
    const template = Array.isArray(notification.templates) ? notification.templates[0] : notification.templates;

    if (!client) {
      errorMessage = 'Client not found for scheduled notification.';
      console.error(`send-scheduled-notification: ${errorMessage}`);
      throw new Error(errorMessage);
    }
    if (!template) {
      errorMessage = 'Template not found for scheduled notification.';
      console.error(`send-scheduled-notification: ${errorMessage}`);
      throw new Error(errorMessage);
    }

    clientNameForLog = client.name;
    const scheduledFor = notification.send_at || 'unknown';
    const delayFromScheduled = new Date().getTime() - new Date(scheduledFor).getTime();
    const delayMinutes = Math.round(delayFromScheduled / 60000);
    console.log(`send-scheduled-notification: Processing notification ID ${scheduledNotificationId}`);
    console.log(`   Client: ${clientNameForLog}`);
    console.log(`   Template: ${template.name}`);
    console.log(`   Scheduled for: ${scheduledFor} UTC`);
    console.log(`   Delay: ${delayMinutes} minutes`);

    // --- NOVO: Buscar o instanceName do usurio ---
    // Service role bypasses RLS, so no explicit user_id filter needed here.
    const { data: userInstance, error: instanceError } = await supabaseAdmin
      .from('user_instances')
      .select('instance_name')
      .eq('user_id', userId)
      .single();

    if (instanceError || !userInstance?.instance_name) {
      errorMessage = `User ${userId} does not have an active instance configured. Skipping notification.`;
      console.error(`send-scheduled-notification: ${errorMessage}`);
      // No lanar erro aqui, mas atualizar o status da notificao para 'failed' e logar.
      // O bloco finally cuidar do log e da atualizao de status.
      statusCode = 412; // Precondition Failed, ou um cdigo customizado para "instncia no configurada"
      throw new Error(errorMessage); // Lana para ir para o bloco finally
    }
    instanceName = userInstance.instance_name;
    console.log(`send-scheduled-notification: Instance Name for user ${userId}: ${instanceName}`);

    // Fetch n8n webhook URL (global config, no user_id filter needed)
    const { data: webhookConfig, error: webhookError } = await supabaseAdmin
      .from('webhook_configs')
      .select('url')
      .eq('type', 'n8n_message_sender')
      .maybeSingle();

    if (webhookError || !webhookConfig?.url) {
      errorMessage = `N8N message sender webhook URL not configured. Configure in Webhooks page.`;
      console.error(`send-scheduled-notification: ${errorMessage}`);
      throw new Error(errorMessage);
    }
    n8nWebhookUrl = webhookConfig.url;
    console.log(`send-scheduled-notification: N8N Webhook URL: ${n8nWebhookUrl}`);

    // --- NOVO: Buscar a chave PIX do perfil do usurio ---
    const { data: userProfile, error: profileError } = await supabaseAdmin
      .from('profiles')
      .select('pix_key')
      .eq('id', userId)
      .single();

    if (profileError && profileError.code !== 'PGRST116') { // PGRST116 = No rows found
      console.error(`send-scheduled-notification: Error fetching user profile for pix_key: ${profileError.message}`);
    }
    const pixKey = userProfile?.pix_key || 'Chave PIX no cadastrada';
    console.log(`send-scheduled-notification: User PIX Key: ${pixKey}`);

    // Variable substitution
    let renderedText = template.content;
    renderedText = renderedText.replaceAll('{{customer_name}}', client.name);
    
    //  POLTICA UTC: next_billing_date j est no formato YYYY-MM-DD (data local sem timezone)
    // No precisa converter timezone, apenas formatar para pt-BR
    const dueDate = new Date(client.next_billing_date + 'T00:00:00');
    const formattedDate = dueDate.toLocaleDateString('pt-BR', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric'
    });
    renderedText = renderedText.replaceAll('{{due_date}}', formattedDate);
    
    const planData = Array.isArray(client.plans) ? client.plans[0] : client.plans;
    renderedText = renderedText.replaceAll('{{plan_name}}', planData?.name || 'Plano Desconhecido');
    renderedText = renderedText.replaceAll('{{value}}', new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(client.value));
    renderedText = renderedText.replaceAll('{{pix_key}}', pixKey); // --- NOVO: Substituio da chave PIX ---
    console.log(`send-scheduled-notification: Rendered message: ${renderedText}`);

    requestBody = {
      body: [
        {
          instanceName: instanceName, // --- NOVO: Adicionado o instanceName aqui ---
          contact_name: client.name,
          number: client.phone, // Assumindo que o formato j  adequado para WhatsApp
          text: renderedText,
          mode: "real"
        }
      ]
    };
    console.log(`send-scheduled-notification: Sending payload to n8n: ${JSON.stringify(requestBody)}`);

    // Send message via n8n webhook
    if (!n8nWebhookUrl) {
      errorMessage = 'N8N webhook URL is null or undefined before fetch.';
      console.error(`send-scheduled-notification: ${errorMessage}`);
      throw new Error(errorMessage);
    }
    const response = await fetch(n8nWebhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody),
    });

    statusCode = response.status;
    console.log(`send-scheduled-notification: N8N Webhook response status: ${statusCode}`);

    // Tenta ler o corpo da resposta, seja sucesso ou erro
    try {
      responseBody = await response.json();
    } catch (jsonError) {
      // Se no for JSON, tenta ler como texto
      responseBody = await response.text();
      console.warn(`send-scheduled-notification: N8N response was not JSON, read as text. Error: ${jsonError}`);
    }
    console.log(`send-scheduled-notification: N8N Webhook response body: ${JSON.stringify(responseBody)}`);


    if (!response.ok) {
      errorMessage = String(responseBody?.message || response.statusText || `Automation server returned an error with status ${statusCode}.`);
      console.error(`send-scheduled-notification: N8N Webhook error response: ${JSON.stringify(responseBody)}`);
      throw new Error(errorMessage);
    }

    // Update scheduled notification status to 'sent'
    const { error: updateSentError } = await supabaseAdmin
      .from('scheduled_notifications')
      .update({ status: 'sent' })
      .eq('id', scheduledNotificationId);
    
    if (updateSentError) {
      console.error(`send-scheduled-notification: Error updating status to 'sent': ${updateSentError.message}`);
    } else {
      console.log(`send-scheduled-notification:  Notification ${scheduledNotificationId} marked as 'sent' successfully`);
    }

    // Log to n8n_message_sender_history (NOVA TABELA)
    const { error: historyInsertError } = await supabaseAdmin
      .from('n8n_message_sender_history') // Alterado para a nova tabela
      .insert({
        user_id: userId,
        client_id: clientId,
        template_id: templateId,
        webhook_type: 'n8n_message_outbound_automated',
        payload: requestBody,
        request_payload: requestBody,
        response_payload: responseBody,
        status_code: statusCode,
        client_name_snapshot: clientNameForLog, // Save client name snapshot
      });
    
    if (historyInsertError) {
      console.error(`send-scheduled-notification: Error logging to n8n_message_sender_history: ${historyInsertError.message}`);
    } else {
      console.log(`send-scheduled-notification:  Logged to n8n_message_sender_history for ${scheduledNotificationId}`);
    }

    return new Response(JSON.stringify({ success: true, message: 'Notification sent successfully.' }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });

  } catch (error: any) {
    console.error(`send-scheduled-notification: Error processing notification ${scheduledNotificationId} for client ${clientNameForLog}: ${error.message}`);
    errorMessage = String(error.message);

    // Update scheduled notification status to 'failed'
    if (scheduledNotificationId) {
      await supabaseAdmin
        .from('scheduled_notifications')
        .update({ status: 'failed' })
        .eq('id', scheduledNotificationId);
      console.log(`send-scheduled-notification: Scheduled notification ${scheduledNotificationId} status updated to 'failed'.`);
    }

    // Log error to n8n_message_sender_history (NOVA TABELA)
    if (userId) {
      await supabaseAdmin
        .from('n8n_message_sender_history') // Alterado para a nova tabela
        .insert({
          user_id: userId,
          client_id: clientId,
          template_id: templateId,
          webhook_type: 'n8n_message_outbound_automated',
          payload: requestBody,
          request_payload: requestBody,
          response_payload: responseBody,
          status_code: statusCode || 500,
          client_name_snapshot: clientNameForLog, // Save client name snapshot even on error
        });
      console.log(`send-scheduled-notification: Logged error to n8n_message_sender_history for ${scheduledNotificationId}.`);
    }

    return new Response(JSON.stringify({ error: errorMessage || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/set-subscriber-due-today/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

// @ts-ignore
import { DateTime } from 'https://esm.sh/luxon@3.4.4';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: adminRoleData, error: adminRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (adminRoleError || adminRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const { subscriptionId, targetUserId, currentStatus, price } = await req.json();

    if (!subscriptionId || !targetUserId || !currentStatus || price === undefined) {
      return new Response(JSON.stringify({ error: 'Missing required fields for setting due date to today.' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    // 1. Calculate today's date in YYYY-MM-DD format (local)
    const todayDate = DateTime.local().toISODate();

    // 2. Determine new status
    const newStatus = currentStatus === 'inactive' ? 'active' : currentStatus;

    // 3. Update subscription
    const { data: updatedSubscription, error: updateError } = await supabaseAdmin
      .from('subscriptions')
      .update({ next_billing_date: todayDate, status: newStatus })
      .eq('id', subscriptionId)
      .eq('user_id', targetUserId)
      .select()
      .single();

    if (updateError) throw updateError;

    // 4. Record financial entry (optional, but good for tracking)
    // REMOVIDO: A criao de entrada financeira para "Vencimento para Hoje"
    // const { error: financialEntryError } = await supabaseAdmin
    //   .from('admin_financial_entries')
    //   .insert({
    //     admin_user_id: user.id,
    //     subscriber_id: targetUserId,
    //     description: `Vencimento para Hoje - Assinatura`,
    //     value: price, // Assuming this is a payment received
    //     type: 'credit',
    //   });

    // if (financialEntryError) {
    //   console.error('Edge Function: Error recording financial entry:', financialEntryError.message);
    //   // Do not throw, as subscription update is more critical
    // }

    return new Response(JSON.stringify({ success: true, data: updatedSubscription }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (error: any) {
    console.error('Edge Function: Error in set-subscriber-due-today:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/update-user-role/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: adminRoleData, error: adminRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (adminRoleError || adminRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const { targetUserId, newRole } = await req.json();

    if (!targetUserId || !newRole) {
      return new Response(JSON.stringify({ error: 'Missing targetUserId or newRole.' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    // Update or insert the user's role
    const { data, error } = await supabaseAdmin
      .from('user_roles')
      .upsert({ user_id: targetUserId, role: newRole }, { onConflict: 'user_id' })
      .select()
      .single();

    if (error) throw error;

    return new Response(JSON.stringify({ success: true, data }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (error: any) {
    console.error('Edge Function: Error in update-user-role:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: supabase/functions/update-user-subscription/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: adminRoleData, error: adminRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (adminRoleError || adminRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const { subscriptionId, userId: targetUserId, plan_name, price, status, next_billing_date } = await req.json();

    if (!subscriptionId || !targetUserId || !plan_name || !price || !status || !next_billing_date) {
      return new Response(JSON.stringify({ error: 'Missing required fields for subscription update.' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    const { data, error } = await supabaseAdmin
      .from('subscriptions')
      .update({ plan_name, price, status, next_billing_date })
      .eq('id', subscriptionId)
      .eq('user_id', targetUserId) // Ensure we update the correct user's subscription
      .select()
      .single();

    if (error) throw error;

    return new Response(JSON.stringify({ success: true, data }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (error: any) {
    console.error('Edge Function: Error in update-user-subscription:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- Contedo de: src/pages/Auth.tsx ---
import { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { supabase } from "@/integrations/supabase/client";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { toast } from "sonner";
import { z } from "zod";

const authSchema = z.object({
  email: z.string().email("E-mail invlido"),
  password: z.string().min(6, "Senha deve ter no mnimo 6 caracteres"),
  name: z.string().min(2, "Nome deve ter no mnimo 2 caracteres").optional(),
});

export default function Auth() {
  const navigate = useNavigate();
  const [loading, setLoading] = useState(false);
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [name, setName] = useState("");

  useEffect(() => {
    const checkSession = async () => {
      const { data: { session } } = await supabase.auth.getSession();
      if (session) {
        navigate("/dashboard");
      }
    };

    checkSession();

    const { data: { subscription } } = supabase.auth.onAuthStateChange((_, session) => {
      if (session) {
        navigate("/dashboard");
      }
    });

    return () => subscription.unsubscribe();
  }, [navigate]);

  const handleSignIn = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      authSchema.omit({ name: true }).parse({ email, password });

      const { error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });

      if (error) throw error;

      toast.success("Login realizado com sucesso!", { description: "Voc ser redirecionado..." });
    } catch (error: any) {
      if (error instanceof z.ZodError) {
        toast.error("Erro de validao", { description: error.errors[0].message });
      } else {
        toast.error("Erro ao fazer login", { description: error.message });
      }
    } finally {
      setLoading(false);
    }
  };

  const handleSignUp = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      authSchema.parse({ email, password, name });

      const { error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          emailRedirectTo: `${window.location.origin}/dashboard`,
          data: {
            name,
          },
        },
      });

      if (error) throw error;

      toast.success("Cadastro realizado!", { description: "Voc j pode fazer login." });
    } catch (error: any) {
      if (error instanceof z.ZodError) {
        toast.error("Erro de validao", { description: error.errors[0].message });
      } else {
        toast.error("Erro ao criar conta", { description: error.message });
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center p-4">
      <div className="w-full max-w-md">
        <div className="text-center mb-8">
          <div className="inline-flex items-center justify-center w-16 h-16 rounded-2xl bg-gradient-to-br from-primary to-primary-glow mb-4 shadow-glow">
            <span className="text-2xl font-bold text-primary-foreground">AC</span>
          </div>
          <h1 className="text-3xl font-bold text-foreground">Acerto Certo</h1>
          <p className="text-muted-foreground mt-2">Sistema de Cobrana e Gerenciamento</p>
        </div>

        <Card className="border-border bg-card shadow-lg">
          <CardHeader>
            <CardTitle>Bem-vindo</CardTitle>
            <CardDescription>Entre ou crie sua conta para continuar</CardDescription>
          </CardHeader>
          <CardContent>
            <Tabs defaultValue="signin" className="w-full">
              <TabsList className="grid w-full grid-cols-2 mb-4">
                <TabsTrigger value="signin">Entrar</TabsTrigger>
                <TabsTrigger value="signup">Cadastrar</TabsTrigger>
              </TabsList>

              <TabsContent value="signin">
                <form onSubmit={handleSignIn} className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="signin-email">E-mail</Label>
                    <Input
                      id="signin-email"
                      type="email"
                      placeholder="seu@email.com"
                      value={email}
                      onChange={(e) => setEmail(e.target.value)}
                      required
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="signin-password">Senha</Label>
                    <Input
                      id="signin-password"
                      type="password"
                      placeholder=""
                      value={password}
                      onChange={(e) => setPassword(e.target.value)}
                      required
                    />
                  </div>
                  <Button type="submit" className="w-full" disabled={loading}>
                    {loading ? "Entrando..." : "Entrar"}
                  </Button>
                </form>
              </TabsContent>

              <TabsContent value="signup">
                <form onSubmit={handleSignUp} className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="signup-name">Nome</Label>
                    <Input
                      id="signup-name"
                      type="text"
                      placeholder="Seu nome"
                      value={name}
                      onChange={(e) => setName(e.target.value)}
                      required
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="signup-email">E-mail</Label>
                    <Input
                      id="signup-email"
                      type="email"
                      placeholder="seu@email.com"
                      value={email}
                      onChange={(e) => setEmail(e.target.value)}
                      required
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="signup-password">Senha</Label>
                    <Input
                      id="signup-password"
                      type="password"
                      placeholder=""
                      value={password}
                      onChange={(e) => setPassword(e.target.value)}
                      required
                    />
                  </div>
                  <Button type="submit" className="w-full" disabled={loading}>
                    {loading ? "Criando conta..." : "Criar conta"}
                  </Button>
                </form>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
--- Contedo de: src/pages/Automations.tsx ---
import { DateTime } from 'luxon'; // Import Luxon's DateTime

import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Table, TableBody, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { ConfigureClientsModal } from '@/components/automations/ConfigureClients/ConfigureClientsModal';
import { AutomationRow } from '@/components/automations/AutomationRow'; // Corrigido: sintaxe de importao
import { useTemplates } from '@/hooks/useTemplates'; // Importar Template do hook useTemplates
import { useClients } from '@/hooks/useClients'; // Corrigido: destruturar clientsError
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { Automation, AutomationInsert, AutomationUpdate, Client } from '@/integrations/supabase/schema'; // Importar tipos do schema
import { toast } from 'sonner';
import { PlusCircle as PlusCircleIcon, Loader2 } from 'lucide-react';
import { useEffect, useState } from 'react';
import { useAuth } from '@/contexts/AuthContext'; // Import useAuth

// --- HOOKS DE DADOS REAIS ---

// Fetch Automations
const fetchAutomations = async (userId: string, userRole: string | null): Promise<Automation[]> => {
  let query = supabase
    .from('automations')
    .select('*')
    .order('created_at', { ascending: true });

  // Aplica o filtro APENAS se o usurio NO for admin
  if (userRole !== 'admin') {
    query = query.eq('user_id', userId);
  }

  const { data, error } = await query;

  if (error) throw new Error(error.message);
  return data || [];
};

export const useAutomations = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth(); // Get user and role from AuthContext

  return useQuery<Automation[], Error>({
    queryKey: ['automations', user?.id, role], // Add role to query key
    queryFn: () => {
      if (!user?.id) throw new Error("Usurio no autenticado");
      return fetchAutomations(user.id, role);
    },
    enabled: !isLoadingAuth && !!user?.id, // Only enable if auth is loaded and user is present
  });
};

// Interface para o payload que a Edge Function espera
interface EdgeFunctionNotificationPayload {
  client_id: string;
  template_id: string;
  send_at: string; // ISO string UTC
}

// Interface para o payload da mutao no frontend
interface ScheduleNotificationsForRuleMutationPayload {
  automation: Automation;
  clients: Client[];
}

const scheduleNotificationsForRule = async (payload: ScheduleNotificationsForRuleMutationPayload) => {
  const { automation, clients } = payload;
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const notificationsToInsert: EdgeFunctionNotificationPayload[] = [];
  const SAO_PAULO_TIMEZONE = 'America/Sao_Paulo';
  const [scheduledHour, scheduledMinute] = automation.scheduled_time.split(':').map(Number);
  const now = DateTime.now(); // Usar Luxon para o tempo atual

  // Filtra apenas clientes ativos ou vencidos que esto na automao
  const relevantClients = clients.filter(c => 
    automation.client_ids.includes(c.id) && (c.status === 'active' || c.status === 'overdue')
  );

  for (const client of relevantClients) {
    if (!client.next_billing_date) continue;

    // A data do Supabase vem como 'YYYY-MM-DD'. Adicionar T00:00:00 para tratar como data local.
    const localBillingDate = DateTime.fromISO(client.next_billing_date, { zone: SAO_PAULO_TIMEZONE }).startOf('day');
    const targetDate = localBillingDate.plus({ days: automation.days_offset });
    
    // Cria a data/hora final no fuso horrio local (So Paulo) usando Luxon
    const localTargetDateTime = targetDate.set({
        hour: scheduledHour,
        minute: scheduledMinute
    });

    // Converte para UTC e obtm a string ISO
    const sendAtUtcIso = localTargetDateTime.toUTC().toISO();

    // Adicionar verificao para sendAtUtcIso ser null
    if (!sendAtUtcIso) {
        console.warn(`Skipping notification for client ${client.id} due to invalid date/time conversion.`);
        continue; // Pula este cliente se a data for invlida
    }

    // Adiciona  lista se a data for no futuro (ou no mximo 1 minuto no passado para tolerncia)
    if (localTargetDateTime.toMillis() >= now.toMillis() - (60 * 1000)) {
        notificationsToInsert.push({
            client_id: client.id,
            template_id: automation.template_id,
            send_at: sendAtUtcIso, // Envia a string ISO UTC gerada pelo Luxon
        });
    }
  }
  
  // Se no houver nada a agendar, no chama a funo da Edge Function
  if (notificationsToInsert.length === 0) {
      console.log("Nenhuma notificao futura para agendar para esta regra.");
      return { success: true, message: 'Nenhuma notificao futura para agendar.' };
  }

  // A URL da Edge Function
  const SUPABASE_PROJECT_ID = "cgqyfpsfymhntumrmbzj";
  const EDGE_FUNCTION_NAME = "schedule-notifications-for-rule";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  // O body da requisio agora envia os agendamentos prontos
  const response = await fetch(EDGE_FUNCTION_URL, {
      method: "POST",
      headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${session.access_token}`,
      },
      body: JSON.stringify({ automationId: automation.id, notifications: notificationsToInsert }),
  });

  if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || "Erro ao invocar a Edge Function.");
  }

  return response.json();
};

export const useScheduleNotificationsForRule = () => {
  const queryClient = useQueryClient();
  return useMutation<any, Error, ScheduleNotificationsForRuleMutationPayload>({
    mutationFn: scheduleNotificationsForRule,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['scheduledNotifications'] });
      queryClient.invalidateQueries({ queryKey: ['connectionMetrics'] }); // Invalida mtricas para atualizar contagem de agendados
      toast.success('Fila de envios agendada com sucesso!');
    },
    onError: (error) => toast.error(`Erro ao agendar fila de envios: ${error.message}`),
  });
};

// Create Automation
export const useCreateAutomation = () => {
  const queryClient = useQueryClient();
  const scheduleMutation = useScheduleNotificationsForRule();
  const { data: clients } = useClients(); // Obter clientes para calcular notificaes

  return useMutation<Automation, Error, AutomationInsert>({
    mutationFn: async (newAutomationData) => {
      const { data: { user } = {} } = await supabase.auth.getUser(); // Destructure with default empty object
      if (!user) throw new Error("Usurio no autenticado");

      const { data, error } = await supabase
        .from('automations')
        .insert({ ...newAutomationData, user_id: user.id })
        .select()
        .single();

      if (error) throw new Error(error.message);
      return data as Automation;
    },
    onSuccess: async (newAutomation) => {
      queryClient.invalidateQueries({ queryKey: ['automations'] });
      queryClient.invalidateQueries({ queryKey: ['connectionMetrics'] });
      toast.success('Automao criada!');

      // Calcular e agendar notificaes
      if (clients) {
        await scheduleMutation.mutateAsync({ 
          automation: newAutomation, 
          clients: clients 
        });
      }
    },
    onError: (error) => toast.error(`Erro ao criar automao: ${error.message}`),
  });
};

// Update Automation
export const useUpdateAutomation = () => {
  const queryClient = useQueryClient();
  const scheduleMutation = useScheduleNotificationsForRule();
  const { data: clients } = useClients(); // Obter clientes para calcular notificaes

  return useMutation<Automation, Error, AutomationUpdate & { id: string }>({
    mutationFn: async (updatedAutomationData) => {
      const { id, ...updateData } = updatedAutomationData;
      const { data: { user } = {} } = await supabase.auth.getUser(); // Destructure with default empty object
      if (!user) throw new Error("Usurio no autenticado");

      const { data, error } = await supabase
        .from('automations')
        .update(updateData)
        .eq('id', id)
        .eq('user_id', user.id)
        .select()
        .single();

      if (error) throw new Error(error.message);
      return data as Automation;
    },
    onSuccess: async (updatedAutomation) => {
      queryClient.invalidateQueries({ queryKey: ['automations'] });
      queryClient.invalidateQueries({ queryKey: ['connectionMetrics'] });
      toast.success('Automao atualizada!');

      // Calcular e agendar notificaes
      if (clients) {
        await scheduleMutation.mutateAsync({ 
          automation: updatedAutomation, 
          clients: clients 
        });
      }
    },
    onError: (error) => toast.error(`Erro ao atualizar automao: ${error.message}`),
  });
};

// Delete Automation
const deleteAutomation = async (id: string): Promise<void> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("Usurio no autenticado");

  // Deleta agendamentos pendentes associados a esta automao
  await supabase
    .from('scheduled_notifications')
    .delete()
    .eq('automation_id', id)
    .eq('user_id', user.id);

  const { error } = await supabase
    .from('automations')
    .delete()
    .eq('id', id)
    .eq('user_id', user.id);

  if (error) throw new Error(error.message);
};

export const useDeleteAutomation = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string>({
    mutationFn: deleteAutomation,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['automations'] });
      queryClient.invalidateQueries({ queryKey: ['connectionMetrics'] });
      queryClient.invalidateQueries({ queryKey: ['scheduledNotifications'] });
      toast.success('Automao excluda e agendamentos removidos!');
    },
    onError: (error) => toast.error(`Erro ao excluir automao: ${error.message}`),
  });
};

export default function AutomationsPage() {
  const { data: automations, isLoading: isLoadingAutomations, error: automationsError } = useAutomations();
  const { data: templates, isLoading: isLoadingTemplates, error: templatesError } = useTemplates();
  const { data: clients, isLoading: isLoadingClients, error: clientsError } = useClients(); // Corrigido: destruturar clientsError

  const createAutomationMutation = useCreateAutomation();
  const updateAutomationMutation = useUpdateAutomation();
  const deleteAutomationMutation = useDeleteAutomation();

  const [modalAutomation, setModalAutomation] = useState<Automation | null>(null);

  useEffect(() => {
    if (automationsError) toast.error(`Erro ao carregar automaes: ${automationsError.message}`);
    if (templatesError) toast.error(`Erro ao carregar templates: ${templatesError.message}`);
    if (clientsError) toast.error(`Erro ao carregar clientes: ${clientsError.message}`);
  }, [automationsError, templatesError, clientsError]);

  const handleAddAutomation = async () => {
    if (!templates || templates.length === 0) {
      toast.error(" necessrio ter pelo menos um template cadastrado para criar uma automao.");
      return;
    }
    if (!clients || clients.length === 0) {
      toast.error(" necessrio ter pelo menos um cliente cadastrado para criar uma automao.");
      return;
    }

    try {
      const { data: { user } = {} } = await supabase.auth.getUser(); // Destructure with default empty object
      if (!user) throw new Error("Usurio no autenticado");

      await createAutomationMutation.mutateAsync({
        days_offset: -1,
        template_id: templates[0].id, // Acessar com segurana
        client_ids: clients.filter((c: Client) => c.status === 'active').map((c: Client) => c.id),
        scheduled_time: '09:00:00',
        user_id: user.id, // Adicionar user_id aqui
      });
    } catch (error) {
      // Erro j tratado no onSuccess/onError do hook
    }
  };

  const handleSaveClients = (automationId: string, clientIds: string[]) => {
    updateAutomationMutation.mutate({ id: automationId, client_ids: clientIds });
  };

  const isLoadingPage = isLoadingAutomations || isLoadingTemplates || isLoadingClients;

  return (
    <div className="bg-background min-h-screen p-4 sm:p-6 lg:p-8">
      <div className="max-w-7xl mx-auto">
        <header className="mb-8">
          <div className="flex justify-between items-center">
            <div>
              <h1 className="text-3xl font-bold text-foreground">Automaes de Envio</h1>
              <p className="text-muted-foreground mt-1">Configure regras para enviar mensagens automaticamente.</p>
            </div>
            <Button onClick={handleAddAutomation} disabled={isLoadingPage || createAutomationMutation.isPending}>
              <PlusCircleIcon className="h-4 w-4 mr-2" />
              Nova Regra
            </Button>
          </div>
        </header>

        <Card className="border-border bg-card shadow-lg">
          <CardContent className="p-0">
            {isLoadingPage ? (
              <div className="h-64 flex items-center justify-center">
                <Loader2 className="h-8 w-8 animate-spin text-primary" />
                <p className="text-muted-foreground ml-2">Carregando automaes...</p>
              </div>
            ) : (automations || []).length === 0 ? (
              <div className="flex flex-col items-center justify-center py-12 text-muted-foreground">
                Nenhuma automao configurada. Crie sua primeira regra!
              </div>
            ) : (
              <div className="overflow-x-auto">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>Quando Enviar</TableHead>
                      <TableHead>Horrio</TableHead>
                      <TableHead>Template da Mensagem</TableHead>
                      <TableHead>Clientes Configurados</TableHead>
                      <TableHead className="w-[50px]">Aes</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {(automations || []).map((automation: Automation) => (
                      <AutomationRow
                        key={automation.id}
                        automation={automation}
                        templates={templates || []} // Passar como array vazio se undefined
                        clients={clients || []} // Passar como array vazio se undefined
                        isLoadingTemplates={isLoadingTemplates}
                        isLoadingClients={isLoadingClients}
                        updateAutomationMutation={updateAutomationMutation}
                        deleteAutomationMutation={deleteAutomationMutation}
                        onOpenClientConfig={setModalAutomation}
                      />
                    ))}
                  </TableBody>
                </Table>
              </div>
            )}
          </CardContent>
        </Card>

        {modalAutomation && (
          <ConfigureClientsModal
            automation={modalAutomation}
            onClose={() => setModalAutomation(null)}
            onSave={handleSaveClients}
          />
        )}
      </div>
    </div>
  );
}
--- Contedo de: src/pages/Clients.tsx ---
import { useEffect, useState } from "react";
import { supabase } from "@/integrations/supabase/client";
import { Button } from "@/components/ui/button";
import { Plus, Search, MoreHorizontal, Pencil, Trash2, ArrowUpDown, RefreshCw, Bell, Check, ListChecks, CalendarCheck } from "lucide-react";
import { Input } from "@/components/ui/input";
import { toast } from "sonner";
import { Badge } from "@/components/ui/badge";
import { ClientDialog } from "@/components/clients/ClientDialog";
import { NotificationDialog } from "@/components/clients/NotificationDialog";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
} from "@/components/ui/dropdown-menu";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { ClientStatus } from "@/integrations/supabase/schema"; // Importar ClientStatus do schema
import { Client, useClients, useDeleteClient, useRenewClient, useUpdateClientStatus, useSetClientDueToday } from "@/hooks/useClients"; // Corrigido: Importar Client do hook useClients
import { format } from "date-fns"; // Importar format para exibio

type SortField = "name" | "due_date";
type SortOrder = "asc" | "desc";

export default function Clients() {
  const { data: clients, isLoading, error } = useClients();
  const deleteClientMutation = useDeleteClient();
  const renewClientMutation = useRenewClient();
  const updateClientStatusMutation = useUpdateClientStatus();
  const setClientDueTodayMutation = useSetClientDueToday();

  const [searchTerm, setSearchTerm] = useState("");
  const [statusFilter, setStatusFilter] = useState<string>("all");
  const [sortField, setSortField] = useState<SortField>("due_date");
  const [sortOrder, setSortOrder] = useState<SortOrder>("asc");
  const [dialogOpen, setDialogOpen] = useState(false);
  const [selectedClient, setSelectedClient] = useState<Client | null>(null);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [clientToDelete, setClientToDelete] = useState<Client | null>(null);
  const [notificationDialogOpen, setNotificationDialogOpen] = useState(false);
  const [clientToNotify, setClientToNotify] = useState<Client | null>(null);
  const [dueTodayDialogOpen, setDueTodayDialogOpen] = useState(false);
  const [clientToDueToday, setClientToDueToday] = useState<Client | null>(null);

  useEffect(() => {
    if (error) {
      toast.error("Erro ao carregar clientes", { description: error.message });
    }
  }, [error]);

  const filteredAndSortedClients = (clients || [])
    .filter((client) => {
      const matchesSearch =
        client.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        client.phone.includes(searchTerm);
      const matchesStatus = statusFilter === "all" || client.status === statusFilter;
      return matchesSearch && matchesStatus;
    })
    .sort((a, b) => {
      const multiplier = sortOrder === "asc" ? 1 : -1;
      if (sortField === "name") {
        return multiplier * a.name.localeCompare(b.name);
      }
      return multiplier * (new Date(a.next_billing_date).getTime() - new Date(b.next_billing_date).getTime());
    });

  const getStatusBadge = (status: string) => {
    const variants: Record<string, { label: string; variant: "default" | "secondary" | "destructive" }> = {
      active: { label: "Em dia", variant: "default" },
      inactive: { label: "Cancelado", variant: "secondary" },
      overdue: { label: "Atrasado", variant: "destructive" },
    };
    const config = variants[status] || variants.active;
    return <Badge variant={config.variant}>{config.label}</Badge>;
  };

  const handleRenewClient = async (client: Client) => {
    if (!client.plan_id) {
      toast.error("Erro ao renovar cliente", { description: "Cliente no possui plano associado." });
      return;
    }

    try {
      const { data: planData, error: planError } = await supabase
        .from("plans")
        .select("period_days")
        .eq("id", client.plan_id)
        .single();

      if (planError) throw planError;
      if (!planData) throw new Error("Plano associado no encontrado.");

      await renewClientMutation.mutateAsync({
        clientId: client.id,
        planPeriodDays: planData.period_days,
        currentNextBillingDate: client.next_billing_date,
        clientName: client.name,
        clientValue: client.value,
      });

      toast.success("Cliente renovado!", { description: `O cliente ${client.name} foi renovado com sucesso.` });
    } catch (error: any) {
      toast.error("Erro ao renovar cliente", { description: error.message });
    }
  };

  const handleChangeStatus = async (client: Client, newStatus: ClientStatus) => {
    try {
      await updateClientStatusMutation.mutateAsync({
        clientId: client.id,
        newStatus,
        clientName: client.name,
        planId: client.plan_id || '', // Garante que planId no  nulo
        planName: client.planDetailsValue ? `Plano de R$${client.planDetailsValue.toFixed(2)}` : 'Plano Desconhecido', // Placeholder ou buscar nome do plano
        clientValue: client.value,
      });

      toast.success("Status atualizado!", { description: "O status do cliente foi alterado com sucesso." });
    } catch (error: any) {
      toast.error("Erro ao mudar status", { description: error.message });
    }
  };

  const handleDueToday = (client: Client) => {
    setClientToDueToday(client);
    setDueTodayDialogOpen(true);
  };

  const handleConfirmDueToday = async () => {
    if (!clientToDueToday) return;

    try {
      await setClientDueTodayMutation.mutateAsync({
        clientId: clientToDueToday.id,
        clientName: clientToDueToday.name,
        currentStatus: clientToDueToday.status as ClientStatus,
      });

      toast.success("Vencimento alterado!", { description: `O vencimento de ${clientToDueToday.name} foi definido para hoje.` });
    } catch (error: any) {
      toast.error("Erro ao alterar vencimento", { description: error.message });
    } finally {
      setDueTodayDialogOpen(false);
      setClientToDueToday(null);
    }
  };

  const handleDeleteConfirm = async () => {
    if (!clientToDelete) return;

    try {
      await deleteClientMutation.mutateAsync(clientToDelete.id);
      toast.success("Cliente excludo", { description: "O cliente foi removido com sucesso." });
    } catch (error: any) {
      toast.error("Erro ao excluir cliente", { description: error.message });
    } finally {
      setDeleteDialogOpen(false);
      setClientToDelete(null);
    }
  };

  const toggleSort = (field: SortField) => {
    if (sortField === field) {
      setSortOrder(sortOrder === "asc" ? "desc" : "asc");
    } else {
      setSortField(field);
      setSortOrder("asc");
    }
  };

  const handleOpenDialog = (client?: Client) => {
    setSelectedClient(client || null);
    setDialogOpen(true);
  };

  const handleOpenNotificationDialog = (client: Client) => {
    setClientToNotify(client);
    setNotificationDialogOpen(true);
  };

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold text-foreground">Clientes</h1>
          <p className="text-muted-foreground mt-1">Gerencie seus clientes e cobranas</p>
        </div>
        <Button onClick={() => handleOpenDialog()} className="gap-2">
          <Plus className="h-4 w-4" />
          Novo Cliente
        </Button>
      </div>

      <div className="flex gap-4">
        <div className="relative flex-1">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Buscar por nome ou telefone..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="pl-10"
          />
        </div>
        <Select value={statusFilter} onValueChange={setStatusFilter}>
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Filtrar por status" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">Todos</SelectItem>
            <SelectItem value="active">Em dia</SelectItem>
            <SelectItem value="overdue">Atrasado</SelectItem>
            <SelectItem value="inactive">Cancelado</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {isLoading ? (
        <div className="border rounded-lg">
          <div className="h-64 flex items-center justify-center">
            <p className="text-muted-foreground">Carregando...</p>
          </div>
        </div>
      ) : filteredAndSortedClients.length === 0 ? (
        <div className="border rounded-lg">
          <div className="flex flex-col items-center justify-center py-12">
            <p className="text-muted-foreground text-center">
              {searchTerm || statusFilter !== "all"
                ? "Nenhum cliente encontrado com os filtros aplicados."
                : "Nenhum cliente cadastrado. Adicione seu primeiro cliente!"}
            </p>
          </div>
        </div>
      ) : (
        <div className="border rounded-lg">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>
                  <Button
                    variant="ghost"
                    onClick={() => toggleSort("name")}
                    className="gap-2 hover:bg-transparent p-0"
                  >
                    Nome
                    <ArrowUpDown className="h-4 w-4" />
                  </Button>
                </TableHead>
                <TableHead>
                  <Button
                    variant="ghost"
                    onClick={() => toggleSort("due_date")}
                    className="gap-2 hover:bg-transparent p-0"
                  >
                    Prximo Vencimento
                    <ArrowUpDown className="h-4 w-4" />
                  </Button>
                </TableHead>
                <TableHead>Telefone</TableHead>
                <TableHead>Valor</TableHead>
                <TableHead>Status</TableHead>
                <TableHead className="w-[50px]"></TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredAndSortedClients.map((client) => (
                <TableRow key={client.id}>
                  <TableCell className="font-medium">{client.name}</TableCell>
                  <TableCell>
                    {(() => {
                      if (!client.next_billing_date) return '-';
                      
                      // A data vem como 'YYYY-MM-DD' do Supabase
                      const dateString = client.next_billing_date;

                      // Divide a string e cria um objeto Date local para evitar interpretao UTC
                      const parts = dateString.split('-').map(Number);
                      // Ms  0-indexado no construtor de Date
                      const localDate = new Date(parts[0], parts[1] - 1, parts[2]);

                      // Formata o objeto Date local para exibio
                      return format(localDate, 'dd/MM/yyyy');
                    })()}
                  </TableCell>
                  <TableCell>{client.phone}</TableCell>
                  <TableCell>
                    {client.planDetailsValue !== undefined && client.planDetailsValue !== null
                      ? new Intl.NumberFormat("pt-BR", { style: "currency", currency: "BRL" }).format(client.planDetailsValue)
                      : "N/A"}
                  </TableCell>
                  <TableCell>{getStatusBadge(client.status)}</TableCell>
                  <TableCell>
                    <DropdownMenu>
                      <DropdownMenuTrigger asChild>
                        <Button variant="ghost" size="icon">
                          <MoreHorizontal className="h-4 w-4" />
                        </Button>
                      </DropdownMenuTrigger>
                      <DropdownMenuContent align="end">
                        <DropdownMenuItem onClick={() => handleOpenDialog(client)}>
                          <Pencil className="h-4 w-4 mr-2" />
                          Editar
                        </DropdownMenuItem>
                        <DropdownMenuItem onClick={() => handleRenewClient(client)}>
                          <RefreshCw className="h-4 w-4 mr-2" />
                          Renovar
                        </DropdownMenuItem>
                        <DropdownMenuItem onClick={() => handleOpenNotificationDialog(client)}>
                          <Bell className="h-4 w-4 mr-2" />
                          Notificar
                        </DropdownMenuItem>
                        <DropdownMenuItem onClick={() => handleDueToday(client)}>
                          <CalendarCheck className="h-4 w-4 mr-2" />
                          Vencer Hoje
                        </DropdownMenuItem>
                        <DropdownMenuSub>
                          <DropdownMenuSubTrigger>
                            <ListChecks className="h-4 w-4 mr-2" />
                            Mudar Status
                          </DropdownMenuSubTrigger>
                          <DropdownMenuSubContent>
                            <DropdownMenuItem onClick={() => handleChangeStatus(client, "active")}>
                              {client.status === "active" && <Check className="h-4 w-4 mr-2" />}
                              Ativo
                            </DropdownMenuItem>
                            <DropdownMenuItem onClick={() => handleChangeStatus(client, "inactive")}>
                              {client.status === "inactive" && <Check className="h-4 w-4 mr-2" />}
                              Inativo
                            </DropdownMenuItem>
                            {/* A opo 'Vencido' foi removida daqui */}
                          </DropdownMenuSubContent>
                        </DropdownMenuSub>
                        <DropdownMenuItem
                          onClick={() => {
                            setClientToDelete(client);
                            setDeleteDialogOpen(true);
                          }}
                          className="text-destructive"
                        >
                          <Trash2 className="h-4 w-4 mr-2" />
                          Excluir
                        </DropdownMenuItem>
                      </DropdownMenuContent>
                    </DropdownMenu>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </div>
      )}

      <ClientDialog
        open={dialogOpen}
        onOpenChange={setDialogOpen}
        client={selectedClient}
      />

      <NotificationDialog
        open={notificationDialogOpen}
        onOpenChange={setNotificationDialogOpen}
        client={clientToNotify}
      />

      <AlertDialog open={dueTodayDialogOpen} onOpenChange={setDueTodayDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Confirmar Vencimento para Hoje</AlertDialogTitle>
            <AlertDialogDescription>
              Tem certeza que deseja alterar o vencimento do cliente "{clientToDueToday?.name}" para hoje?
              Se o cliente estiver inativo, ele ser ativado.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancelar</AlertDialogCancel>
            <AlertDialogAction onClick={handleConfirmDueToday} className="bg-primary text-primary-foreground hover:bg-primary/90">
              Confirmar
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Confirmar excluso</AlertDialogTitle>
            <AlertDialogDescription>
              Tem certeza que deseja excluir o cliente "{clientToDelete?.name}"? Esta ao no pode ser desfeita.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancelar</AlertDialogCancel>
            <AlertDialogAction onClick={handleDeleteConfirm} className="bg-destructive text-destructive-foreground hover:bg-destructive/90">
              Excluir
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
--- Contedo de: src/pages/Connection.tsx ---
import { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { nanoid } from 'nanoid';
import { UserInstance, UserInstanceInsert, UserInstanceUpdate } from "@/integrations/supabase/schema";
import { useWebhookConfig } from '@/hooks/useWebhookConfig';
import { useLogEvolutionLogoutHistory } from '@/hooks/useEvolutionLogoutHistory'; // NOVO: Importar o hook de histrico de logout

type ConnectionStatus = "disconnected" | "connecting" | "connected";

// Define a URL fixa da Edge Function que atua como listener da Evolution API
const SUPABASE_PROJECT_ID = 'cgqyfpsfymhntumrmbzj';
const EVOLUTION_WEBHOOK_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/evolution-webhook-receiver`;

// --- Hooks para gerenciar a instncia do usurio ---
const fetchUserInstance = async (): Promise<UserInstance | null> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("Usurio no autenticado");

  const { data, error } = await supabase
    .from('user_instances')
    .select('*')
    .eq('user_id', user.id)
    .single();

  if (error && error.code !== 'PGRST116') throw error; // PGRST116 = No rows found
  return data;
};

export const useUserInstance = () => {
  return useQuery<UserInstance | null, Error>({
    queryKey: ['userInstance'],
    queryFn: fetchUserInstance,
  });
};

const createUserInstance = async (newEntry: UserInstanceInsert): Promise<UserInstance> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("Usurio no autenticado");

  const { data, error } = await supabase
    .from('user_instances')
    .insert({ ...newEntry, user_id: user.id })
    .select()
    .single();

  if (error) throw new Error(error.message);
  return data as UserInstance;
};

export const useCreateUserInstance = () => {
  const queryClient = useQueryClient();
  return useMutation<UserInstance, Error, UserInstanceInsert>({
    mutationFn: createUserInstance,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['userInstance'] });
    },
  });
};

const updateUserInstance = async (updatedEntry: UserInstanceUpdate & { id: string }): Promise<UserInstance> => {
  const { id, ...updateData } = updatedEntry;
  const { data, error } = await supabase
    .from('user_instances')
    .update(updateData)
    .eq('id', id)
    .select()
    .single();

  if (error) throw new Error(error.message);
  return data as UserInstance;
};

export const useUpdateUserInstance = () => {
  const queryClient = useQueryClient();
  return useMutation<UserInstance, Error, UserInstanceUpdate & { id: string }>({
    mutationFn: updateUserInstance,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['userInstance'] });
    },
  });
};

export default function Connection() {
  const { data: userInstance, isLoading: isLoadingInstance, error: instanceError } = useUserInstance();
  const updateUserInstanceMutation = useUpdateUserInstance();
  const logEvolutionLogoutMutation = useLogEvolutionLogoutHistory(); // NOVO: Hook de mutao para log de logout

  // BLOC 1: Buscar a URL do webhook de gerao de QR Code do n8n
  const { data: n8nQrWebhookConfig, isLoading: isLoadingN8nQrConfig, error: n8nQrConfigError } = useWebhookConfig('n8n_qr_code_generator');
  // NOVO: Buscar a URL do webhook de logout da Evolution API
  const { data: n8nEvolutionLogoutConfig, isLoading: isLoadingN8nEvolutionLogout, error: n8nEvolutionLogoutError } = useWebhookConfig('n8n_evolution_logout');


  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>("disconnected");
  const [qrCodeBase64, setQrCodeBase64] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [currentUserId, setCurrentUserId] = useState<string | null>(null);

  useEffect(() => {
    supabase.auth.getUser().then(({ data: { user } }) => {
      setCurrentUserId(user?.id || null);
    });
  }, []);

  useEffect(() => {
    if (userInstance) {
      setConnectionStatus(userInstance.status as ConnectionStatus);
      setQrCodeBase64(userInstance.qr_code_base64 || null);
    } else if (!isLoadingInstance && !instanceError) {
      setConnectionStatus("disconnected");
      setQrCodeBase64(null);
    }
  }, [userInstance, isLoadingInstance, instanceError]);

  useEffect(() => {
    if (instanceError) {
      toast.error("Erro ao carregar dados da conexo", { description: instanceError.message });
    }
    // Exibir erro se a configurao do webhook de QR Code falhar
    if (n8nQrConfigError) {
      toast.error("Erro ao carregar configurao do webhook de QR Code", { description: n8nQrConfigError.message });
    }
    // NOVO: Exibir erro se a configurao do webhook de logout falhar
    if (n8nEvolutionLogoutError) {
      toast.error("Erro ao carregar configurao do webhook de logout", { description: n8nEvolutionLogoutError.message });
    }
  }, [instanceError, n8nQrConfigError, n8nEvolutionLogoutError]);

  // --- Supabase Realtime Listener ---
  useEffect(() => {
    if (!currentUserId) return;

    const channel = supabase.channel('instance-status-updates')
      .on(
        'postgres_changes',
        { event: 'UPDATE', schema: 'public', table: 'user_instances', filter: `user_id=eq.${currentUserId}` },
        (payload) => {
          console.log('Status da instncia alterado via Realtime!', payload.new);
          const newStatus = payload.new.status as ConnectionStatus;
          const newQrCode = payload.new.qr_code_base64 || null;
          setConnectionStatus(newStatus);
          setQrCodeBase64(newQrCode);

          if (newStatus === 'connected') {
            toast.success("Conectado!", { description: "Seu WhatsApp foi conectado com sucesso." });
          } else if (newStatus === 'disconnected' && !isLoading) {
            toast.error("Desconectado", { description: "Seu WhatsApp foi desconectado." });
          }
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [currentUserId, isLoading]);


  const getStatusDisplay = (status: ConnectionStatus) => {
    switch (status) {
      case "disconnected":
        return { label: "Desconectado", variant: "destructive" as const };
      case "connecting":
        return { label: "Aguardando QR Code...", variant: "secondary" as const };
      case "connected":
        return { label: "Conectado", variant: "default" as const };
      default:
        return { label: "Desconhecido", variant: "secondary" as const };
    }
  };

  const logN8nQrInteraction = async (
    requestPayload: any,
    responsePayload: any,
    statusCode: number | null,
    errorMessage: string | null,
    instanceName: string
  ) => {
    if (!currentUserId) return;

    try {
      const { error: invokeError } = await supabase.functions.invoke('log-n8n-qr-interaction', {
        body: {
          requestPayload,
          responsePayload,
          statusCode,
          errorMessage,
          instanceName,
        },
        headers: {
          'Authorization': `Bearer ${await supabase.auth.getSession().then(s => s.data.session?.access_token)}`,
        },
      });

      if (invokeError) {
        console.error('Error invoking log-n8n-qr-interaction:', invokeError.message);
      }
    } catch (logError: any) {
      console.error('Failed to log N8N QR interaction:', logError.message);
    }
  };

  const handleGenerateQrCode = async () => {
    setIsLoading(true);
    setError(null);
    setQrCodeBase64(null);
    setConnectionStatus("connecting");

    let requestBody: any = {};
    let responseData: any = null;
    let httpStatusCode: number | null = null;
    let currentInstanceName: string = '';
    let currentInstanceId: string | undefined = userInstance?.id;
    let operationErrorMessage: string | null = null;

    try {
      // BLOC 1: Obter a URL do webhook de gerao de QR Code do n8n
      if (isLoadingN8nQrConfig) {
        throw new Error('Configurao do webhook de QR Code ainda est carregando.');
      }
      if (n8nQrConfigError) {
        throw new Error('Erro ao carregar URL do webhook de QR Code: ' + n8nQrConfigError.message);
      }
      if (!n8nQrWebhookConfig?.url) {
        throw new Error('URL do webhook de QR Code do n8n no configurada. Configure em Conexo > Webhooks.');
      }

      const n8n_qr_code_webhook_url = n8nQrWebhookConfig.url;
      const evolution_listener_url = EVOLUTION_WEBHOOK_URL; // URL fixa da nossa Edge Function

      // --- PASSO 2: GARANTIR A EXISTNCIA DE UMA INSTNCIA PARA O UTILIZADOR ---
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Utilizador no autenticado.');

      if (userInstance) {
        currentInstanceName = userInstance.instance_name;
        currentInstanceId = userInstance.id;
        await updateUserInstanceMutation.mutateAsync({
          id: currentInstanceId,
          status: "connecting",
          qr_code_base64: null,
        });
      } else {
        const newName = `user-${nanoid(10)}`;
        const { data: newInstance, error: createError } = await supabase
          .from('user_instances')
          .insert({ user_id: user.id, instance_name: newName, status: "connecting", qr_code_base64: null })
          .select('id, instance_name')
          .single();
        
        if (createError) {
          throw new Error('Erro ao criar a instncia do utilizador: ' + createError.message);
        }
        currentInstanceName = newInstance.instance_name;
        currentInstanceId = newInstance.id;
      }

      // --- PASSO 3: ENVIAR A REQUISIO PARA O N8N COM TODOS OS DADOS ---
      requestBody = {
        instanceName: currentInstanceName,
        webhook: {
          url: evolution_listener_url, // Esta  a URL da nossa Supabase Edge Function
          events: ['CONNECTION_UPDATE']
        }
      };

      const response = await fetch(n8n_qr_code_webhook_url, { // Usar a URL correta do webhook do n8n
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      });

      httpStatusCode = response.status;
      responseData = await response.json();

      if (!response.ok) {
        throw new Error(responseData.message || 'O servidor de automao retornou um erro.');
      }

      const result = Array.isArray(responseData) ? responseData[0] : responseData; // Acessar o primeiro elemento do array

      // CORREO AQUI: Acessar 'base64' diretamente do 'result' se a estrutura for como o exemplo fornecido
      if (result.base64) { 
        setQrCodeBase64(result.base64); // Atualizar estado local
        if (currentInstanceId) {
          await updateUserInstanceMutation.mutateAsync({
            id: currentInstanceId,
            instance_name: result.instanceName || currentInstanceName, // Usar instanceName da resposta ou o gerado
            qr_code_base64: result.base64, // Salvar base64
            status: "connecting",
          });
        }
        toast.success("QR Code gerado!", { description: "Escaneie o QR Code com seu celular para conectar." });
      } else {
        throw new Error('No foi possvel obter o QR Code. Tente novamente.');
      }

    } catch (err: any) {
      operationErrorMessage = err.message;
      setError(err.message);
      // BLOC 2: Tratamento de Erro no Envio do POST - Reverter status para 'disconnected' no DB
      if (userInstance?.id) {
        await updateUserInstanceMutation.mutateAsync({
          id: userInstance.id,
          status: "disconnected",
          qr_code_base64: null,
        });
      }
      setConnectionStatus("disconnected"); // Atualiza o estado local imediatamente
      setQrCodeBase64(null); // Limpa o QR code imediatamente
      console.error("Erro detalhado no processo de gerar QR Code:", err);
      toast.error("Erro ao gerar QR Code", { description: err.message });
    } finally {
      setIsLoading(false);
      // Logar a interao com o N8N QR Code, independentemente do sucesso ou falha
      if (currentUserId && currentInstanceName) {
        logN8nQrInteraction(
          requestBody,
          responseData,
          httpStatusCode,
          operationErrorMessage,
          currentInstanceName
        );
      }
    }
  };

  const handleDisconnect = async () => {
    if (!userInstance || !userInstance.id || !userInstance.instance_name) {
      toast.error("Erro", { description: "Nenhuma instncia para desconectar." });
      return;
    }

    setIsLoading(true);
    setError(null);

    let requestBody: any = {};
    let responseData: any = null;
    let httpStatusCode: number | null = null;
    let operationErrorMessage: string | null = null;

    try {
      // NOVO: Buscar a URL do webhook de logout do n8n
      if (isLoadingN8nEvolutionLogout) {
        throw new Error('Configurao do webhook de logout ainda est carregando.');
      }
      if (n8nEvolutionLogoutError) {
        throw new Error('Erro ao carregar URL do webhook de logout: ' + n8nEvolutionLogoutError.message);
      }
      if (!n8nEvolutionLogoutConfig?.url) {
        throw new Error('URL do webhook de logout do n8n no configurada. Configure em Conexo > Webhooks.');
      }

      const n8n_evolution_logout_webhook_url = n8nEvolutionLogoutConfig.url;
      const instanceName = userInstance.instance_name;

      requestBody = {
        instanceName: instanceName,
        Event: "Disconnect" // Payload conforme especificado
      };

      const response = await fetch(n8n_evolution_logout_webhook_url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      });

      httpStatusCode = response.status;
      responseData = await response.json();

      if (!response.ok) {
        throw new Error(responseData.message || 'O servidor de automao retornou um erro ao tentar desconectar.');
      }

      toast.success("Solicitao de desconexo enviada!", { description: "Aguarde a confirmao da Evolution API." });
      // O status ser atualizado via Realtime pelo evolution-webhook-receiver
      
    } catch (err: any) {
      operationErrorMessage = err.message;
      setError(err.message);
      console.error("Erro detalhado no processo de desconexo:", err);
      toast.error("Erro ao desconectar", { description: err.message });
    } finally {
      setIsLoading(false);
      // Logar a interao de logout, independentemente do sucesso ou falha
      if (currentUserId && userInstance?.instance_name) {
        logEvolutionLogoutMutation.mutate({
          requestPayload: requestBody,
          responsePayload: responseData,
          statusCode: httpStatusCode,
          errorMessage: operationErrorMessage,
          instanceName: userInstance.instance_name,
        });
      }
    }
  };

  // BLOC 3: Funo para o boto "Cancelar"
  const handleCancelConnection = async () => {
    if (!userInstance || !userInstance.id) {
      toast.error("Erro", { description: "Nenhuma instncia para cancelar a conexo." });
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      await updateUserInstanceMutation.mutateAsync({
        id: userInstance.id,
        status: "disconnected",
        qr_code_base64: null,
      });
      // O listener Realtime ir atualizar o estado local automaticamente
      toast.info("Conexo cancelada", { description: "O processo de conexo foi cancelado." });
    } catch (err: any) {
      setError(err.message);
      toast.error("Erro ao cancelar conexo", { description: err.message });
    } finally {
      setIsLoading(false);
    }
  };

  const { label, variant } = getStatusDisplay(connectionStatus);

  if (isLoadingInstance) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <div className="w-16 h-16 border-4 border-primary border-t-transparent rounded-full animate-spin mx-auto mb-4" />
          <p className="text-muted-foreground">Carregando status da conexo...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-3xl font-bold text-foreground">Conexo com WhatsApp</h1>
        <p className="text-muted-foreground mt-1">Gerencie a integrao do seu sistema com o WhatsApp</p>
      </div>

      <Card className="border-border bg-card">
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            Status: <Badge variant={variant}>{label}</Badge>
          </CardTitle>
          <CardDescription>
            {connectionStatus === "disconnected" && "Para enviar notificaes, conecte seu nmero de WhatsApp."}
            {connectionStatus === "connecting" && "Aguardando leitura do QR Code..."}
            {connectionStatus === "connected" && "Dispositivo conectado com sucesso!"}
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {error && (
            <div className="bg-destructive/10 text-destructive p-3 rounded-md text-sm">
              <p className="font-medium">Erro:</p>
              <p>{error}</p>
            </div>
          )}

          {connectionStatus === "disconnected" && (
            <Button onClick={handleGenerateQrCode} className="w-full" disabled={isLoading || isLoadingN8nQrConfig}>
              {isLoading || isLoadingN8nQrConfig ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" /> Gerando QR Code...
                </>
              ) : (
                "Gerar QR Code"
              )}
            </Button>
          )}

          {connectionStatus === "connecting" && (
            <div className="flex flex-col items-center justify-center space-y-4">
              {isLoading ? (
                <Loader2 className="h-12 w-12 animate-spin text-primary" />
              ) : qrCodeBase64 ? (
                <div>
                  <p className="text-muted-foreground mb-4">Escaneie o QR Code com o seu WhatsApp.</p>
                  <img 
                    src={
                      qrCodeBase64.startsWith('data:image') 
                        ? qrCodeBase64 
                        : `data:image/png;base64,${qrCodeBase64}`
                    } 
                    alt="WhatsApp QR Code"
                    className="mx-auto rounded-lg border-4 border-white bg-white"
                  />
                  <p className="text-xs text-muted-foreground mt-4">Escaneie o QR Code com o seu celular.</p>
                </div>
              ) : (
                <p className="text-muted-foreground mb-4">Gerando QR Code... Por favor, aguarde.</p>
              )}
              {/* BLOC 3: Boto "Cancelar" - agora habilitado quando connectionStatus  "connecting" */}
              <Button onClick={handleCancelConnection} variant="outline" className="w-full" disabled={isLoading}>
                {isLoading ? (
                  <>
                    <Loader2 className="h-4 w-4 mr-2 animate-spin" /> Cancelando...
                  </>
                ) : (
                  "Cancelar"
                )}
              </Button>
            </div>
          )}

          {connectionStatus === "connected" && (
            <Button onClick={handleDisconnect} variant="destructive" className="w-full" disabled={isLoading || isLoadingN8nEvolutionLogout}>
              {isLoading || isLoadingN8nEvolutionLogout ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" /> Desconectando...
                </>
              ) : (
                "Desconectar"
              )}
            </Button>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
--- Contedo de: src/pages/Dashboard.tsx ---
import { useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Users, FileText, AlertCircle, TrendingUp } from "lucide-react";
import { toast } from "sonner";
import { useDashboardStats } from "@/hooks/useDashboardStats";

export default function Dashboard() {
  const { data: stats, isLoading, error } = useDashboardStats();

  useEffect(() => {
    if (error) {
      toast.error("Erro ao carregar estatsticas", { description: error.message });
    }
  }, [error]);

  const statCards = [
    {
      title: "Total de Clientes",
      value: stats?.totalClients || 0,
      icon: Users,
      color: "text-primary",
    },
    {
      title: "Clientes Ativos",
      value: stats?.activeClients || 0,
      icon: TrendingUp,
      color: "text-success",
    },
    {
      title: "Planos Cadastrados",
      value: stats?.totalPlans || 0,
      icon: FileText,
      color: "text-accent",
    },
    {
      title: "Cobranas Atrasadas",
      value: stats?.overdueClients || 0,
      icon: AlertCircle,
      color: "text-destructive",
    },
  ];

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-3xl font-bold text-foreground">Dashboard</h1>
        <p className="text-muted-foreground mt-1">
          Viso geral do seu sistema de cobrana
        </p>
      </div>

      {isLoading ? (
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-4">
          {[...Array(4)].map((_, i) => (
            <Card key={i} className="border-border bg-card">
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <div className="h-4 bg-muted rounded w-24 animate-pulse" />
                <div className="h-4 w-4 bg-muted rounded animate-pulse" />
              </CardHeader>
              <CardContent>
                <div className="h-8 bg-muted rounded w-16 animate-pulse" />
              </CardContent>
            </Card>
          ))}
        </div>
      ) : (
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-4">
          {statCards.map((stat) => (
            <Card
              key={stat.title}
              className="border-border bg-card hover:shadow-md transition-shadow"
            >
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <CardTitle className="text-sm font-medium text-muted-foreground">
                  {stat.title}
                </CardTitle>
                <stat.icon className={`h-4 w-4 ${stat.color}`} />
              </CardHeader>
              <CardContent>
                <div className={`text-3xl font-bold ${stat.color}`}>{stat.value}</div>
              </CardContent>
            </Card>
          ))}
        </div>
      )}

      <Card className="border-border bg-card">
        <CardHeader>
          <CardTitle>Bem-vindo ao Acerto Certo</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-muted-foreground">
            Gerencie seus clientes, planos e cobranas de forma eficiente. Use o menu lateral
            para navegar entre as diferentes funcionalidades do sistema.
          </p>
        </CardContent>
      </Card>
    </div>
  );
}
--- Contedo de: src/pages/NotFound.tsx ---
import { useLocation } from "react-router-dom";
import { useEffect } from "react";

const NotFound = () => {
  const location = useLocation();

  useEffect(() => {
    console.error("404 Error: User attempted to access non-existent route:", location.pathname);
  }, [location.pathname]);

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-100">
      <div className="text-center">
        <h1 className="mb-4 text-4xl font-bold">404</h1>
        <p className="mb-4 text-xl text-gray-600">Oops! Page not found</p>
        <a href="/" className="text-blue-500 underline hover:text-blue-700">
          Return to Home
        </a>
      </div>
    </div>
  );
};

export default NotFound;

--- Contedo de: src/pages/Plans.tsx ---
import { useEffect, useState } from "react";
import { Button } from "@/components/ui/button";
import { Plus, MoreHorizontal, Pencil, Trash2 } from "lucide-react";
import { toast } from "sonner";
import { PlanDialog } from "@/components/plans/PlanDialog";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { usePlans, useDeletePlan } from "@/hooks/usePlans";
import { Plan } from "@/integrations/supabase/schema"; // Importar Plan do schema

export default function Plans() {
  const { data: plans, isLoading, error } = usePlans();
  const deletePlanMutation = useDeletePlan();

  const [dialogOpen, setDialogOpen] = useState(false);
  const [selectedPlan, setSelectedPlan] = useState<Plan | null>(null);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [planToDelete, setPlanToDelete] = useState<Plan | null>(null);

  useEffect(() => {
    if (error) {
      toast.error("Erro ao carregar planos", { description: error.message });
    }
  }, [error]);

  const handleOpenDialog = (plan?: Plan) => {
    setSelectedPlan(plan || null);
    setDialogOpen(true);
  };

  const getPeriodLabel = (days: number) => {
    if (days === 1) return "Dirio";
    if (days === 7) return "Semanal";
    if (days === 30) return "Mensal";
    return `${days} dias`;
  };

  const handleDeleteConfirm = async () => {
    if (!planToDelete) return;

    try {
      await deletePlanMutation.mutateAsync(planToDelete.id);
      toast.success("Plano excludo", { description: "O plano foi removido com sucesso." });
    } catch (error: any) {
      toast.error("Erro ao excluir plano", { description: error.message });
    } finally {
      setDeleteDialogOpen(false);
      setPlanToDelete(null);
    }
  };

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold text-foreground">Planos</h1>
          <p className="text-muted-foreground mt-1">Gerencie seus planos de cobrana</p>
        </div>
        <Button onClick={() => handleOpenDialog()} className="gap-2">
          <Plus className="h-4 w-4" />
          Novo Plano
        </Button>
      </div>

      {isLoading ? (
        <div className="border rounded-lg">
          <div className="h-64 flex items-center justify-center">
            <p className="text-muted-foreground">Carregando...</p>
          </div>
        </div>
      ) : (plans || []).length === 0 ? (
        <div className="border rounded-lg">
          <div className="flex flex-col items-center justify-center py-12">
            <p className="text-muted-foreground text-center">
              Nenhum plano cadastrado. Crie seu primeiro plano!
            </p>
          </div>
        </div>
      ) : (
        <div className="border rounded-lg">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Nome do Plano</TableHead>
                <TableHead>Valor</TableHead>
                <TableHead>Perodo (dias)</TableHead>
                <TableHead className="w-[50px]"></TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {(plans || []).map((plan) => (
                <TableRow key={plan.id}>
                  <TableCell className="font-medium">{plan.name}</TableCell>
                  <TableCell>R$ {Number(plan.value).toFixed(2)}</TableCell>
                  <TableCell>{getPeriodLabel(plan.period_days)}</TableCell>
                  <TableCell>
                    <DropdownMenu>
                      <DropdownMenuTrigger asChild>
                        <Button variant="ghost" size="icon">
                          <MoreHorizontal className="h-4 w-4" />
                        </Button>
                      </DropdownMenuTrigger>
                      <DropdownMenuContent align="end">
                        <DropdownMenuItem onClick={() => handleOpenDialog(plan)}>
                          <Pencil className="h-4 w-4 mr-2" />
                          Editar
                        </DropdownMenuItem>
                        <DropdownMenuItem
                          onClick={() => {
                            setPlanToDelete(plan);
                            setDeleteDialogOpen(true);
                          }}
                          className="text-destructive"
                        >
                          <Trash2 className="h-4 w-4 mr-2" />
                          Excluir
                        </DropdownMenuItem>
                      </DropdownMenuContent>
                    </DropdownMenu>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </div>
      )}

      <PlanDialog
        open={dialogOpen}
        onOpenChange={setDialogOpen}
        plan={selectedPlan}
      />

      <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Confirmar excluso</AlertDialogTitle>
            <AlertDialogDescription>
              Tem certeza que deseja excluir o plano "{planToDelete?.name}"? Esta ao no pode ser desfeita.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancelar</AlertDialogCancel>
            <AlertDialogAction onClick={handleDeleteConfirm} className="bg-destructive text-destructive-foreground hover:bg-destructive/90">
              Excluir
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
--- Contedo de: src/pages/Profile.tsx ---
import React, { useState, useEffect } from 'react';
import { useMutation } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { User, Mail, Lock, Save, QrCode, KeyRound, ShieldCheck, LockKeyhole, Gem, Phone, UserCheck } from 'lucide-react';
import { toast } from 'sonner';
import { Skeleton } from '@/components/ui/skeleton';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import { useProfileAndSubscriptionData, useUpdateProfile } from '@/hooks/useProfileData';
import { useLocation, useNavigate } from 'react-router-dom';
import { PixPaymentModal } from '@/components/profile/PixPaymentModal';
import { MercadoPagoPaymentModal } from '@/components/profile/MercadoPagoPaymentModal'; // NOVO: Importar modal do Mercado Pago
import { useActiveGateway } from '@/hooks/useActiveGateway'; // NOVO: Importar hook do gateway ativo

// --- LGICA DE DADOS (HOOKS) ---
const useUpdatePassword = () => {
    return useMutation({
        mutationFn: async ({ newPassword }: { newPassword: string }) => {
            const { error } = await supabase.auth.updateUser({ password: newPassword });
            if (error) throw new Error(error.message);
        },
        onSuccess: () => toast.success('Senha atualizada com sucesso!'),
        onError: (error) => toast.error(`Erro ao atualizar senha: ${error.message}`),
    });
};

// --- COMPONENTE PRINCIPAL DA PGINA ---
export default function Profile() {
    const [isPixModalOpen, setIsPixModalOpen] = useState(false);
    const [isMercadoPagoModalOpen, setIsMercadoPagoModalOpen] = useState(false); // NOVO: Estado para o modal do Mercado Pago
    const { data, isLoading, error } = useProfileAndSubscriptionData();
    const { data: activeGateway, isLoading: isLoadingActiveGateway } = useActiveGateway(); // NOVO: Hook para o gateway ativo
    const updateProfileMutation = useUpdateProfile();
    const updatePasswordMutation = useUpdatePassword();
    const location = useLocation();
    const navigate = useNavigate();
    const [highlightPhone, setHighlightPhone] = useState(false);
    const [highlightTaxId, setHighlightTaxId] = useState(false);

    useEffect(() => {
        const params = new URLSearchParams(location.search);
        if (params.get('missingPhone') === 'true') {
            toast.error('Telefone obrigatrio', {
                description: 'Por favor, preencha seu nmero de telefone para continuar navegando no sistema.',
            });
            setHighlightPhone(true);
            params.delete('missingPhone');
            navigate({ search: params.toString() }, { replace: true });
        }
    }, [location.search, navigate]);

    const handleProfileSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        setHighlightTaxId(false);
        const formData = new FormData(e.target as HTMLFormElement);
        const name = formData.get('name') as string;
        const pix_key = formData.get('pix_key') as string;
        const phone = formData.get('phone') as string;
        const tax_id = formData.get('tax_id') as string;

        const cleanedTaxId = tax_id.replace(/\D/g, '');
        if (!cleanedTaxId || (cleanedTaxId.length !== 11 && cleanedTaxId.length !== 14)) {
            toast.error("CPF/CNPJ invlido ou ausente", { description: "Deve conter 11 (CPF) ou 14 (CNPJ) nmeros." });
            setHighlightTaxId(true);
            return;
        }

        updateProfileMutation.mutate({ 
            name, 
            pix_key: pix_key || null, 
            phone: phone || null,
            tax_id: cleanedTaxId,
        });
    };
    
    const handlePasswordSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        const formData = new FormData(e.target as HTMLFormElement);
        const newPassword = formData.get('password') as string;
        if (newPassword && newPassword.length >= 6) {
            updatePasswordMutation.mutate({ newPassword });
        } else {
            toast.error('A nova senha deve ter pelo menos 6 caracteres.');
        }
    };

    const formatDate = (dateString: string) => new Date(dateString + 'T00:00:00').toLocaleDateString('pt-BR', { year: 'numeric', month: 'long', day: 'numeric' });

    if (isLoading || isLoadingActiveGateway) return ( // NOVO: Incluir isLoadingActiveGateway
        <div className="min-h-screen p-4 sm:p-6 lg:p-8">
            <Skeleton className="h-12 w-1/3" />
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mt-8">
                <div className="lg:col-span-2 space-y-8">
                    <Skeleton className="h-64 w-full" />
                    <Skeleton className="h-48 w-full" />
                </div>
                <div className="lg:col-span-1">
                    <Skeleton className="h-64 w-full" />
                </div>
            </div>
        </div>
    );
    if (error) return <div className="p-8 text-destructive">Erro ao carregar dados do perfil: {error.message}</div>;

    if (!data) return null; 
    const { profile, subscription } = data;

    const isPagbankActive = activeGateway?.gateway_name === 'pagbank';
    const isMercadoPagoActive = activeGateway?.gateway_name === 'mercadopago';

    return (
        <div className="bg-background min-h-screen text-foreground p-4 sm:p-6 lg:p-8 font-sans">
            <div className="max-w-4xl mx-auto space-y-8">
                <header>
                    <h1 className="text-3xl font-bold text-foreground">Gerenciar Perfil</h1>
                    <p className="text-muted-foreground mt-1">Atualize suas informaes pessoais e gerencie sua assinatura.</p>
                </header>
                <main className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                    <div className="lg:col-span-2 space-y-8">
                        <Card className="rounded-xl">
                            <form onSubmit={handleProfileSubmit}>
                                <CardHeader className="p-6">
                                    <CardTitle className="text-lg font-semibold text-foreground flex items-center">
                                        <User className="w-5 h-5 mr-2 text-primary" />
                                        Informaes do Perfil
                                    </CardTitle>
                                    <CardDescription className="text-sm text-muted-foreground mt-1">Edite seu nome, e-mail, telefone e chave PIX.</CardDescription>
                                </CardHeader>
                                <CardContent className="p-6 pt-0">
                                    <div className="mt-6 space-y-4">
                                        <div className="relative">
                                            <User className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                                            <Input id="name" name="name" defaultValue={profile.name} className="block w-full rounded-lg pl-10" />
                                        </div>
                                        <div className="relative">
                                            <Mail className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                                            <Input id="email" name="email" type="email" defaultValue={profile.email} disabled className="block w-full rounded-lg pl-10 text-muted-foreground" />
                                        </div>
                                        <div className="relative">
                                            <Phone className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                                            <Input 
                                                id="phone" 
                                                name="phone" 
                                                type="tel" 
                                                defaultValue={profile.phone || ''} 
                                                placeholder="Seu telefone (ex: 5511984701079)" 
                                                className={cn("block w-full rounded-lg pl-10", highlightPhone && "border-2 border-destructive")}
                                            />
                                        </div>
                                        <div className="relative">
                                            <UserCheck className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                                            <Input 
                                                id="tax_id" 
                                                name="tax_id" 
                                                defaultValue={profile.tax_id || ''} 
                                                placeholder="Seu CPF ou CNPJ (apenas nmeros)" 
                                                className={cn("block w-full rounded-lg pl-10", highlightTaxId && "border-2 border-destructive")}
                                                required
                                            />
                                        </div>
                                        <div className="relative">
                                            <KeyRound className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                                            <Input id="pix_key" name="pix_key" defaultValue={profile.pix_key || ''} placeholder="Sua chave PIX (e-mail, telefone ou aleatria)" className="block w-full rounded-lg pl-10" />
                                        </div>
                                    </div>
                                </CardContent>
                                <CardFooter className="bg-card/50 border-t border-border px-6 py-4 rounded-b-xl flex justify-end">
                                    <Button type="submit" disabled={updateProfileMutation.isPending}>
                                        <Save className="h-4 w-4 mr-2" />
                                        {updateProfileMutation.isPending ? "Salvando..." : "Salvar Alteraes"}
                                    </Button>
                                </CardFooter>
                            </form>
                        </Card>
                        <Card className="rounded-xl">
                             <form onSubmit={handlePasswordSubmit}>
                                <CardHeader className="p-6">
                                    <CardTitle className="text-lg font-semibold text-foreground flex items-center">
                                        <ShieldCheck className="w-5 h-5 mr-2 text-primary" />
                                        Segurana
                                    </CardTitle>
                                    <CardDescription className="text-sm text-muted-foreground mt-1">Altere sua senha de acesso.</CardDescription>
                                </CardHeader>
                                <CardContent className="p-6 pt-0">
                                    <div className="mt-6">
                                        <div className="relative">
                                            <Lock className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                                            <Input id="password" name="password" type="password" placeholder="" className="block w-full rounded-lg pl-10" />
                                        </div>
                                    </div>
                                </CardContent>
                                <CardFooter className="bg-card/50 border-t border-border px-6 py-4 rounded-b-xl flex justify-end">
                                    <Button type="submit" disabled={updatePasswordMutation.isPending}>
                                        <LockKeyhole className="h-4 w-4 mr-2" />
                                        {updatePasswordMutation.isPending ? "Atualizando..." : "Atualizar Senha"}
                                    </Button>
                                </CardFooter>
                            </form>
                        </Card>
                    </div>
                    <div className="lg:col-span-1">
                        <Card className="rounded-xl">
                            <CardHeader className="p-6">
                                <CardTitle className="text-lg font-semibold text-foreground flex items-center">
                                    <Gem className="w-5 h-5 mr-2 text-primary" />
                                    Assinatura
                                </CardTitle>
                            </CardHeader>
                            <CardContent className="p-6 pt-0">
                                {subscription ? (
                                    <div className="mt-6 p-4 rounded-lg bg-muted/50 space-y-4">
                                        <div className="flex items-center justify-between">
                                            <span className="font-semibold text-foreground">{subscription.planName}</span>
                                            <span className={cn(
                                                "py-1 px-3 rounded-full text-xs font-semibold",
                                                subscription.status === 'active' ? 'bg-success/10 text-success' : 'bg-destructive/10 text-destructive'
                                            )}>
                                                {subscription.status === 'active' ? 'Ativa' : subscription.status === 'overdue' ? 'Atrasada' : 'Inativa'}
                                            </span>
                                        </div>
                                        <div className="text-center">
                                            <p className="text-4xl font-bold text-foreground">
                                                {subscription.price.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}
                                                <span className="text-base font-medium text-muted-foreground">/ms</span>
                                            </p>
                                        </div>
                                        <div className="text-sm text-muted-foreground text-center border-t border-border pt-3">
                                            <p>Prxima cobrana em {formatDate(subscription.nextBillingDate)}</p>
                                        </div>
                                    </div>
                                ) : (
                                    <div className="mt-6 p-4 rounded-lg bg-muted/50 text-center text-muted-foreground">
                                        Nenhuma assinatura ativa.
                                    </div>
                                )}
                            </CardContent>
                            <CardFooter className="bg-card/50 border-t border-border px-6 py-4 rounded-b-xl">
                                {isPagbankActive && (
                                    <Button 
                                        className="w-full bg-secondary hover:bg-secondary/80 text-secondary-foreground" 
                                        onClick={() => {
                                            if (!subscription) {
                                                toast.error("Erro", { description: "Voc no possui uma assinatura ativa para renovar." });
                                                return;
                                            }
                                            setIsPixModalOpen(true);
                                        }}
                                        disabled={!subscription}
                                    >
                                        <QrCode className="w-5 h-5 mr-2" />
                                        Renovar com PIX
                                    </Button>
                                )}
                                {isMercadoPagoActive && (
                                    <Button 
                                        className="w-full bg-secondary hover:bg-secondary/80 text-secondary-foreground" 
                                        onClick={() => {
                                            if (!subscription) {
                                                toast.error("Erro", { description: "Voc no possui uma assinatura ativa para renovar." });
                                                return;
                                            }
                                            setIsMercadoPagoModalOpen(true);
                                        }}
                                        disabled={!subscription}
                                    >
                                        <QrCode className="w-5 h-5 mr-2" />
                                        Renovar com PIX
                                    </Button>
                                )}
                                {!isPagbankActive && !isMercadoPagoActive && (
                                    <Button 
                                        className="w-full bg-muted-foreground text-muted" 
                                        disabled
                                    >
                                        Nenhum gateway de pagamento ativo
                                    </Button>
                                )}
                            </CardFooter>
                        </Card>
                    </div>
                </main>
            </div>

            {/* Modal de Pagamento PIX */}
            {isPixModalOpen && subscription && (
                <PixPaymentModal
                    open={isPixModalOpen}
                    onOpenChange={setIsPixModalOpen}
                    subscriptionId={subscription.id}
                    amount={subscription.price}
                    planName={subscription.planName}
                />
            )}

            {/* NOVO: Modal de Pagamento Mercado Pago */}
            {isMercadoPagoModalOpen && subscription && (
                <MercadoPagoPaymentModal
                    open={isMercadoPagoModalOpen}
                    onOpenChange={setIsMercadoPagoModalOpen}
                    subscriptionId={subscription.id}
                    amount={subscription.price}
                    planName={subscription.planName}
                />
            )}
        </div>
    );
}
--- Contedo de: src/pages/Templates.tsx ---
import { useEffect, useState } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Plus } from "lucide-react";
import { toast } from "sonner";
import { TemplateDialog } from "@/components/templates/TemplateDialog";
import { Badge } from "@/components/ui/badge";
import { useTemplates, Template } from "@/hooks/useTemplates"; // Importar Template do hook useTemplates
import { useAuth } from "@/contexts/AuthContext"; // Importar useAuth

export default function Templates() {
  const { user, role } = useAuth(); // Obter user e role do AuthContext
  const { data: templates, isLoading, error } = useTemplates();
  // Removed: const deleteTemplateMutation = useDeleteTemplate(); // Usar o hook de delete

  const [dialogOpen, setDialogOpen] = useState(false);
  const [selectedTemplate, setSelectedTemplate] = useState<Template | null>(null);

  useEffect(() => {
    if (error) {
      toast.error("Erro ao carregar templates", { description: error.message });
    }
  }, [error]);

  const handleOpenDialog = (template?: Template) => {
    setSelectedTemplate(template || null);
    setDialogOpen(true);
  };

  // REMOVIDO: getCategoryLabel e getCategoryColor

  const canEditOrDelete = (template: Template) => {
    if (!user) return false;
    // Admins podem editar/deletar qualquer template
    if (role === 'admin') return true;
    // Usurio comum s pode editar/deletar seus prprios templates E que sejam do tipo 'normal'
    return template.user_id === user.id && template.type === 'normal';
  };

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold text-foreground">Templates</h1>
          <p className="text-muted-foreground mt-1">Gerencie suas mensagens automticas</p>
        </div>
        <Button onClick={() => handleOpenDialog()} className="gap-2">
          <Plus className="h-4 w-4" />
          Novo Template
        </Button>
      </div>

      {isLoading ? (
        <div className="grid gap-4 md:grid-cols-2">
          {[...Array(4)].map((_, i) => (
            <Card key={i} className="border-border bg-card">
              <CardHeader>
                <div className="h-6 bg-muted rounded w-3/4 animate-pulse" />
              </CardHeader>
              <CardContent className="space-y-2">
                <div className="h-4 bg-muted rounded w-full animate-pulse" />
                <div className="h-4 bg-muted rounded w-2/3 animate-pulse" />
              </CardContent>
            </Card>
          ))}
        </div>
      ) : (templates || []).length === 0 ? (
        <Card className="border-border bg-card">
          <CardContent className="flex flex-col items-center justify-center py-12">
            <p className="text-muted-foreground text-center">
              Nenhum template cadastrado. Crie seu primeiro template!
            </p>
          </CardContent>
        </Card>
      ) : (
        <div className="grid gap-4 md:grid-cols-2">
          {(templates || []).map((template: Template) => (
            <Card
              key={template.id}
              className={`border-border bg-card hover:shadow-md transition-shadow ${canEditOrDelete(template) ? 'cursor-pointer' : 'cursor-not-allowed opacity-80'}`}
              onClick={() => canEditOrDelete(template) && handleOpenDialog(template)}
            >
              <CardHeader>
                <div className="flex items-start justify-between">
                  <CardTitle className="text-lg">{template.name}</CardTitle>
                  <div className="flex gap-2 items-center">
                    {template.user_id === null && (
                      <Badge variant="secondary" className="bg-blue-800/20 text-blue-300">Padro</Badge>
                    )}
                    {template.type === 'global' && ( // Exibir badge para templates globais
                      <Badge variant="secondary" className="bg-purple-800/20 text-purple-300">Global</Badge>
                    )}
                    {/* REMOVIDO: Badge de categoria */}
                  </div>
                </div>
              </CardHeader>
              <CardContent>
                <CardDescription className="line-clamp-3">
                  {template.content}
                </CardDescription>
              </CardContent>
            </Card>
          ))}
        </div>
      )}

      <Card className="border-border bg-card">
        <CardHeader>
          <CardTitle>Placeholders Disponveis</CardTitle>
          <CardDescription>
            Use estes marcadores em suas mensagens para personalizao automtica
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="grid gap-2 md:grid-cols-2">
            <div className="flex items-center gap-2">
              <code className="px-2 py-1 rounded bg-muted text-sm">
                {"{{customer_name}}"}
              </code>
              <span className="text-sm text-muted-foreground">Nome do cliente</span>
            </div>
            <div className="flex items-center gap-2">
              <code className="px-2 py-1 rounded bg-muted text-sm">
                {"{{plan_name}}"}
              </code>
              <span className="text-sm text-muted-foreground">Nome do plano</span>
            </div>
            <div className="flex items-center gap-2">
              <code className="px-2 py-1 rounded bg-muted text-sm">
                {"{{due_date}}"}
              </code>
              <span className="text-sm text-muted-foreground">Data de vencimento</span>
            </div>
            <div className="flex items-center gap-2">
              <code className="px-2 py-1 rounded bg-muted text-sm">
                {"{{value}}"}
              </code>
              <span className="text-sm text-muted-foreground">Valor da cobrana</span>
            </div>
            {/* NOVO: Placeholder para Chave PIX */}
            <div className="flex items-center gap-2">
              <code className="px-2 py-1 rounded bg-muted text-sm">
                {"{{pix_key}}"}
              </code>
              <span className="text-sm text-muted-foreground">Chave PIX do seu perfil</span>
            </div>
          </div>
        </CardContent>
      </Card>

      <TemplateDialog
        open={dialogOpen}
        onOpenChange={setDialogOpen}
        template={selectedTemplate}
      />
    </div>
  );
}
--- Contedo de: src/hooks/useActiveGateway.ts ---
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { toast } from "sonner";
import { ActivePaymentGateway, ActivePaymentGatewayInsert } from '@/integrations/supabase/schema';
import { useAuth } from '@/contexts/AuthContext';

const SUPABASE_PROJECT_ID = "cgqyfpsfymhntumrmbzj";
const EDGE_FUNCTION_NAME = "crud-active-gateway";
const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

// --- Fetch Active Payment Gateway ---
const fetchActiveGateway = async (): Promise<ActivePaymentGateway | null> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao buscar gateway de pagamento ativo.");
  }

  return response.json();
};

export const useActiveGateway = () => {
  const { user, isLoading: isLoadingAuth } = useAuth(); // Removed role from destructuring
  return useQuery<ActivePaymentGateway | null, Error>({
    queryKey: ["activePaymentGateway", user?.id], // Removed role from query key
    queryFn: fetchActiveGateway,
    enabled: !isLoadingAuth && !!user?.id, // Removed role === 'admin' condition
    staleTime: 1000 * 60 * 5, // Cache por 5 minutos
  });
};

// --- Save Active Payment Gateway (Upsert) ---
const saveActiveGateway = async (gatewayName: string): Promise<ActivePaymentGateway> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const payload: ActivePaymentGatewayInsert = { gateway_name: gatewayName };

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST", // Usamos POST para upsert, a Edge Function lida com a lgica
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao salvar gateway de pagamento ativo.");
  }

  return response.json();
};

export const useSaveActiveGateway = () => {
  const queryClient = useQueryClient();
  return useMutation<ActivePaymentGateway, Error, string>({
    mutationFn: saveActiveGateway,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['activePaymentGateway'] });
      toast.success("Gateway ativo salvo com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao salvar gateway ativo", { description: error.message });
    },
  });
};
--- Contedo de: src/hooks/useAdminFinancialData.ts ---
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
// @ts-ignore
import { AdminFinancialEntry, AdminFinancialEntryInsert, AdminFinancialEntryUpdate, TransactionType } from '@/integrations/supabase/schema';
import { toast } from "sonner";
import { useAuth } from '@/contexts/AuthContext';

// --- Interfaces para dados de resumo e anlise ---
export interface AdminFinancialSummary {
  receivedToday: number;
  receivedThisWeek: number;
  receivedThisMonth: number;
  receivableToday: number;
  receivableTomorrow: number;
  receivableThisWeek: number;
  receivableThisMonth: number;
  lostValueToday: number;
  lostValueThisWeek: number;
  lostValueThisMonth: number;
}

export interface AdminKpis {
  currentMonthRevenue: number;
  previousMonthRevenue: number;
  monthlyGrowthPercentage: number;
  newSubscribersThisMonth: number;
  activeSubscribers: number;
  revenueForecast: number;
}

export interface AdminRevenueData {
  date: string;
  revenue: number;
}

export interface AdminMonthlyRevenueHistory {
  month: string;
  revenue: number;
}

export interface AdminWeeklyRevenue {
  [key: string]: {
    currentMonth: number;
    previousMonth: number;
  };
}

export interface AdminRevenueByPlan {
  planName: string;
  totalRevenue: number;
}

export interface AdminChurnByPlan {
  planName: string;
  lostCount: number;
}

export interface AdminChurnAnalysis {
  lostSubscribersThisMonth: number;
  lostRevenueThisMonth: number;
  churnRate: number;
  churnByPlan: AdminChurnByPlan[];
}

export interface AdminFinancialAnalysis {
  kpis: AdminKpis;
  revenueLast30Days: AdminRevenueData[];
  monthlyRevenueHistory: AdminMonthlyRevenueHistory[];
  weeklyRevenueComparison: AdminWeeklyRevenue;
  revenueByPlan: AdminRevenueByPlan[];
  churnAnalysis: AdminChurnAnalysis;
}

const SUPABASE_PROJECT_ID = "cgqyfpsfymhntumrmbzj";

// --- Fetch Admin Financial Summary ---
const fetchAdminFinancialSummary = async (): Promise<AdminFinancialSummary> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "admin-financial-summary";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao buscar resumo financeiro administrativo.");
  }

  return response.json();
};

export const useAdminFinancialSummary = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();
  return useQuery<AdminFinancialSummary, Error>({
    queryKey: ["adminFinancialSummary", user?.id, role],
    queryFn: fetchAdminFinancialSummary,
    enabled: !isLoadingAuth && !!user?.id && role === 'admin',
    staleTime: 1000 * 60 * 5,
  });
};

// --- Fetch Admin Financial Analysis ---
const fetchAdminFinancialAnalysis = async (): Promise<AdminFinancialAnalysis> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "admin-financial-analysis";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao buscar anlise financeira administrativa.");
  }

  return response.json();
};

export const useAdminFinancialAnalysis = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();
  return useQuery<AdminFinancialAnalysis, Error>({
    queryKey: ["adminFinancialAnalysis", user?.id, role],
    queryFn: fetchAdminFinancialAnalysis,
    enabled: !isLoadingAuth && !!user?.id && role === 'admin',
    staleTime: 1000 * 60 * 5,
  });
};

// --- Fetch Admin Financial Entries (CRUD) ---
const fetchAdminFinancialEntries = async (): Promise<AdminFinancialEntry[]> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "admin-financial-entries";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao buscar extrato financeiro administrativo.");
  }

  return response.json();
};

export const useAdminFinancialEntries = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();
  return useQuery<AdminFinancialEntry[], Error>({
    queryKey: ["adminFinancialEntries", user?.id, role],
    queryFn: fetchAdminFinancialEntries,
    enabled: !isLoadingAuth && !!user?.id && role === 'admin',
    staleTime: 1000 * 60,
  });
};

// --- Create Admin Financial Entry ---
const createAdminFinancialEntry = async (newEntry: AdminFinancialEntryInsert): Promise<AdminFinancialEntry> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "admin-financial-entries";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(newEntry),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao criar lanamento financeiro administrativo.");
  }

  return response.json();
};

export const useCreateAdminFinancialEntry = () => {
  const queryClient = useQueryClient();
  return useMutation<AdminFinancialEntry, Error, AdminFinancialEntryInsert>({
    mutationFn: createAdminFinancialEntry,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['adminFinancialEntries'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialAnalysis'] });
      toast.success("Lanamento financeiro administrativo criado com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao criar lanamento financeiro administrativo", { description: error.message });
    },
  });
};

// --- Update Admin Financial Entry ---
const updateAdminFinancialEntry = async (updatedEntry: AdminFinancialEntryUpdate & { id: string }): Promise<AdminFinancialEntry> => {
  const { id, ...updateData } = updatedEntry;
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "admin-financial-entries";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}?id=${id}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "PUT",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(updateData),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao atualizar lanamento financeiro administrativo.");
  }

  return response.json();
};

export const useUpdateAdminFinancialEntry = () => {
  const queryClient = useQueryClient();
  return useMutation<AdminFinancialEntry, Error, AdminFinancialEntryUpdate & { id: string }>({
    mutationFn: updateAdminFinancialEntry,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['adminFinancialEntries'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialAnalysis'] });
      toast.success("Lanamento financeiro administrativo atualizado com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao atualizar lanamento financeiro administrativo", { description: error.message });
    },
  });
};

// --- Delete Admin Financial Entry ---
const deleteAdminFinancialEntry = async (id: string): Promise<void> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "admin-financial-entries";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}?id=${id}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "DELETE",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao excluir lanamento financeiro administrativo.");
  }
};

export const useDeleteAdminFinancialEntry = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string>({
    mutationFn: deleteAdminFinancialEntry,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['adminFinancialEntries'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialAnalysis'] });
      toast.success("Lanamento financeiro administrativo excludo com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao excluir lanamento financeiro administrativo", { description: error.message });
    },
  });
};
--- Contedo de: src/hooks/useClients.ts ---
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { Client as BaseClient, ClientInsert, ClientUpdate, ClientStatus, Plan } from '@/integrations/supabase/schema';
import { format } from 'date-fns';
import { useAuth } from '@/contexts/AuthContext'; // Import useAuth

// Estender o tipo Client para incluir as propriedades adicionadas no hook
export interface Client extends BaseClient {
  planDetailsValue?: number | null;
  planDetailsName?: string | null;
}

// O tipo Client j  importado de schema.ts, que j inclui a relao com 'plans'.
// No precisamos mais de BaseClient ou de estender Client aqui.

// --- Fetch Clients ---
const fetchClients = async (userId: string, userRole: string | null): Promise<Client[]> => { // Usar o tipo Client estendido
  let query = supabase
    .from('clients')
    .select('*, plans(name, value)') // Seleciona todos os campos do cliente e o 'name' e 'value' do plano
    .order('name');

  // Aplica o filtro APENAS se o usurio NO for admin
  if (userRole !== 'admin') {
    query = query.eq('user_id', userId);
  }

  const { data, error } = await query;

  if (error) throw new Error(error.message);
  
  // Mapeia os dados para incluir o valor e o nome do plano diretamente no objeto do cliente
  return data.map(client => ({
    ...client,
    planDetailsValue: (client.plans as Plan | null)?.value, // Atribui o valor do plano  nova propriedade
    planDetailsName: (client.plans as Plan | null)?.name, // Atribui o nome do plano  nova propriedade
  })) as Client[]; // Adiciona type assertion para garantir que o tipo est correto
};

export const useClients = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth(); // Get user and role from AuthContext

  return useQuery<Client[], Error>({ // Usar o tipo Client estendido
    queryKey: ['clients', user?.id, role], // Add role to query key
    queryFn: () => {
      if (!user?.id) throw new Error("Usurio no autenticado");
      return fetchClients(user.id, role);
    },
    enabled: !isLoadingAuth && !!user?.id, // Only enable if auth is loaded and user is present
  });
};

// --- Create Client ---
const createClient = async (newClient: ClientInsert): Promise<Client> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("Usurio no autenticado");

  const { data, error } = await supabase
    .from('clients')
    .insert({ ...newClient, user_id: user.id })
    .select()
    .single();

  if (error) throw new Error(error.message);
  return data as Client;
};

export const useCreateClient = () => {
  const queryClient = useQueryClient();
  return useMutation<Client, Error, ClientInsert>({
    mutationFn: createClient,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['clients'] });
      queryClient.invalidateQueries({ queryKey: ['dashboardStats'] });
      queryClient.invalidateQueries({ queryKey: ['financialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] });
      queryClient.invalidateQueries({ queryKey: ['automations'] }); // Invalida automaes
    },
  });
};

// --- Update Client ---
const updateClient = async (updatedClient: ClientUpdate & { id: string }): Promise<Client> => {
  const { id, ...updateData } = updatedClient;
  const { data, error } = await supabase
    .from('clients')
    .update(updateData)
    .eq('id', id)
    .select()
    .single();

  if (error) throw new Error(error.message);
  return data as Client;
};

export const useUpdateClient = () => {
  const queryClient = useQueryClient();
  return useMutation<Client, Error, ClientUpdate & { id: string }>({
    mutationFn: updateClient,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['clients'] });
      queryClient.invalidateQueries({ queryKey: ['dashboardStats'] });
      queryClient.invalidateQueries({ queryKey: ['financialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] });
      queryClient.invalidateQueries({ queryKey: ['automations'] }); // Invalida automaes
    },
  });
};

// --- Delete Client ---
const deleteClient = async (id: string): Promise<void> => {
  const { error } = await supabase
    .from('clients')
    .delete()
    .eq('id', id);

  if (error) throw new Error(error.message);
};

export const useDeleteClient = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string>({
    mutationFn: deleteClient,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['clients'] });
      queryClient.invalidateQueries({ queryKey: ['dashboardStats'] });
      queryClient.invalidateQueries({ queryKey: ['financialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] });
      queryClient.invalidateQueries({ queryKey: ['automations'] }); // Invalida automaes
    },
  });
};

// --- Renew Client ---
interface RenewClientParams {
  clientId: string;
  planPeriodDays: number;
  currentNextBillingDate: string;
  clientName: string;
  clientValue: number;
}

const renewClient = async ({ clientId, planPeriodDays, currentNextBillingDate, clientName, clientValue }: RenewClientParams): Promise<void> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("Usurio no autenticado");

  const date = new Date(currentNextBillingDate);
  date.setDate(date.getDate() + planPeriodDays);
  const newNextBillingDate = format(date, 'yyyy-MM-dd');

  const { error: updateError } = await supabase
    .from("clients")
    .update({ next_billing_date: newNextBillingDate, status: "active" })
    .eq("id", clientId);

  if (updateError) throw new Error(updateError.message);

  // Registrar a renovao como uma entrada financeira
  const { error: financialError } = await supabase.from("financial_entries").insert({
    user_id: user.id,
    description: `Renovao - ${clientName}`,
    value: clientValue,
    type: "credit",
  });

  if (financialError) {
    console.error("Erro ao registrar entrada financeira de renovao:", financialError.message);
    throw new Error(`Erro ao registrar entrada financeira: ${financialError.message}`);
  }
};

export const useRenewClient = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, RenewClientParams>({
    mutationFn: renewClient,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['clients'] });
      queryClient.invalidateQueries({ queryKey: ['financialEntries'] }); // Invalida extrato
      queryClient.invalidateQueries({ queryKey: ['financialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] });
      queryClient.invalidateQueries({ queryKey: ['automations'] }); // Invalida automaes
    },
  });
};

// --- Update Client Status ---
interface UpdateClientStatusParams {
  clientId: string;
  newStatus: ClientStatus;
  clientName: string;
  planId: string;
  planName: string;
  clientValue: number;
}

const updateClientStatus = async ({ clientId, newStatus, clientName, planId, planName, clientValue }: UpdateClientStatusParams): Promise<void> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("Usurio no autenticado");

  // Se o status for alterado para 'inactive', registrar evento de churn
  if (newStatus === "inactive") {
    const { error: logError } = await supabase.from("logs").insert({
      user_id: user.id,
      action: "client_churned",
      details: {
        client_id: clientId,
        client_name: clientName,
        plan_id: planId,
        plan_name: planName,
        plan_value: clientValue,
      },
    });
    if (logError) console.error("Erro ao registrar evento de churn:", logError.message);
  }

  const { error } = await supabase
    .from("clients")
    .update({ status: newStatus })
    .eq("id", clientId);

  if (error) throw new Error(error.message);
};

export const useUpdateClientStatus = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, UpdateClientStatusParams>({
    mutationFn: updateClientStatus,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['clients'] });
      queryClient.invalidateQueries({ queryKey: ['dashboardStats'] });
      queryClient.invalidateQueries({ queryKey: ['financialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] });
      queryClient.invalidateQueries({ queryKey: ['automations'] }); // Invalida automaes
    },
  });
};

// --- Set Client Due Today ---
interface SetClientDueTodayParams {
  clientId: string;
  clientName: string;
  currentStatus: ClientStatus;
}

const setClientDueToday = async ({ clientId, currentStatus }: SetClientDueTodayParams): Promise<void> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("Usurio no autenticado");

  const today = format(new Date(), 'yyyy-MM-dd');
  const newStatus = currentStatus === "inactive" ? "active" : currentStatus;

  const { error } = await supabase
    .from("clients")
    .update({ next_billing_date: today, status: newStatus })
    .eq("id", clientId);

  if (error) throw new Error(error.message);
};

export const useSetClientDueToday = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, SetClientDueTodayParams>({
    mutationFn: setClientDueToday,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['clients'] });
      queryClient.invalidateQueries({ queryKey: ['dashboardStats'] });
      queryClient.invalidateQueries({ queryKey: ['financialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] });
      queryClient.invalidateQueries({ queryKey: ['automations'] }); // Invalida automaes
    },
  });
};
--- Contedo de: src/hooks/useDashboardStats.ts ---
import { useQuery } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/contexts/AuthContext'; // Import useAuth

interface Stats {
  totalClients: number;
  activeClients: number;
  totalPlans: number;
  overdueClients: number;
  migrationNeeded?: boolean;
}

const fetchDashboardStats = async (userId: string, userRole: string | null): Promise<Stats> => {
  let clientsQuery = supabase.from("clients").select("*", { count: "exact" });
  let plansQuery = supabase.from("plans").select("*", { count: "exact" });

  // Apply filter ONLY if the user is NOT an admin
  if (userRole !== 'admin') {
    clientsQuery = clientsQuery.eq("user_id", userId);
    plansQuery = plansQuery.eq("user_id", userId);
  }

  const [clientsResult, plansResult] = await Promise.all([
    clientsQuery,
    plansQuery,
  ]);

  if (clientsResult.error) throw new Error(clientsResult.error.message);
  if (plansResult.error) throw new Error(plansResult.error.message);

  const clients = clientsResult.data || [];
  const activeClients = clients.filter((c) => c.status === "active").length;
  const overdueClients = clients.filter((c) => c.status === "overdue").length;

  // Check if schema migration is needed
  try {
    await supabase.functions.invoke('apply-schema-migration');
  } catch (error) {
    console.log('Migration check:', error);
  }

  return {
    totalClients: clientsResult.count || 0,
    activeClients,
    totalPlans: plansResult.count || 0,
    overdueClients,
  };
};

export const useDashboardStats = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth(); // Get user and role from AuthContext

  return useQuery<Stats, Error>({
    queryKey: ['dashboardStats', user?.id, role], // Add role to query key
    queryFn: () => {
      if (!user?.id) throw new Error("Usurio no autenticado");
      return fetchDashboardStats(user.id, role);
    },
    enabled: !isLoadingAuth && !!user?.id, // Only enable if auth is loaded and user is present
    staleTime: 1000 * 60, // 1 minuto de cache
  });
};
--- Contedo de: src/hooks/useEvolutionLogoutHistory.ts ---
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { EvolutionLogoutHistoryEntry, Json } from '@/integrations/supabase/schema';
import { toast } from "sonner";
import { useAuth } from '@/contexts/AuthContext'; // Import useAuth

interface LogEvolutionLogoutPayload {
  requestPayload: Json;
  responsePayload: Json | null;
  statusCode: number | null;
  errorMessage: string | null;
  instanceName: string;
}

const logEvolutionLogoutHistory = async (payload: LogEvolutionLogoutPayload): Promise<EvolutionLogoutHistoryEntry> => {
  const { requestPayload, responsePayload, statusCode, errorMessage, instanceName } = payload;
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error('Usurio no autenticado');

  // Service role bypasses RLS, so no explicit user_id filter needed here.
  const { data, error } = await supabase
    .from('evolution_logout_history')
    .insert({
      user_id: user.id,
      webhook_type: 'n8n_evolution_logout_outbound', // Tipo para logs de logout
      payload: { instanceName, requestPayload, responsePayload, errorMessage },
      request_payload: requestPayload,
      response_payload: responsePayload,
      status_code: statusCode,
    })
    .select()
    .single();

  if (error) {
    console.error('Error inserting into evolution_logout_history:', error.message);
    throw new Error(`Failed to log Evolution logout interaction: ${error.message}`);
  }
  return data as EvolutionLogoutHistoryEntry;
};

export const useLogEvolutionLogoutHistory = () => {
  const queryClient = useQueryClient();
  const { user, role } = useAuth(); // Get user and role from AuthContext

  return useMutation<EvolutionLogoutHistoryEntry, Error, LogEvolutionLogoutPayload>({
    mutationFn: logEvolutionLogoutHistory,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['webhookHistory', 'evolution_logout_history', user?.id, role] }); // Add user.id and role to query key
    },
    onError: (error) => {
      toast.error('Erro ao registrar histrico de logout', { description: error.message });
    },
  });
};
--- Contedo de: src/hooks/useFinancialEntries.ts ---
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { FinancialEntry, FinancialEntryInsert, FinancialEntryUpdate } from '@/integrations/supabase/schema';
import { useAuth } from '@/contexts/AuthContext'; // Import useAuth

// --- Fetch Financial Entries ---
const fetchFinancialEntries = async (userId: string, userRole: string | null): Promise<FinancialEntry[]> => {
  let query = supabase
    .from('financial_entries')
    .select('*')
    .order('created_at', { ascending: false });

  // Aplica o filtro APENAS se o usurio NO for admin
  if (userRole !== 'admin') {
    query = query.eq('user_id', userId);
  }

  const { data, error } = await query;

  if (error) throw new Error(error.message);
  return data || [];
};

export const useFinancialEntries = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth(); // Get user and role from AuthContext

  return useQuery<FinancialEntry[], Error>({
    queryKey: ['financialEntries', user?.id, role], // Add role to query key
    queryFn: () => {
      if (!user?.id) throw new Error("Usurio no autenticado");
      return fetchFinancialEntries(user.id, role);
    },
    enabled: !isLoadingAuth && !!user?.id, // Only enable if auth is loaded and user is present
  });
};

// --- Create Financial Entry ---
const createFinancialEntry = async (newEntry: FinancialEntryInsert): Promise<FinancialEntry> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("Usurio no autenticado");

  const { data, error } = await supabase
    .from('financial_entries')
    .insert({ ...newEntry, user_id: user.id })
    .select()
    .single();

  if (error) throw new Error(error.message);
  return data as FinancialEntry;
};

export const useCreateFinancialEntry = () => {
  const queryClient = useQueryClient();
  return useMutation<FinancialEntry, Error, FinancialEntryInsert>({
    mutationFn: createFinancialEntry,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['financialEntries'] });
      queryClient.invalidateQueries({ queryKey: ['financialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] });
    },
  });
};

// --- Update Financial Entry ---
const updateFinancialEntry = async (updatedEntry: FinancialEntryUpdate & { id: string }): Promise<FinancialEntry> => {
  const { id, ...updateData } = updatedEntry;
  const { data, error } = await supabase
    .from('financial_entries')
    .update(updateData)
    .eq('id', id)
    .select()
    .single();

  if (error) throw new Error(error.message);
  return data as FinancialEntry;
};

export const useUpdateFinancialEntry = () => {
  const queryClient = useQueryClient();
  return useMutation<FinancialEntry, Error, FinancialEntryUpdate & { id: string }>({
    mutationFn: updateFinancialEntry,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['financialEntries'] });
      queryClient.invalidateQueries({ queryKey: ['financialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] });
    },
  });
};

// --- Delete Financial Entry ---
const deleteFinancialEntry = async (id: string): Promise<void> => {
  const { error } = await supabase
    .from('financial_entries')
    .delete()
    .eq('id', id);

  if (error) throw new Error(error.message);
};

export const useDeleteFinancialEntry = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string>({
    mutationFn: deleteFinancialEntry,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['financialEntries'] });
      queryClient.invalidateQueries({ queryKey: ['financialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] });
    },
  });
};
--- Contedo de: src/hooks/useMercadoPagoConfig.ts ---
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { toast } from "sonner";
import { MercadoPagoConfig, MercadoPagoConfigInsert } from '@/integrations/supabase/schema';
import { useAuth } from '@/contexts/AuthContext';

const SUPABASE_PROJECT_ID = "cgqyfpsfymhntumrmbzj";
const EDGE_FUNCTION_NAME = "crud-mercado-pago-configs";
const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

// --- Fetch Mercado Pago Config ---
const fetchMercadoPagoConfig = async (): Promise<MercadoPagoConfig | null> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao buscar configuraes do Mercado Pago.");
  }

  return response.json();
};

export const useMercadoPagoConfig = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();
  return useQuery<MercadoPagoConfig | null, Error>({
    queryKey: ["mercadoPagoConfig", user?.id, role],
    queryFn: fetchMercadoPagoConfig,
    enabled: !isLoadingAuth && !!user?.id && role === 'admin',
    staleTime: 1000 * 60 * 5, // Cache por 5 minutos
  });
};

// --- Save Mercado Pago Config (Upsert) ---
const saveMercadoPagoConfig = async (config: MercadoPagoConfigInsert): Promise<MercadoPagoConfig> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST", // Usamos POST para upsert, a Edge Function lida com a lgica
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(config),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao salvar configuraes do Mercado Pago.");
  }

  return response.json();
};

export const useSaveMercadoPagoConfig = () => {
  const queryClient = useQueryClient();
  return useMutation<MercadoPagoConfig, Error, MercadoPagoConfigInsert>({
    mutationFn: saveMercadoPagoConfig,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['mercadoPagoConfig'] });
      toast.success("Configuraes do Mercado Pago salvas com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao salvar configuraes do Mercado Pago", { description: error.message });
    },
  });
};
--- Contedo de: src/hooks/usePagbankConfig.ts ---
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { toast } from "sonner";
import { useAuth } from '@/contexts/AuthContext';
import { Tables, TablesInsert, TablesUpdate } from '@/integrations/supabase/schema';

// Definir o tipo para a tabela pagbank_configs
export type PagbankConfig = Tables<'pagbank_configs'>;
export type PagbankConfigInsert = TablesInsert<'pagbank_configs'>;
export type PagbankConfigUpdate = TablesUpdate<'pagbank_configs'>;

const SUPABASE_PROJECT_ID = "cgqyfpsfymhntumrmbzj";
const EDGE_FUNCTION_NAME = "crud-pagbank-configs";
const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

// --- Fetch PagBank Config ---
const fetchPagbankConfig = async (): Promise<PagbankConfig | null> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao buscar configuraes do PagBank.");
  }

  return response.json();
};

export const usePagbankConfig = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();
  return useQuery<PagbankConfig | null, Error>({
    queryKey: ["pagbankConfig", user?.id, role],
    queryFn: fetchPagbankConfig,
    enabled: !isLoadingAuth && !!user?.id && role === 'admin',
    staleTime: 1000 * 60 * 5, // Cache por 5 minutos
  });
};

// --- Save PagBank Config (Upsert) ---
const savePagbankConfig = async (config: PagbankConfigInsert): Promise<PagbankConfig> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST", // Usamos POST para upsert, a Edge Function lida com a lgica
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(config),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao salvar configuraes do PagBank.");
  }

  return response.json();
};

export const useSavePagbankConfig = () => {
  const queryClient = useQueryClient();
  return useMutation<PagbankConfig, Error, PagbankConfigInsert>({
    mutationFn: savePagbankConfig,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['pagbankConfig'] });
      toast.success("Configuraes do PagBank salvas com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao salvar configuraes do PagBank", { description: error.message });
    },
  });
};
--- Contedo de: src/hooks/usePlans.ts ---
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { Plan, PlanInsert, PlanUpdate } from '@/integrations/supabase/schema';
import { useAuth } from '@/contexts/AuthContext'; // Import useAuth

// --- Fetch Plans ---
const fetchPlans = async (userId: string, userRole: string | null): Promise<Plan[]> => {
  let query = supabase
    .from('plans')
    .select('*')
    .order('name');

  // Aplica o filtro APENAS se o usurio NO for admin
  if (userRole !== 'admin') {
    query = query.eq('user_id', userId);
  }

  const { data, error } = await query;

  if (error) throw new Error(error.message);
  return data || [];
};

export const usePlans = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth(); // Get user and role from AuthContext

  return useQuery<Plan[], Error>({
    queryKey: ['plans', user?.id, role], // Add role to query key
    queryFn: () => {
      if (!user?.id) throw new Error("Usurio no autenticado");
      return fetchPlans(user.id, role);
    },
    enabled: !isLoadingAuth && !!user?.id, // Only enable if auth is loaded and user is present
  });
};

// --- Create Plan ---
const createPlan = async (newPlan: PlanInsert): Promise<Plan> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("Usurio no autenticado");

  const { data, error } = await supabase
    .from('plans')
    .insert({ ...newPlan, user_id: user.id })
    .select()
    .single();

  if (error) throw new Error(error.message);
  return data as Plan;
};

export const useCreatePlan = () => {
  const queryClient = useQueryClient();
  return useMutation<Plan, Error, PlanInsert>({
    mutationFn: createPlan,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['plans'] });
      queryClient.invalidateQueries({ queryKey: ['dashboardStats'] });
      queryClient.invalidateQueries({ queryKey: ['clients'] }); // Clientes podem precisar de planos atualizados
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] }); // Anlise pode depender de planos
    },
  });
};

// --- Update Plan ---
const updatePlan = async (updatedPlan: PlanUpdate & { id: string }): Promise<Plan> => {
  const { id, ...updateData } = updatedPlan;
  const { data, error } = await supabase
    .from('plans')
    .update(updateData)
    .eq('id', id)
    .select()
    .single();

  if (error) throw new Error(error.message);
  return data as Plan;
};

export const useUpdatePlan = () => {
  const queryClient = useQueryClient();
  return useMutation<Plan, Error, PlanUpdate & { id: string }>({
    mutationFn: updatePlan,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['plans'] });
      queryClient.invalidateQueries({ queryKey: ['dashboardStats'] });
      queryClient.invalidateQueries({ queryKey: ['clients'] }); // Clientes podem precisar de planos atualizados
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] }); // Anlise pode depender de planos
    },
  });
};

// --- Delete Plan ---
const deletePlan = async (id: string): Promise<void> => {
  const { error } = await supabase
    .from('plans')
    .delete()
    .eq('id', id);

  if (error) throw new Error(error.message);
};

export const useDeletePlan = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string>({
    mutationFn: deletePlan,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['plans'] });
      queryClient.invalidateQueries({ queryKey: ['dashboardStats'] });
      queryClient.invalidateQueries({ queryKey: ['clients'] }); // Clientes podem precisar de planos atualizados
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] }); // Anlise pode depender de planos
    },
  });
};
--- Contedo de: src/hooks/useProfileData.ts ---
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { Profile } from '@/integrations/supabase/schema'; // Importar o tipo Profile
import { toast } from "sonner"; // Importar toast

const fetchUserProfile = async (userId: string): Promise<Profile | null> => {
  const { data, error } = await supabase
    .from('profiles')
    .select('*, pix_key, phone, tax_id') // Incluir pix_key, phone e tax_id na seleo
    .eq('id', userId)
    .single();

  if (error && error.code !== 'PGRST116') { // PGRST116 = No rows found
    throw new Error(error.message);
  }
  return data;
};

export const useUserProfile = () => {
  return useQuery<Profile | null, Error>({
    queryKey: ['userProfile'],
    queryFn: async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return null;
      return fetchUserProfile(user.id);
    },
  });
};

// NOVO: Hook para buscar dados de perfil e assinatura combinados
export const useProfileAndSubscriptionData = () => {
    const { data: profile, isLoading: isLoadingProfile, error: profileError } = useUserProfile();

    return useQuery({
        queryKey: ['profileAndSubscription', profile?.id], // Adicionar profile.id para re-fetch quando o perfil mudar
        queryFn: async () => {
            if (!profile) throw new Error('Perfil do usurio no encontrado.');

            // Buscar a assinatura real do usurio
            const { data: subscriptionData, error: subscriptionError } = await supabase
                .from('subscriptions')
                .select('id, plan_name, price, status, next_billing_date')
                .eq('user_id', profile.id)
                .single();

            if (subscriptionError && subscriptionError.code !== 'PGRST116') {
                throw new Error(subscriptionError.message);
            }

            const subscription = subscriptionData ? {
                id: subscriptionData.id,
                planName: subscriptionData.plan_name,
                price: subscriptionData.price,
                nextBillingDate: subscriptionData.next_billing_date,
                status: subscriptionData.status,
            } : null;

            return { profile, subscription };
        },
        enabled: !!profile && !isLoadingProfile && !profileError, // S executa esta query se o perfil j tiver sido carregado
        staleTime: 1000 * 60 * 5, // 5 minutos de cache
    });
};

const useUpdateProfile = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: async ({ name, pix_key, phone, tax_id }: { name: string; pix_key: string | null; phone: string | null; tax_id: string }) => {
            const { data: { user } } = await supabase.auth.getUser();
            if (!user) throw new Error('Utilizador no autenticado');
            
            const { error } = await supabase.from('profiles').update({ name, pix_key, phone, tax_id }).eq('id', user.id);
            if (error) throw new Error(error.message);
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['userProfile'] });
            queryClient.invalidateQueries({ queryKey: ['profileAndSubscription'] });
            toast.success('Perfil atualizado com sucesso!');
        },
        onError: (error) => toast.error(`Erro ao atualizar perfil: ${error.message}`),
    });
};

export { useUpdateProfile }; // Exportar o hook useUpdateProfile
--- Contedo de: src/hooks/useSubscriberManagement.ts ---
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import {
  Profile,
  Enums,
  SubscriberPlan, SubscriberPlanInsert, SubscriberPlanUpdate,
  SubscriberTemplate, SubscriberTemplateInsert, SubscriberTemplateUpdate,
  SubscriberAutomation, SubscriberAutomationInsert, SubscriberAutomationUpdate,
} from '@/integrations/supabase/schema';
import { toast } from "sonner";
import { useAuth } from '@/contexts/AuthContext'; // Corrigido o caminho de importao
import { DateTime } from 'luxon'; // Import Luxon

const SUPABASE_PROJECT_ID = "cgqyfpsfymhntumrmbzj";

// --- Interfaces para dados de usurio (assinante) ---
export interface UserWithDetails extends Profile {
  role: Enums<'app_role'>;
  phone: string | null; // Adicionado o campo phone
  subscription: {
    id: string;
    plan_name: string;
    price: number;
    status: string;
    next_billing_date: string;
  } | null;
  instance: {
    id: string;
    instance_name: string;
    status: string;
  } | null;
}

// --- Fetch All Users (Subscribers) ---
const fetchAllUsers = async (): Promise<UserWithDetails[]> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "list-all-users";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao buscar lista de usurios.");
  }

  return response.json();
};

export const useAllUsers = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();
  return useQuery<UserWithDetails[], Error>({
    queryKey: ["allUsers", user?.id, role],
    queryFn: fetchAllUsers,
    enabled: !isLoadingAuth && !!user?.id && role === 'admin',
    staleTime: 1000 * 60,
  });
};

// --- Update User Role ---
interface UpdateUserRolePayload {
  targetUserId: string;
  newRole: Enums<'app_role'>;
}

const updateUserRole = async (payload: UpdateUserRolePayload): Promise<any> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "update-user-role";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao atualizar funo do usurio.");
  }

  return response.json();
};

export const useUpdateUserRole = () => {
  const queryClient = useQueryClient();
  return useMutation<any, Error, UpdateUserRolePayload>({
    mutationFn: updateUserRole,
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['allUsers'] });
      // Invalidate the specific user's profile and subscription data
      queryClient.invalidateQueries({ queryKey: ['userProfile', variables.targetUserId] });
      queryClient.invalidateQueries({ queryKey: ['profileAndSubscription', variables.targetUserId] });
      toast.success("Funo do usurio atualizada com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao atualizar funo do usurio", { description: error.message });
    },
  });
};

// --- Update User Subscription ---
interface UpdateUserSubscriptionPayload {
  subscriptionId: string;
  userId: string;
  plan_name: string;
  price: number;
  status: string;
  next_billing_date: string;
}

const updateUserSubscription = async (payload: UpdateUserSubscriptionPayload): Promise<any> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "update-user-subscription";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST", // Usando POST para enviar o body
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao atualizar assinatura do usurio.");
  }

  return response.json();
};

export const useUpdateUserSubscription = () => {
  const queryClient = useQueryClient();
  return useMutation<any, Error, UpdateUserSubscriptionPayload>({
    mutationFn: updateUserSubscription,
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['allUsers'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialAnalysis'] });
      // Invalidate the specific user's profile and subscription data
      queryClient.invalidateQueries({ queryKey: ['userProfile', variables.userId] });
      queryClient.invalidateQueries({ queryKey: ['profileAndSubscription', variables.userId] });
      toast.success("Assinatura do usurio atualizada com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao atualizar assinatura do usurio", { description: error.message });
    },
  });
};

// --- Renew Subscriber ---
interface RenewSubscriberParams {
  subscriptionId: string;
  targetUserId: string;
  planName: string;
  currentNextBillingDate: string;
  price: number;
}

const renewSubscriber = async (payload: RenewSubscriberParams): Promise<any> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "renew-subscriber-subscription";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao renovar assinatura do assinante.");
  }

  return response.json();
};

export const useRenewSubscriber = () => {
  const queryClient = useQueryClient();
  return useMutation<any, Error, RenewSubscriberParams>({
    mutationFn: renewSubscriber,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['allUsers'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialEntries'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialAnalysis'] });
      toast.success("Assinatura renovada com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao renovar assinatura", { description: error.message });
    },
  });
};

// --- Set Subscriber Due Today ---
interface SetSubscriberDueTodayParams {
  subscriptionId: string;
  targetUserId: string;
  currentStatus: string;
  price: number;
}

const setSubscriberDueToday = async (payload: SetSubscriberDueTodayParams): Promise<any> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "set-subscriber-due-today";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao definir vencimento para hoje.");
  }

  return response.json();
};

export const useSetSubscriberDueToday = () => {
  const queryClient = useQueryClient();
  return useMutation<any, Error, SetSubscriberDueTodayParams>({
    mutationFn: setSubscriberDueToday,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['allUsers'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialEntries'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialAnalysis'] });
      toast.success("Vencimento da assinatura definido para hoje!");
    },
    onError: (error) => {
      toast.error("Erro ao definir vencimento para hoje", { description: error.message });
    },
  });
};

// --- Delete User ---
const deleteUser = async (targetUserId: string): Promise<void> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session || !session.user) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "delete-user";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify({ targetUserId }),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao excluir usurio.");
  }
};

export const useDeleteUser = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string>({
    mutationFn: deleteUser,
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['allUsers'] });
      // Invalidate the specific user's profile and subscription data
      queryClient.invalidateQueries({ queryKey: ['userProfile', variables] });
      queryClient.invalidateQueries({ queryKey: ['profileAndSubscription', variables] });
      toast.success("Usurio excludo com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao excluir usurio", { description: error.message });
    },
  });
};

// --- Fetch Subscriber Plans ---
const fetchSubscriberPlans = async (): Promise<SubscriberPlan[]> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "crud-subscriber-plans";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao buscar planos de assinantes.");
  }

  return response.json();
};

export const useSubscriberPlans = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();
  return useQuery<SubscriberPlan[], Error>({
    queryKey: ["subscriberPlans", user?.id, role],
    queryFn: fetchSubscriberPlans,
    enabled: !isLoadingAuth && !!user?.id && role === 'admin',
    staleTime: 1000 * 60 * 5,
  });
};

// --- Create Subscriber Plan ---
const createSubscriberPlan = async (newPlan: SubscriberPlanInsert): Promise<SubscriberPlan> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "crud-subscriber-plans";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(newPlan),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao criar plano de assinante.");
  }

  return response.json();
};

export const useCreateSubscriberPlan = () => {
  const queryClient = useQueryClient();
  return useMutation<SubscriberPlan, Error, SubscriberPlanInsert>({
    mutationFn: createSubscriberPlan,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['subscriberPlans'] });
      toast.success("Plano de assinante criado com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao criar plano de assinante", { description: error.message });
    },
  });
};

// --- Update Subscriber Plan ---
const updateSubscriberPlan = async (updatedPlan: SubscriberPlanUpdate & { id: string }): Promise<SubscriberPlan> => {
  console.log('updateSubscriberPlan: Funo de mutao iniciada com payload:', updatedPlan); // Log de depurao
  const { id, ...updateData } = updatedPlan;
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "crud-subscriber-plans";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}?id=${id}`;

  const fetchOptions: RequestInit = {
    method: "PUT",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(updateData),
  };

  console.log('useUpdateSubscriberPlan: Tentando requisio PUT com opes:', fetchOptions); // Log de depurao

  const response = await fetch(EDGE_FUNCTION_URL, fetchOptions);

  if (!response.ok) {
    const errorData = await response.json();
    console.error('useUpdateSubscriberPlan: Falha na requisio com errorData:', errorData); // Log de depurao
    throw new Error(errorData.error || "Erro ao atualizar plano de assinante.");
  }

  return response.json();
};

export const useUpdateSubscriberPlan = () => {
  const queryClient = useQueryClient();
  return useMutation<SubscriberPlan, Error, SubscriberPlanUpdate & { id: string }>({
    mutationFn: updateSubscriberPlan,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['subscriberPlans'] });
      toast.success("Plano de assinante atualizado com sucesso!");
    },
    onError: (error) => {
      console.error("useUpdateSubscriberPlan: Mutao falhou:", error); // Log de depurao
      toast.error("Erro ao atualizar plano de assinante", { description: error.message });
    },
  });
};

// --- Delete Subscriber Plan ---
const deleteSubscriberPlan = async (id: string): Promise<void> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session || !session.user) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "crud-subscriber-plans";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}?id=${id}`;

  const fetchOptions: RequestInit = {
    method: "DELETE",
    headers: {
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: undefined, // Explicitly set body to undefined for DELETE
  };

  console.log('useDeleteSubscriberPlan: Tentando requisio DELETE com opes:', fetchOptions); // Log de depurao

  const response = await fetch(EDGE_FUNCTION_URL, fetchOptions);

  if (!response.ok) {
    const errorData = await response.json();
    console.error('useDeleteSubscriberPlan: Falha na requisio com errorData:', errorData); // Log de depurao
    throw new Error(errorData.error || "Erro ao excluir plano de assinante.");
  }
};

export const useDeleteSubscriberPlan = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string>({
    mutationFn: deleteSubscriberPlan,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['subscriberPlans'] });
      toast.success("Plano de assinante excludo com sucesso!");
    },
    onError: (error) => {
      console.error("useDeleteSubscriberPlan: Mutao falhou:", error); // Log de depurao
      toast.error("Erro ao excluir plano de assinante", { description: error.message });
    },
  });
};

// --- Fetch Subscriber Templates ---
const fetchSubscriberTemplates = async (): Promise<SubscriberTemplate[]> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "crud-subscriber-templates";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao buscar templates de assinantes.");
  }

  return response.json();
};

export const useSubscriberTemplates = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();
  return useQuery<SubscriberTemplate[], Error>({
    queryKey: ["subscriberTemplates", user?.id, role],
    queryFn: fetchSubscriberTemplates,
    enabled: !isLoadingAuth && !!user?.id && role === 'admin',
    staleTime: 1000 * 60 * 5,
  });
};

// --- Create Subscriber Template ---
const createSubscriberTemplate = async (newTemplate: SubscriberTemplateInsert): Promise<SubscriberTemplate> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "crud-subscriber-templates";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(newTemplate),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao criar template de assinante.");
  }

  return response.json();
};

export const useCreateSubscriberTemplate = () => {
  const queryClient = useQueryClient();
  return useMutation<SubscriberTemplate, Error, SubscriberTemplateInsert>({
    mutationFn: createSubscriberTemplate,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['subscriberTemplates'] });
      toast.success("Template de assinante criado com sucesso!");
    },
    onError: (error) => {
      console.error("Erro tcnico ao criar template de assinante:", error); // Log completo
      toast.error("Erro ao criar template de assinante", { description: error.message });
    },
  });
};

// --- Update Subscriber Template ---
const updateSubscriberTemplate = async (updatedTemplate: SubscriberTemplateUpdate & { id: string }): Promise<SubscriberTemplate> => {
  const { id, ...updateData } = updatedTemplate;
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "crud-subscriber-templates";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}?id=${id}`;

  const fetchOptions: RequestInit = {
    method: "PUT",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(updateData),
  };

  console.log('useUpdateSubscriberTemplate: Tentando requisio PUT com opes:', fetchOptions);

  const response = await fetch(EDGE_FUNCTION_URL, fetchOptions);

  if (!response.ok) {
    const errorData = await response.json();
    console.error('useUpdateSubscriberTemplate: Falha na requisio com errorData:', errorData);
    throw new Error(errorData.error || "Erro ao atualizar template de assinante.");
  }

  return response.json();
};

export const useUpdateSubscriberTemplate = () => {
  const queryClient = useQueryClient();
  return useMutation<SubscriberTemplate, Error, SubscriberTemplateUpdate & { id: string }>({
    mutationFn: updateSubscriberTemplate,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['subscriberTemplates'] });
      toast.success("Template de assinante atualizado com sucesso!");
    },
    onError: (error) => {
      console.error("Erro tcnico ao atualizar template de assinante:", error); // Log completo
      toast.error("Erro ao atualizar template de assinante", { description: error.message });
    },
  });
};

// --- Delete Subscriber Template ---
const deleteSubscriberTemplate = async (id: string): Promise<void> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session || !session.user) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "crud-subscriber-templates";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}?id=${id}`;

  const fetchOptions: RequestInit = {
    method: "DELETE",
    headers: {
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: undefined, // Explicitly set body to undefined for DELETE
  };

  console.log('useDeleteSubscriberTemplate: Tentando requisio DELETE com opes:', fetchOptions);

  const response = await fetch(EDGE_FUNCTION_URL, fetchOptions);

  if (!response.ok) {
    const errorData = await response.json();
    console.error('useDeleteSubscriberTemplate: Falha na requisio com errorData:', errorData);
    throw new Error(errorData.error || "Erro ao excluir template de assinante.");
  }
};

export const useDeleteSubscriberTemplate = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string>({
    mutationFn: deleteSubscriberTemplate,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['subscriberTemplates'] });
      toast.success("Template de assinante excludo com sucesso!");
    },
    onError: (error) => {
      console.error("Erro tcnico ao excluir template de assinante:", error); // Log completo
      toast.error("Erro ao excluir template de assinante", { description: error.message });
    },
  });
};

// --- Fetch Subscriber Automations ---
const fetchSubscriberAutomations = async (): Promise<SubscriberAutomation[]> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const EDGE_FUNCTION_NAME = "crud-subscriber-automations";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao buscar automaes de assinantes.");
  }

  return response.json();
};

export const useSubscriberAutomations = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();
  return useQuery<SubscriberAutomation[], Error>({
    queryKey: ["subscriberAutomations", user?.id, role],
    queryFn: fetchSubscriberAutomations,
    enabled: !isLoadingAuth && !!user?.id && role === 'admin',
    staleTime: 1000 * 60,
  });
};

// --- Schedule Subscriber Notifications for Rule ---
interface ScheduleSubscriberNotificationsPayload {
  automation: SubscriberAutomation;
  subscribers: UserWithDetails[]; // Lista completa de usurios/assinantes
}

const scheduleSubscriberNotificationsForRule = async (payload: ScheduleSubscriberNotificationsPayload) => {
  const { automation, subscribers } = payload;
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("Usurio no autenticado.");

  const notificationsToInsert: { user_id: string; subscriber_template_id: string; send_at: string; status: 'pending' }[] = [];
  const SAO_PAULO_TIMEZONE = 'America/Sao_Paulo';
  const [scheduledHour, scheduledMinute] = automation.scheduled_time.split(':').map(Number);
  const now = DateTime.now();

  const relevantSubscribers = subscribers.filter(s =>
    automation.subscriber_ids.includes(s.id) && s.subscription?.status === 'active'
  );

  for (const subscriber of relevantSubscribers) {
    if (!subscriber.subscription?.next_billing_date) continue;

    // A data do Supabase vem como 'YYYY-MM-DD'. Tratar como data local.
    const localBillingDate = DateTime.fromISO(subscriber.subscription.next_billing_date, { zone: SAO_PAULO_TIMEZONE }).startOf('day');
    const targetDate = localBillingDate.plus({ days: automation.days_offset });

    const localTargetDateTime = targetDate.set({
        hour: scheduledHour,
        minute: scheduledMinute
    });

    const sendAtUtcIso = localTargetDateTime.toUTC().toISO();

    if (!sendAtUtcIso) {
        console.warn(`Skipping notification for subscriber ${subscriber.id} due to invalid date/time conversion.`);
        continue;
    }

    if (localTargetDateTime.toMillis() >= now.toMillis() - (60 * 1000)) {
        notificationsToInsert.push({
            user_id: subscriber.id,
            subscriber_template_id: automation.subscriber_template_id,
            send_at: sendAtUtcIso,
            status: 'pending',
        });
    }
  }

  if (notificationsToInsert.length === 0) {
      console.log("Nenhuma notificao futura para agendar para esta regra de assinante.");
      return { success: true, message: 'Nenhuma notificao futura para agendar.' };
  }

  const EDGE_FUNCTION_NAME = "schedule-subscriber-notifications";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
      method: "POST",
      headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${session.access_token}`,
      },
      body: JSON.stringify({ automationId: automation.id, notifications: notificationsToInsert }),
  });

  if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || "Erro ao invocar a Edge Function de agendamento de assinantes.");
  }

  return response.json();
};

export const useScheduleSubscriberNotificationsForRule = () => {
  const queryClient = useQueryClient();
  return useMutation<any, Error, ScheduleSubscriberNotificationsPayload>({
    mutationFn: scheduleSubscriberNotificationsForRule,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['scheduledNotifications'] }); // Invalida para atualizar a lista de agendamentos
      queryClient.invalidateQueries({ queryKey: ['connectionMetrics'] }); // Invalida mtricas para atualizar contagem de agendados
      toast.success('Fila de envios para assinantes agendada com sucesso!');
    },
    onError: (error) => toast.error(`Erro ao agendar fila de envios para assinantes: ${error.message}`),
  });
};

// --- Create Subscriber Automation ---
export const useCreateSubscriberAutomation = () => {
  const queryClient = useQueryClient();
  const scheduleMutation = useScheduleSubscriberNotificationsForRule();
  const { data: allUsers } = useAllUsers(); // Obter todos os usurios para calcular notificaes

  return useMutation<SubscriberAutomation, Error, SubscriberAutomationInsert>({
    mutationFn: async (newAutomationData) => {
      const { data: { session } } = await supabase.auth.getSession(); // Use getSession
      if (!session || !session.user) throw new Error("Usurio no autenticado"); // Check session and user

      const { data, error } = await supabase
        .from('subscriber_automations')
        .insert({ ...newAutomationData, admin_user_id: session.user.id })
        .select()
        .single();

      if (error) throw new Error(error.message);
      return data as SubscriberAutomation;
    },
    onSuccess: async (newAutomation) => {
      queryClient.invalidateQueries({ queryKey: ['subscriberAutomations'] });
      queryClient.invalidateQueries({ queryKey: ['connectionMetrics'] });
      toast.success('Automao de assinante criada!');

      if (allUsers) {
        await scheduleMutation.mutateAsync({
          automation: newAutomation,
          subscribers: allUsers,
        });
      }
    },
    onError: (error) => toast.error(`Erro ao criar automao de assinante: ${error.message}`),
  });
};

// --- Update Subscriber Automation ---
export const useUpdateSubscriberAutomation = () => {
  const queryClient = useQueryClient();
  const scheduleMutation = useScheduleSubscriberNotificationsForRule();
  const { data: allUsers } = useAllUsers(); // Obter todos os usurios para calcular notificaes

  return useMutation<SubscriberAutomation, Error, SubscriberAutomationUpdate & { id: string }>({
    mutationFn: async (updatedAutomationData) => {
      const { id, ...updateData } = updatedAutomationData;
      const { data: { session } } = await supabase.auth.getSession(); // Use getSession
      if (!session || !session.user) throw new Error("Usurio no autenticado"); // Check session and user

      const { data, error } = await supabase
        .from('subscriber_automations')
        .update(updateData)
        .eq('id', id)
        .eq('admin_user_id', session.user.id) // Garante que o admin s atualiza suas prprias automaes
        .select()
        .single();

      if (error) throw new Error(error.message);
      return data as SubscriberAutomation;
    },
    onSuccess: async (updatedAutomation) => {
      queryClient.invalidateQueries({ queryKey: ['subscriberAutomations'] });
      queryClient.invalidateQueries({ queryKey: ['connectionMetrics'] });
      toast.success('Automao de assinante atualizada!');

      if (allUsers) {
        await scheduleMutation.mutateAsync({
          automation: updatedAutomation,
          subscribers: allUsers,
        });
      }
    },
    onError: (error) => toast.error(`Erro ao atualizar automao de assinante: ${error.message}`),
  });
};

// --- Delete Subscriber Automation ---
const deleteSubscriberAutomation = async (id: string): Promise<void> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session || !session.user) throw new Error("Usurio no autenticado.");

  // Deleta agendamentos pendentes associados a esta automao
  await supabase
    .from('scheduled_notifications')
    .delete()
    .eq('automation_id', id)
    .eq('user_id', session.user.id) // Garante que o admin s deleta seus prprios agendamentos
    .eq('type', 'subscriber_notification'); // Filtra pelo tipo correto

  const { error } = await supabase
    .from('subscriber_automations')
    .delete()
    .eq('id', id)
    .eq('admin_user_id', session.user.id); // Garante que o admin s deleta suas prprias automaes

  if (error) throw new Error(error.message);
};

export const useDeleteSubscriberAutomation = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string>({
    mutationFn: deleteSubscriberAutomation,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['subscriberAutomations'] });
      queryClient.invalidateQueries({ queryKey: ['connectionMetrics'] });
      queryClient.invalidateQueries({ queryKey: ['scheduledNotifications'] });
      toast.success('Automao de assinante excluda e agendamentos removidos!');
    },
    onError: (error) => toast.error(`Erro ao excluir automao de assinante: ${error.message}`),
  });
};

// --- Hook para buscar a URL do webhook de envio de mensagens (reutilizado do useClients) ---
const fetchN8nMessageSenderUrl = async (): Promise<string | null> => {
  const { data: { session } } = await supabase.auth.getSession(); // Obter a sesso
  if (!session || !session.user) throw new Error('Usurio no autenticado');

  const { data, error } = await supabase
    .from('webhook_configs')
    .select('url')
    .eq('type', 'n8n_message_sender')
    .maybeSingle();

  if (error) throw error;
  return data?.url || null;
};

export const useN8nMessageSenderUrl = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();
  return useQuery<string | null, Error>({
    queryKey: ['n8nMessageSenderUrl', user?.id, role],
    queryFn: fetchN8nMessageSenderUrl,
    enabled: !isLoadingAuth && !!user?.id && role === 'admin', // Apenas admins podem usar este webhook
    staleTime: 1000 * 60 * 5,
  });
};

// --- Hook de mutao para enviar a mensagem via webhook para assinantes ---
interface SendSubscriberMessagePayload {
  n8nWebhookUrl: string;
  subscriber: UserWithDetails;
  templateId: string;
  renderedTextContent: string;
}

const sendSubscriberMessageViaWebhook = async ({ n8nWebhookUrl, subscriber, templateId, renderedTextContent }: SendSubscriberMessagePayload) => {
  const { data: { user: adminUser } } = await supabase.auth.getUser();
  if (!adminUser) throw new Error('Administrador no autenticado');

  // Buscar o instanceName do administrador logado
  const { data: adminUserInstance, error: instanceError } = await supabase
    .from('user_instances')
    .select('instance_name')
    .eq('user_id', adminUser.id)
    .single();

  if (instanceError || !adminUserInstance?.instance_name) {
    throw new Error('Nenhuma instncia do WhatsApp configurada para o administrador. Por favor, conecte o WhatsApp em "Conexo > WhatsApp".');
  }
  const instanceName = adminUserInstance.instance_name;

  const requestBody = {
    body: [
      {
        instanceName: instanceName,
        contact_name: subscriber.name,
        number: subscriber.phone, // Usar o telefone do perfil do assinante
        text: renderedTextContent,
        mode: "real"
      }
    ]
  };

  let statusCode: number | null = null;
  let responsePayload: any = null;
  let errorMessage: string | null = null;

  try {
    const response = await fetch(n8nWebhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody),
    });

    statusCode = response.status;
    
    try {
      responsePayload = await response.json();
    } catch (jsonError) {
      responsePayload = await response.text();
      console.warn("Webhook response was not JSON, read as text.", jsonError);
    }

    if (!response.ok) {
      errorMessage = responsePayload?.message || response.statusText || `O servidor de automao retornou um erro com status ${statusCode}.`;
      throw new Error(errorMessage || 'An unknown error occurred during webhook processing.');
    }

    return { success: true, statusCode };

  } catch (error: any) {
    errorMessage = error.message;
    console.error("Erro ao enviar mensagem via webhook para assinante:", error);
    throw new Error(errorMessage || 'An unknown error occurred.');
  } finally {
    await supabase
      .from('n8n_message_sender_history')
      .insert({
        user_id: adminUser.id, // ID do administrador que enviou
        client_id: subscriber.id, // ID do assinante (que  um user_id)
        template_id: templateId,
        webhook_type: 'n8n_message_outbound_subscriber', // Novo tipo para diferenciar
        payload: requestBody,
        request_payload: requestBody,
        response_payload: responsePayload,
        status_code: statusCode,
        client_name_snapshot: subscriber.name, // Snapshot do nome do assinante
      });
  }
};

export const useSendSubscriberMessageWebhook = () => {
  const queryClient = useQueryClient();
  return useMutation<any, Error, SendSubscriberMessagePayload>({
    mutationFn: sendSubscriberMessageViaWebhook,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['webhookHistory', 'n8n_message_sender_history', 'n8n_message_outbound_subscriber'] });
    },
  });
};
--- Contedo de: src/hooks/useTemplates.ts ---
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";
import { Tables } from "@/integrations/supabase/schema"; // Importar Tables do schema

// Tipos para os dados do template
export interface Template extends Tables<'templates'> {
  // A interface Tables<'templates'> j inclui todos os campos e a tipagem correta (user_id: string | null)
  // No precisamos redefinir os campos aqui, apenas estender para garantir que o tipo seja o esperado.
}

// Hook para buscar todos os templates do usurio
export const useTemplates = () => {
  return useQuery<Template[], Error>({
    queryKey: ["templates"],
    queryFn: async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error("Utilizador no autenticado");

      // Verificar se o perfil do usurio existe
      const { data: _profileData, error: profileError } = await supabase // Renomeado para _profileData
        .from("profiles")
        .select("id, name, email, tax_id")
        .eq("id", user.id)
        .single();

      if (profileError && profileError.code === 'PGRST116') { // No rows found
        // Perfil no existe, criar um novo
        const { error: insertProfileError } = await supabase.from("profiles").insert({
          id: user.id,
          email: user.email!, // O email do usurio  obrigatrio
          name: user.user_metadata?.full_name || user.email!, // Usar o nome completo se disponvel, caso contrrio, o email
          phone: null, // Inicializar phone como null
          pix_key: null, // Inicializar pix_key como null
          tax_id: "", // Inicializar tax_id como uma string vazia, pois  um campo obrigatrio
        });

        if (insertProfileError) {
          console.error("Erro ao criar perfil:", insertProfileError.message);
          throw new Error("Erro ao criar perfil do usurio.");
        }
      } else if (profileError) {
        console.error("Erro ao buscar perfil:", profileError.message);
        throw new Error("Erro ao buscar perfil do usurio.");
      }

      const { data, error } = await supabase
        .from("templates")
        .select("*")
        .or(`user_id.eq.${user.id},type.eq.global,user_id.is.null`) // MODIFICADO: Incluir templates do usurio, globais e padro (user_id nulo)
        .order("created_at", { ascending: false });

      if (error) throw new Error(error.message);
      return data as Template[]; // Adicionar type assertion
    },
  });
};

// Hook para criar um novo template
export const useCreateTemplate = () => {
  const queryClient = useQueryClient();
  return useMutation<Template, Error, Omit<Tables<'templates'>, "id" | "created_at" | "updated_at">>({
    mutationFn: async (newTemplate) => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error("Utilizador no autenticado");

      const { data, error } = await supabase
        .from("templates")
        .insert({ ...newTemplate, user_id: user.id })
        .select()
        .single();

      if (error) throw new Error(error.message);
      return data as Template; // Adicionar type assertion
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["templates"] });
      toast.success("Template criado com sucesso!");
    },
    onError: (error) => toast.error(`Erro ao criar template: ${error.message}`),
  });
};

// Hook para atualizar um template existente
export const useUpdateTemplate = () => {
  const queryClient = useQueryClient();
  return useMutation<Template, Error, Partial<Tables<'templates'>> & { id: string }>({
    mutationFn: async (updatedTemplate) => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error("Utilizador no autenticado");

      const { id, ...updates } = updatedTemplate;
      const { data, error } = await supabase
        .from("templates")
        .update(updates)
        .eq("id", id!)
        .eq("user_id", user.id)
        .select()
        .single();

      if (error) throw new Error(error.message);
      return data as Template; // Adicionar type assertion
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["templates"] });
      toast.success("Template atualizado com sucesso!");
    },
    onError: (error) => toast.error(`Erro ao atualizar template: ${error.message}`),
  });
};

// Hook para deletar um template
export const useDeleteTemplate = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string>({
    mutationFn: async (templateId) => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error("Utilizador no autenticado");

      const { error } = await supabase
        .from("templates")
        .delete()
        .eq("id", templateId)
        .eq("user_id", user.id);

      if (error) throw new Error(error.message);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["templates"] });
      toast.success("Template deletado com sucesso!");
    },
    onError: (error) => toast.error(`Erro ao deletar template: ${error.message}`),
  });
};
--- Contedo de: src/hooks/useWebhookConfig.ts ---
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { WebhookConfig } from '@/integrations/supabase/schema';
import { toast } from "sonner";
// Removed: import { useAuth } from '@/contexts/AuthContext'; // Import useAuth

// A interface WebhookConfig j  exportada do schema.ts

const fetchWebhookConfig = async (type: string): Promise<WebhookConfig | null> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error('Usurio no autenticado');

  // RLS will handle access based on role. For SELECT, any authenticated user can read.
  const { data, error } = await supabase
    .from('webhook_configs')
    .select('*')
    .eq('type', type) // Removed .eq('user_id', user.id)
    .maybeSingle();

  if (error) throw error;
  return data;
};

export const useWebhookConfig = (type: string) => {
  return useQuery<WebhookConfig | null, Error>({
    queryKey: ['webhookConfig', type],
    queryFn: () => fetchWebhookConfig(type),
  });
};

const saveWebhookConfig = async (type: string, url: string): Promise<WebhookConfig> => {
  const { data: { session } } = await supabase.auth.getSession(); // Corrected: Destructure 'session'
  if (!session || !session.user) throw new Error('Usurio no autenticado'); // Corrected: Check 'session' and 'session.user'

  // The user_id is still passed, but RLS will ensure only admins can perform upsert.
  const { data, error } = await supabase
    .from('webhook_configs')
    .upsert({
      user_id: session.user.id, // user_id is still a column, but RLS controls who can modify it
      type,
      url,
      payload: {}, // Adicionado para satisfazer o campo 'payload' obrigatrio
    }, {
      onConflict: 'type' // Changed onConflict to 'type' since it's global per type
    })
    .select()
    .single();

  if (error) throw error;
  return data;
};

export const useSaveWebhookConfig = () => {
  const queryClient = useQueryClient();

  return useMutation<WebhookConfig, Error, { type: string; url: string }>({
    mutationFn: ({ type, url }) => saveWebhookConfig(type, url),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['webhookConfig', variables.type] });
      toast.success('Configurao salva!', { description: 'URL do webhook atualizada com sucesso.' });
    },
    onError: (error) => {
      toast.error('Erro ao salvar', { description: error.message });
    },
  });
};
--- Contedo de: src/hooks/useWebhookHistory.ts ---
import { useQuery } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { Json } from '@/integrations/supabase/schema'; // Importar Json do schema
import { useAuth } from '@/contexts/AuthContext'; // Import useAuth

// Definir uma interface base que todas as tabelas de histrico devem seguir
interface BaseHistoryEntry {
  id: string;
  user_id: string | null; // Pode ser null se o user_id no for encontrado no momento do log
  webhook_type: string;
  payload: Json;
  request_payload: Json | null;
  response_payload: Json | null;
  status_code: number | null;
  timestamp: string;
  client_id: string | null;
  template_id: string | null;
  client_name_snapshot: string | null;
}

// Definir os nomes das tabelas de histrico permitidos
type HistoryTableNames = 'evolution_api_history' | 'n8n_qr_code_history' | 'n8n_message_sender_history' | 'webhook_history' | 'evolution_logout_history';

// A funo de fetch agora  genrica e retorna um array do tipo T
const fetchWebhookHistory = async <T extends BaseHistoryEntry>(
  tableName: HistoryTableNames,
  webhookTypes: string | string[] | null,
  userId: string,
  userRole: string | null
): Promise<T[]> => {
  let query = supabase
    .from(tableName)
    .select('*');

  // Apply filter ONLY if the user is NOT an admin
  if (userRole !== 'admin') {
    query = query.eq('user_id', userId);
  }

  if (webhookTypes && (Array.isArray(webhookTypes) ? webhookTypes.length > 0 : true)) {
    const types = Array.isArray(webhookTypes) ? webhookTypes : [webhookTypes];
    query = query.in('webhook_type', types);
  }

  const { data, error } = await query
    .order('timestamp', { ascending: false })
    .limit(50);

  if (error) {
    console.error(`Error fetching webhook history from ${tableName}:`, error.message);
    throw new Error(`Failed to fetch history from ${tableName}: ${error.message}`);
  }
  return data as T[] || [];
};

// O hook useWebhookHistory tambm  genrico
export const useWebhookHistory = <T extends BaseHistoryEntry>(
  tableName: HistoryTableNames,
  webhookTypes?: string | string[] | null
) => {
  const { user, role, isLoading: isLoadingAuth } = useAuth(); // Get user and role from AuthContext

  const typesKey = Array.isArray(webhookTypes) ? webhookTypes.join(',') : (webhookTypes === null ? 'all_inbound' : webhookTypes || 'all');
  
  return useQuery<T[], Error>({
    queryKey: ['webhookHistory', tableName, typesKey, user?.id, role], // Add user.id and role to query key
    queryFn: () => {
      if (!user?.id) throw new Error("Usurio no autenticado");
      return fetchWebhookHistory<T>(tableName, webhookTypes || null, user.id, role); // Explicitly pass null if webhookTypes is undefined
    },
    enabled: !isLoadingAuth && !!user?.id, // Only enable if auth is loaded and user is present
    refetchInterval: 5000, // Atualiza a cada 5 segundos
  });
};======================================
  7. SCHEMA COMPLETO COM POLTICAS DE SEGURANA (RLS)
======================================



SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


CREATE EXTENSION IF NOT EXISTS "pg_cron" WITH SCHEMA "pg_catalog";






COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "pg_net" WITH SCHEMA "public";






CREATE EXTENSION IF NOT EXISTS "http" WITH SCHEMA "public";






CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE TYPE "public"."app_role" AS ENUM (
    'admin',
    'user'
);


ALTER TYPE "public"."app_role" OWNER TO "postgres";


CREATE TYPE "public"."client_status" AS ENUM (
    'active',
    'inactive',
    'overdue'
);


ALTER TYPE "public"."client_status" OWNER TO "postgres";


CREATE TYPE "public"."pagbank_environment" AS ENUM (
    'sandbox',
    'production'
);


ALTER TYPE "public"."pagbank_environment" OWNER TO "postgres";


CREATE TYPE "public"."template_type" AS ENUM (
    'normal',
    'global'
);


ALTER TYPE "public"."template_type" OWNER TO "postgres";


CREATE TYPE "public"."transaction_type" AS ENUM (
    'credit',
    'debit'
);


ALTER TYPE "public"."transaction_type" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_client_cancellation"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  -- A funo s executa se o status foi alterado PARA 'inactive'
  IF NEW.status = 'inactive' AND OLD.status != 'inactive' THEN
    
    -- Ao 1: Remover o cliente de todas as futuras mensagens agendadas
    DELETE FROM public.pending_sends
    WHERE client_id = NEW.id;

    -- Ao 2: Remover o ID do cliente de todas as regras de automao
    -- onde ele possa estar presente.
    UPDATE public.automations
    SET client_ids = array_remove(client_ids, NEW.id)
    WHERE user_id = NEW.user_id AND NEW.id = ANY(client_ids);

  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_client_cancellation"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_client_overdue_status"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  -- A funo s executa se o status foi alterado PARA 'overdue'
  IF NEW.status = 'overdue' AND OLD.status != 'overdue' THEN
    
    -- Ao: Remove o cliente de todas as futuras mensagens agendadas
    DELETE FROM public.pending_sends
    WHERE client_id = NEW.id;

  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_client_overdue_status"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  default_plan RECORD;
BEGIN
  -- 1. Inserir na tabela profiles
  INSERT INTO public.profiles (id, name, email, phone) -- Adicionado 'phone'
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'name', split_part(NEW.email, '@', 1)),
    NEW.email,
    NEW.raw_user_meta_data->>'phone' -- Tenta pegar o telefone do metadata
  );

  -- 2. Inserir na tabela user_roles
  INSERT INTO public.user_roles (user_id, role)
  VALUES (NEW.id, 'user');

  -- 3. Buscar o "Plano Inicial" dinamicamente
  SELECT name, value, period_days
  INTO default_plan
  FROM public.subscriber_plans
  WHERE name = 'Plano Inicial'
  LIMIT 1;

  -- 4. Inserir na tabela subscriptions usando o Plano Inicial
  IF default_plan IS NOT NULL THEN
    INSERT INTO public.subscriptions (user_id, plan_name, price, status, next_billing_date)
    VALUES (
      NEW.id,
      default_plan.name,
      default_plan.value,
      'active',
      (NOW() + (default_plan.period_days || ' days')::INTERVAL)::date
    );
  ELSE
    -- Fallback: Se o Plano Inicial no existir, usar valores padro
    INSERT INTO public.subscriptions (user_id, plan_name, price, status, next_billing_date)
    VALUES (NEW.id, 'Plano Gratuito', 0.00, 'active', (NOW() + INTERVAL '30 days')::date);
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_new_user"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."prevent_default_plan_deletion"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  IF OLD.name = 'Plano Inicial' THEN
    RAISE EXCEPTION 'No  permitido excluir o Plano Inicial. Voc pode edit-lo se necessrio.';
  END IF;
  RETURN OLD;
END;
$$;


ALTER FUNCTION "public"."prevent_default_plan_deletion"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_automated_notifications"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
    current_utc_hour INTEGER := EXTRACT(HOUR FROM NOW() AT TIME ZONE 'UTC');
    automation_record RECORD;
    client_record RECORD;
    template_content TEXT;
    n8n_webhook_url TEXT;
    rendered_message TEXT;
    request_body JSONB;
    http_response_status_code INTEGER;
    http_response_body TEXT;
    user_id_for_log UUID;
BEGIN
    -- Get the n8n webhook URL once
    SELECT url INTO n8n_webhook_url
    FROM public.webhook_configs
    WHERE type = 'n8n_message_sender'
    LIMIT 1;

    IF n8n_webhook_url IS NULL THEN
        RAISE WARNING 'N8N message sender webhook URL not configured. Skipping automated notifications.';
        RETURN;
    END IF;

    -- Loop through automations matching the current UTC hour
    FOR automation_record IN
        SELECT
            a.id AS automation_id,
            a.user_id,
            a.days_offset,
            a.template_id,
            a.client_ids,
            t.content AS template_content,
            p.name AS plan_name_placeholder, -- Placeholder for plan name
            p.value AS plan_value_placeholder -- Placeholder for plan value
        FROM
            public.automations a
        JOIN
            public.templates t ON a.template_id = t.id
        LEFT JOIN
            public.plans p ON t.id = p.id -- Join with plans to get plan details if template is related
        WHERE
            EXTRACT(HOUR FROM a.scheduled_time) = current_utc_hour
    LOOP
        user_id_for_log := automation_record.user_id;

        -- Loop through clients associated with this automation
        FOR client_record IN
            SELECT
                c.id AS client_id,
                c.name AS customer_name,
                c.phone,
                c.value,
                c.next_billing_date,
                cp.name AS client_plan_name, -- Actual plan name from client's plan_id
                cp.value AS client_plan_value -- Actual plan value from client's plan_id
            FROM
                public.clients c
            LEFT JOIN
                public.plans cp ON c.plan_id = cp.id
            WHERE
                c.id = ANY(automation_record.client_ids)
                AND c.user_id = automation_record.user_id
                AND c.status IN ('active', 'overdue')
                AND c.next_billing_date = (CURRENT_DATE + (automation_record.days_offset * INTERVAL '1 day'))::DATE
        LOOP
            -- Replace placeholders
            rendered_message := REPLACE(automation_record.template_content, '{{customer_name}}', client_record.customer_name);
            rendered_message := REPLACE(rendered_message, '{{plan_name}}', COALESCE(client_record.client_plan_name, 'Plano Desconhecido'));
            rendered_message := REPLACE(rendered_message, '{{due_date}}', TO_CHAR(client_record.next_billing_date, 'DD/MM/YYYY'));
            rendered_message := REPLACE(rendered_message, '{{value}}', TO_CHAR(client_record.value, 'FM999G999G999D00'));

            -- Construct request body for n8n
            request_body := JSONB_BUILD_OBJECT(
                'body', JSONB_BUILD_ARRAY(
                    JSONB_BUILD_OBJECT(
                        'contact_name', client_record.customer_name,
                        'number', client_record.phone,
                        'text', rendered_message,
                        'mode', 'real'
                    )
                )
            );

            -- Make HTTP POST request to n8n
            BEGIN
                SELECT status, content INTO http_response_status_code, http_response_body
                FROM http_post(
                    n8n_webhook_url,
                    request_body::TEXT,
                    'application/json'
                );

                -- Log to webhook_history
                INSERT INTO public.webhook_history (user_id, webhook_type, payload, status_code, timestamp)
                VALUES (
                    user_id_for_log,
                    'n8n_message_outbound_automated',
                    request_body,
                    http_response_status_code,
                    NOW()
                );

            EXCEPTION
                WHEN OTHERS THEN
                    RAISE WARNING 'Error sending automated notification for client %: %', client_record.client_id, SQLERRM;
                    -- Log error to webhook_history
                    INSERT INTO public.webhook_history (user_id, webhook_type, payload, status_code, timestamp)
                    VALUES (
                        user_id_for_log,
                        'n8n_message_outbound_automated',
                        request_body,
                        500, -- Internal Server Error for HTTP call failure
                        NOW()
                    );
            END;

        END LOOP;
    END LOOP;
END;
$$;


ALTER FUNCTION "public"."process_automated_notifications"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_notification_queue"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    notification_record RECORD;
    edge_function_url TEXT;
    supabase_project_id TEXT := 'cgqyfpsfymhntumrmbzj';
    edge_function_name TEXT := 'send-scheduled-notification';
BEGIN
    RAISE NOTICE 'DEBUG: Iniciando process_notification_queue (verso http_request)...';

    edge_function_url := 'https://' || supabase_project_id || '.supabase.co/functions/v1/' || edge_function_name;

    FOR notification_record IN
        SELECT id FROM public.scheduled_notifications
        WHERE status = 'pending' AND send_at <= NOW()
        FOR UPDATE SKIP LOCKED
    LOOP
        RAISE NOTICE 'DEBUG: Processando notificao ID: %', notification_record.id;

        -- CORREO: Nome da tabela corrigido de 'public.scheduled.notifications' para 'public.scheduled_notifications'
        UPDATE public.scheduled_notifications
        SET status = 'processing'
        WHERE id = notification_record.id;

        -- Usando a construo explcita do objeto http_request com a schema 'extensions'
        PERFORM extensions.http((
            'POST',
            edge_function_url,
            ARRAY[extensions.http_header('Content-Type', 'application/json')],
            'application/json',
            jsonb_build_object('id', notification_record.id)::text
        )::extensions.http_request);

        RAISE NOTICE 'DEBUG: Notificao ID % delegada para a Edge Function.', notification_record.id;
    END LOOP;

    RAISE NOTICE 'DEBUG: Finalizado o processamento da fila.';
END;
$$;


ALTER FUNCTION "public"."process_notification_queue"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_client_status_based_on_due_date"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
DECLARE
  local_today DATE;
BEGIN
  -- Obtm a data de hoje no fuso horrio 'America/Sao_Paulo'
  local_today := (NOW() AT TIME ZONE 'America/Sao_Paulo')::DATE;

  -- Apenas atualiza o status se no for 'inactive' (cancelado)
  IF NEW.status != 'inactive' THEN
    -- Se a data de vencimento for anterior a local_today, define o status como 'overdue'
    IF NEW.next_billing_date < local_today THEN
      NEW.status := 'overdue';
    -- Caso contrrio, se for local_today ou no futuro, define o status como 'active'
    ELSE
      NEW.status := 'active';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_client_status_based_on_due_date"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_templates_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_templates_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_updated_at_column"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_updated_at_column"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."active_payment_gateway" (
    "id" bigint DEFAULT 1 NOT NULL,
    "gateway_name" "text" NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."active_payment_gateway" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."admin_financial_entries" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "admin_user_id" "uuid",
    "subscriber_id" "uuid",
    "description" "text" NOT NULL,
    "value" numeric NOT NULL,
    "type" "public"."transaction_type" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."admin_financial_entries" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."automations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "days_offset" integer NOT NULL,
    "template_id" "uuid" NOT NULL,
    "client_ids" "uuid"[] NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "scheduled_time" time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL
);


ALTER TABLE "public"."automations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."clients" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "phone" "text" NOT NULL,
    "email" "text",
    "notes" "text",
    "plan_id" "uuid",
    "due_date" "date" NOT NULL,
    "next_billing_date" "date" NOT NULL,
    "status" "public"."client_status" DEFAULT 'active'::"public"."client_status" NOT NULL,
    "value" numeric(10,2) NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."clients" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."connection_status" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "instance_name" "text" NOT NULL,
    "status" "text" DEFAULT 'disconnected'::"text" NOT NULL,
    "qr_code_base64" "text",
    "last_updated" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."connection_status" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."evolution_api_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "webhook_type" "text" NOT NULL,
    "payload" "jsonb" NOT NULL,
    "request_payload" "jsonb",
    "response_payload" "jsonb",
    "status_code" integer,
    "timestamp" timestamp with time zone DEFAULT "now"(),
    "client_id" "uuid",
    "template_id" "uuid",
    "client_name_snapshot" "text"
);


ALTER TABLE "public"."evolution_api_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."evolution_logout_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "webhook_type" "text" NOT NULL,
    "payload" "jsonb" NOT NULL,
    "request_payload" "jsonb",
    "response_payload" "jsonb",
    "status_code" integer,
    "timestamp" timestamp with time zone DEFAULT "now"(),
    "client_id" "uuid",
    "template_id" "uuid",
    "client_name_snapshot" "text"
);


ALTER TABLE "public"."evolution_logout_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."financial_entries" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "description" "text" NOT NULL,
    "value" numeric(10,2) NOT NULL,
    "type" "public"."transaction_type" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."financial_entries" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "action" "text" NOT NULL,
    "details" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."mercado_pago_charges" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "subscription_id" "uuid" NOT NULL,
    "mercado_pago_payment_id" "text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "value" numeric NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."mercado_pago_charges" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."mercado_pago_configs" (
    "id" bigint DEFAULT 1 NOT NULL,
    "mercado_pago_public_key" "text" NOT NULL,
    "mercado_pago_access_token" "text" NOT NULL,
    "mercado_pago_client_id" "text" NOT NULL,
    "mercado_pago_client_secret" "text" NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "enforce_single_row" CHECK (("id" = 1))
);


ALTER TABLE "public"."mercado_pago_configs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."n8n_message_sender_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "webhook_type" "text" NOT NULL,
    "payload" "jsonb" NOT NULL,
    "request_payload" "jsonb",
    "response_payload" "jsonb",
    "status_code" integer,
    "timestamp" timestamp with time zone DEFAULT "now"(),
    "client_id" "uuid",
    "template_id" "uuid",
    "client_name_snapshot" "text"
);


ALTER TABLE "public"."n8n_message_sender_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."n8n_qr_code_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "webhook_type" "text" NOT NULL,
    "payload" "jsonb" NOT NULL,
    "request_payload" "jsonb",
    "response_payload" "jsonb",
    "status_code" integer,
    "timestamp" timestamp with time zone DEFAULT "now"(),
    "client_id" "uuid",
    "template_id" "uuid",
    "client_name_snapshot" "text"
);


ALTER TABLE "public"."n8n_qr_code_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."pagbank_charges" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "subscription_id" "uuid" NOT NULL,
    "pagbank_charge_id" "text" NOT NULL,
    "status" "text" DEFAULT 'PENDING'::"text" NOT NULL,
    "value" numeric NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."pagbank_charges" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."pagbank_configs" (
    "id" bigint DEFAULT 1 NOT NULL,
    "pagbank_email" "text" NOT NULL,
    "pagbank_token" "text" NOT NULL,
    "pagbank_pix_key" "text" NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "environment" "public"."pagbank_environment" DEFAULT 'sandbox'::"public"."pagbank_environment" NOT NULL
);


ALTER TABLE "public"."pagbank_configs" OWNER TO "postgres";


COMMENT ON COLUMN "public"."pagbank_configs"."environment" IS 'Ambiente da API PagBank a ser utilizado (sandbox ou production).';



CREATE TABLE IF NOT EXISTS "public"."pending_sends" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "client_id" "uuid" NOT NULL,
    "automation_id" "uuid" NOT NULL,
    "template_id" "uuid" NOT NULL,
    "scheduled_for" "date" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."pending_sends" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."plans" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "value" numeric(10,2) NOT NULL,
    "period_days" integer NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."plans" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."profiles" (
    "id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "email" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "pix_key" "text",
    "phone" "text",
    "tax_id" "text" DEFAULT ''::"text" NOT NULL
);


ALTER TABLE "public"."profiles" OWNER TO "postgres";


COMMENT ON COLUMN "public"."profiles"."pix_key" IS 'Chave PIX do usurio para recebimento de pagamentos.';



COMMENT ON COLUMN "public"."profiles"."phone" IS 'Nmero de telefone do usurio, obrigatrio para usurios no-admin.';



COMMENT ON COLUMN "public"."profiles"."tax_id" IS 'CPF ou CNPJ do usurio (apenas nmeros). Obrigatrio.';



CREATE TABLE IF NOT EXISTS "public"."scheduled_notifications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "client_id" "uuid" NOT NULL,
    "template_id" "uuid" NOT NULL,
    "automation_id" "uuid" NOT NULL,
    "send_at" timestamp with time zone NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "type" "text" DEFAULT 'client_notification'::"text" NOT NULL
);


ALTER TABLE "public"."scheduled_notifications" OWNER TO "postgres";


COMMENT ON COLUMN "public"."scheduled_notifications"."type" IS 'Type of notification: client_notification or subscriber_notification.';



CREATE TABLE IF NOT EXISTS "public"."send_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "client_id" "uuid" NOT NULL,
    "template_id" "uuid" NOT NULL,
    "sent_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "status" "text" NOT NULL,
    "error_message" "text",
    CONSTRAINT "send_history_status_check" CHECK (("status" = ANY (ARRAY['success'::"text", 'failed'::"text"])))
);


ALTER TABLE "public"."send_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."subscriber_automations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "admin_user_id" "uuid",
    "days_offset" integer NOT NULL,
    "subscriber_template_id" "uuid",
    "subscriber_ids" "uuid"[] NOT NULL,
    "scheduled_time" time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."subscriber_automations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."subscriber_plans" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "value" numeric NOT NULL,
    "period_days" integer NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."subscriber_plans" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."subscriber_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "admin_user_id" "uuid",
    "name" "text" NOT NULL,
    "content" "text" NOT NULL,
    "type" "public"."template_type" DEFAULT 'normal'::"public"."template_type" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."subscriber_templates" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."subscriptions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "plan_name" "text" NOT NULL,
    "price" numeric(10,2) NOT NULL,
    "status" "text" DEFAULT 'inactive'::"text" NOT NULL,
    "next_billing_date" "date" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."subscriptions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "name" "text" NOT NULL,
    "content" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "type" "public"."template_type" DEFAULT 'normal'::"public"."template_type" NOT NULL
);


ALTER TABLE "public"."templates" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."url_configs" (
    "id" integer DEFAULT 1 NOT NULL,
    "n8n_webhook_url" "text" NOT NULL,
    "evolution_listener_url" "text" NOT NULL,
    CONSTRAINT "single_row_check" CHECK (("id" = 1))
);


ALTER TABLE "public"."url_configs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_instances" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "instance_name" "text" NOT NULL,
    "status" "text" DEFAULT 'disconnected'::"text" NOT NULL,
    "qr_code_base64" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."user_instances" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_roles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "role" "public"."app_role" DEFAULT 'user'::"public"."app_role" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."user_roles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."webhook_configs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "type" "text" NOT NULL,
    "url" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."webhook_configs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."webhook_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "webhook_type" "text" NOT NULL,
    "payload" "jsonb" NOT NULL,
    "status_code" integer,
    "timestamp" timestamp with time zone DEFAULT "now"() NOT NULL,
    "request_payload" "jsonb",
    "response_payload" "jsonb",
    "client_id" "uuid",
    "template_id" "uuid",
    "client_name_snapshot" "text"
);


ALTER TABLE "public"."webhook_history" OWNER TO "postgres";


COMMENT ON COLUMN "public"."webhook_history"."client_name_snapshot" IS 'Snapshot of the client name at the time of the webhook call. Used to preserve history even if client is deleted.';



ALTER TABLE ONLY "public"."active_payment_gateway"
    ADD CONSTRAINT "active_payment_gateway_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."admin_financial_entries"
    ADD CONSTRAINT "admin_financial_entries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."automations"
    ADD CONSTRAINT "automations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."connection_status"
    ADD CONSTRAINT "connection_status_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."connection_status"
    ADD CONSTRAINT "connection_status_user_id_instance_name_key" UNIQUE ("user_id", "instance_name");



ALTER TABLE ONLY "public"."evolution_api_history"
    ADD CONSTRAINT "evolution_api_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."evolution_logout_history"
    ADD CONSTRAINT "evolution_logout_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."financial_entries"
    ADD CONSTRAINT "financial_entries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."logs"
    ADD CONSTRAINT "logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."mercado_pago_charges"
    ADD CONSTRAINT "mercado_pago_charges_mercado_pago_payment_id_key" UNIQUE ("mercado_pago_payment_id");



ALTER TABLE ONLY "public"."mercado_pago_charges"
    ADD CONSTRAINT "mercado_pago_charges_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."mercado_pago_configs"
    ADD CONSTRAINT "mercado_pago_configs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."n8n_message_sender_history"
    ADD CONSTRAINT "n8n_message_sender_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."n8n_qr_code_history"
    ADD CONSTRAINT "n8n_qr_code_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."pagbank_charges"
    ADD CONSTRAINT "pagbank_charges_pagbank_charge_id_key" UNIQUE ("pagbank_charge_id");



ALTER TABLE ONLY "public"."pagbank_charges"
    ADD CONSTRAINT "pagbank_charges_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."pagbank_configs"
    ADD CONSTRAINT "pagbank_configs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."pending_sends"
    ADD CONSTRAINT "pending_sends_client_id_automation_id_scheduled_for_key" UNIQUE ("client_id", "automation_id", "scheduled_for");



ALTER TABLE ONLY "public"."pending_sends"
    ADD CONSTRAINT "pending_sends_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."plans"
    ADD CONSTRAINT "plans_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."scheduled_notifications"
    ADD CONSTRAINT "scheduled_notifications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."send_history"
    ADD CONSTRAINT "send_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."subscriber_automations"
    ADD CONSTRAINT "subscriber_automations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."subscriber_plans"
    ADD CONSTRAINT "subscriber_plans_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."subscriber_templates"
    ADD CONSTRAINT "subscriber_templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."subscriptions"
    ADD CONSTRAINT "subscriptions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."subscriptions"
    ADD CONSTRAINT "subscriptions_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."templates"
    ADD CONSTRAINT "templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."url_configs"
    ADD CONSTRAINT "url_configs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_instances"
    ADD CONSTRAINT "user_instances_instance_name_key" UNIQUE ("instance_name");



ALTER TABLE ONLY "public"."user_instances"
    ADD CONSTRAINT "user_instances_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_instances"
    ADD CONSTRAINT "user_instances_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_user_id_role_key" UNIQUE ("user_id", "role");



ALTER TABLE ONLY "public"."webhook_configs"
    ADD CONSTRAINT "webhook_configs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."webhook_configs"
    ADD CONSTRAINT "webhook_configs_user_id_type_key" UNIQUE ("user_id", "type");



ALTER TABLE ONLY "public"."webhook_history"
    ADD CONSTRAINT "webhook_history_pkey" PRIMARY KEY ("id");



CREATE INDEX "idx_profiles_phone" ON "public"."profiles" USING "btree" ("phone");



CREATE INDEX "idx_webhook_history_client_name_snapshot" ON "public"."webhook_history" USING "btree" ("client_name_snapshot");



CREATE UNIQUE INDEX "unique_standard_template_name" ON "public"."templates" USING "btree" ("name") WHERE ("user_id" IS NULL);



CREATE OR REPLACE TRIGGER "prevent_default_plan_deletion_trigger" BEFORE DELETE ON "public"."subscriber_plans" FOR EACH ROW EXECUTE FUNCTION "public"."prevent_default_plan_deletion"();



CREATE OR REPLACE TRIGGER "trigger_handle_client_cancellation" AFTER UPDATE ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."handle_client_cancellation"();



CREATE OR REPLACE TRIGGER "trigger_handle_client_overdue_status" AFTER UPDATE ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."handle_client_overdue_status"();



CREATE OR REPLACE TRIGGER "trigger_set_client_status" BEFORE INSERT OR UPDATE ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."set_client_status_based_on_due_date"();



CREATE OR REPLACE TRIGGER "update_automations_updated_at" BEFORE UPDATE ON "public"."automations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_clients_updated_at" BEFORE UPDATE ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_plans_updated_at" BEFORE UPDATE ON "public"."plans" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_profiles_updated_at" BEFORE UPDATE ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_subscriber_automations_updated_at" BEFORE UPDATE ON "public"."subscriber_automations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_subscriber_plans_updated_at" BEFORE UPDATE ON "public"."subscriber_plans" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_subscriber_templates_updated_at" BEFORE UPDATE ON "public"."subscriber_templates" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_subscriptions_updated_at" BEFORE UPDATE ON "public"."subscriptions" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_templates_updated_at" BEFORE UPDATE ON "public"."templates" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_user_instances_updated_at" BEFORE UPDATE ON "public"."user_instances" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_webhook_configs_updated_at" BEFORE UPDATE ON "public"."webhook_configs" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



ALTER TABLE ONLY "public"."admin_financial_entries"
    ADD CONSTRAINT "admin_financial_entries_admin_user_id_fkey" FOREIGN KEY ("admin_user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."admin_financial_entries"
    ADD CONSTRAINT "admin_financial_entries_subscriber_id_fkey" FOREIGN KEY ("subscriber_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."automations"
    ADD CONSTRAINT "automations_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."templates"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."automations"
    ADD CONSTRAINT "automations_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_plan_id_fkey" FOREIGN KEY ("plan_id") REFERENCES "public"."plans"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."connection_status"
    ADD CONSTRAINT "connection_status_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."evolution_api_history"
    ADD CONSTRAINT "evolution_api_history_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."evolution_api_history"
    ADD CONSTRAINT "evolution_api_history_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."templates"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."evolution_api_history"
    ADD CONSTRAINT "evolution_api_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."evolution_logout_history"
    ADD CONSTRAINT "evolution_logout_history_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."evolution_logout_history"
    ADD CONSTRAINT "evolution_logout_history_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."templates"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."evolution_logout_history"
    ADD CONSTRAINT "evolution_logout_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."financial_entries"
    ADD CONSTRAINT "financial_entries_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."logs"
    ADD CONSTRAINT "logs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mercado_pago_charges"
    ADD CONSTRAINT "mercado_pago_charges_subscription_id_fkey" FOREIGN KEY ("subscription_id") REFERENCES "public"."subscriptions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mercado_pago_charges"
    ADD CONSTRAINT "mercado_pago_charges_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."n8n_message_sender_history"
    ADD CONSTRAINT "n8n_message_sender_history_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."n8n_message_sender_history"
    ADD CONSTRAINT "n8n_message_sender_history_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."templates"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."n8n_message_sender_history"
    ADD CONSTRAINT "n8n_message_sender_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."n8n_qr_code_history"
    ADD CONSTRAINT "n8n_qr_code_history_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."n8n_qr_code_history"
    ADD CONSTRAINT "n8n_qr_code_history_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."templates"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."n8n_qr_code_history"
    ADD CONSTRAINT "n8n_qr_code_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."pagbank_charges"
    ADD CONSTRAINT "pagbank_charges_subscription_id_fkey" FOREIGN KEY ("subscription_id") REFERENCES "public"."subscriptions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."pagbank_charges"
    ADD CONSTRAINT "pagbank_charges_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."pending_sends"
    ADD CONSTRAINT "pending_sends_automation_id_fkey" FOREIGN KEY ("automation_id") REFERENCES "public"."automations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."pending_sends"
    ADD CONSTRAINT "pending_sends_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."pending_sends"
    ADD CONSTRAINT "pending_sends_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."templates"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."pending_sends"
    ADD CONSTRAINT "pending_sends_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."plans"
    ADD CONSTRAINT "plans_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."scheduled_notifications"
    ADD CONSTRAINT "scheduled_notifications_automation_id_fkey" FOREIGN KEY ("automation_id") REFERENCES "public"."automations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."scheduled_notifications"
    ADD CONSTRAINT "scheduled_notifications_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."scheduled_notifications"
    ADD CONSTRAINT "scheduled_notifications_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."templates"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."scheduled_notifications"
    ADD CONSTRAINT "scheduled_notifications_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."send_history"
    ADD CONSTRAINT "send_history_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."send_history"
    ADD CONSTRAINT "send_history_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."templates"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."send_history"
    ADD CONSTRAINT "send_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."subscriber_automations"
    ADD CONSTRAINT "subscriber_automations_admin_user_id_fkey" FOREIGN KEY ("admin_user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."subscriber_automations"
    ADD CONSTRAINT "subscriber_automations_subscriber_template_id_fkey" FOREIGN KEY ("subscriber_template_id") REFERENCES "public"."subscriber_templates"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."subscriber_templates"
    ADD CONSTRAINT "subscriber_templates_admin_user_id_fkey" FOREIGN KEY ("admin_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."subscriptions"
    ADD CONSTRAINT "subscriptions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."templates"
    ADD CONSTRAINT "templates_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_instances"
    ADD CONSTRAINT "user_instances_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."webhook_configs"
    ADD CONSTRAINT "webhook_configs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."webhook_history"
    ADD CONSTRAINT "webhook_history_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."webhook_history"
    ADD CONSTRAINT "webhook_history_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."templates"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."webhook_history"
    ADD CONSTRAINT "webhook_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



CREATE POLICY "Admins can delete Mercado Pago charges" ON "public"."mercado_pago_charges" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can delete admin financial entries" ON "public"."admin_financial_entries" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can delete subscriber automations" ON "public"."subscriber_automations" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can delete subscriber plans" ON "public"."subscriber_plans" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can delete subscriber templates" ON "public"."subscriber_templates" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can insert Mercado Pago charges" ON "public"."mercado_pago_charges" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can insert PagBank configs" ON "public"."pagbank_configs" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can insert active payment gateway" ON "public"."active_payment_gateway" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can insert admin financial entries" ON "public"."admin_financial_entries" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can insert subscriber automations" ON "public"."subscriber_automations" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can insert subscriber plans" ON "public"."subscriber_plans" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can insert subscriber templates" ON "public"."subscriber_templates" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can manage Mercado Pago configs" ON "public"."mercado_pago_configs" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can manage webhook configs" ON "public"."webhook_configs" TO "authenticated" USING ((( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")) WITH CHECK ((( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role"));



CREATE POLICY "Admins can update Mercado Pago charges" ON "public"."mercado_pago_charges" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can update PagBank configs" ON "public"."pagbank_configs" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can update active payment gateway" ON "public"."active_payment_gateway" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can update admin financial entries" ON "public"."admin_financial_entries" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can update subscriber automations" ON "public"."subscriber_automations" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can update subscriber plans" ON "public"."subscriber_plans" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can update subscriber templates" ON "public"."subscriber_templates" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can view Mercado Pago configs" ON "public"."mercado_pago_configs" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can view PagBank configs" ON "public"."pagbank_configs" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can view all Mercado Pago charges" ON "public"."mercado_pago_charges" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can view all admin financial entries" ON "public"."admin_financial_entries" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can view all subscriber automations" ON "public"."subscriber_automations" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can view all subscriber plans" ON "public"."subscriber_plans" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can view all subscriber templates" ON "public"."subscriber_templates" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Allow authenticated users to read their own, standard, or globa" ON "public"."templates" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR ("user_id" IS NULL) OR ("type" = 'global'::"public"."template_type")));



CREATE POLICY "Allow users to delete normal templates and admins to delete any" ON "public"."templates" FOR DELETE TO "authenticated" USING (((("auth"."uid"() = "user_id") AND ("type" = 'normal'::"public"."template_type")) OR (EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role"))))));



CREATE POLICY "Allow users to insert normal templates and admins to insert any" ON "public"."templates" FOR INSERT TO "authenticated" WITH CHECK (((("auth"."uid"() = "user_id") AND ("type" = 'normal'::"public"."template_type")) OR (EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role"))))));



CREATE POLICY "Allow users to update normal templates and admins to update any" ON "public"."templates" FOR UPDATE TO "authenticated" USING (((("auth"."uid"() = "user_id") AND ("type" = 'normal'::"public"."template_type")) OR (EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))))) WITH CHECK (((("auth"."uid"() = "user_id") AND ("type" = 'normal'::"public"."template_type")) OR (EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role"))))));



CREATE POLICY "Authenticated users can read url configs" ON "public"."url_configs" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can read webhook configs" ON "public"."webhook_configs" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can view active payment gateway" ON "public"."active_payment_gateway" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Users can delete their own Mercado Pago charges" ON "public"."mercado_pago_charges" FOR DELETE TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can delete their own connection status OR Admins can dele" ON "public"."connection_status" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can delete their own financial entries OR Admins can dele" ON "public"."financial_entries" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can delete their own logs OR Admins can delete for others" ON "public"."logs" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can delete their own profile OR Admins can delete for oth" ON "public"."profiles" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can delete their own scheduled notifications OR Admins ca" ON "public"."scheduled_notifications" FOR DELETE TO "authenticated" USING (((("auth"."uid"() = "user_id") AND ("type" = 'client_notification'::"text")) OR (EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role"))))));



CREATE POLICY "Users can delete their own send history OR Admins can delete fo" ON "public"."send_history" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can delete their own subscription OR Admins can delete fo" ON "public"."subscriptions" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can delete their own webhook history OR Admins can delete" ON "public"."webhook_history" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can insert their own Mercado Pago charges" ON "public"."mercado_pago_charges" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can insert their own connection status OR Admins can inse" ON "public"."connection_status" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can insert their own financial entries OR Admins can inse" ON "public"."financial_entries" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can insert their own logs OR Admins can insert for others" ON "public"."logs" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can insert their own scheduled notifications OR Admins ca" ON "public"."scheduled_notifications" FOR INSERT TO "authenticated" WITH CHECK (((("auth"."uid"() = "user_id") AND ("type" = 'client_notification'::"text")) OR (EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role"))))));



CREATE POLICY "Users can insert their own send history OR Admins can insert fo" ON "public"."send_history" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can insert their own subscription OR Admins can insert fo" ON "public"."subscriptions" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can insert their own webhook history OR Admins can insert" ON "public"."webhook_history" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can manage their own automations OR Admins can manage all" ON "public"."automations" TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role"))) WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can manage their own clients OR Admins can manage all" ON "public"."clients" TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role"))) WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can manage their own instance mapping OR Admins can manag" ON "public"."user_instances" TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role"))) WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can manage their own pending sends" ON "public"."pending_sends" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can manage their own plans OR Admins can manage all" ON "public"."plans" TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role"))) WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can manage their own role" ON "public"."user_roles" TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can update their own Mercado Pago charges" ON "public"."mercado_pago_charges" FOR UPDATE TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can update their own connection status OR Admins can upda" ON "public"."connection_status" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can update their own financial entries OR Admins can upda" ON "public"."financial_entries" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can update their own logs OR Admins can update for others" ON "public"."logs" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can update their own profile OR Admins can update for oth" ON "public"."profiles" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can update their own scheduled notifications OR Admins ca" ON "public"."scheduled_notifications" FOR UPDATE TO "authenticated" USING (((("auth"."uid"() = "user_id") AND ("type" = 'client_notification'::"text")) OR (EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role"))))));



CREATE POLICY "Users can update their own send history OR Admins can update fo" ON "public"."send_history" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can update their own subscription OR Admins can update fo" ON "public"."subscriptions" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can update their own webhook history OR Admins can update" ON "public"."webhook_history" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can view their own Mercado Pago charges" ON "public"."mercado_pago_charges" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view their own PagBank charges" ON "public"."pagbank_charges" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role"))))));



CREATE POLICY "Users can view their own connection status OR Admins can view a" ON "public"."connection_status" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can view their own financial entries OR Admins can view a" ON "public"."financial_entries" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can view their own logs OR Admins can view all" ON "public"."logs" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can view their own profile OR Admins can view all" ON "public"."profiles" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can view their own role" ON "public"."user_roles" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view their own scheduled notifications OR Admins can " ON "public"."scheduled_notifications" FOR SELECT TO "authenticated" USING (((("auth"."uid"() = "user_id") AND ("type" = 'client_notification'::"text")) OR (EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role"))))));



CREATE POLICY "Users can view their own send history OR Admins can view all" ON "public"."send_history" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can view their own subscription OR Admins can view all" ON "public"."subscriptions" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can view their own webhook history OR Admins can view all" ON "public"."webhook_history" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



ALTER TABLE "public"."active_payment_gateway" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."admin_financial_entries" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."automations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."clients" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."connection_status" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."evolution_api_history" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "evolution_api_history_delete_policy OR Admins can delete for ot" ON "public"."evolution_api_history" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "evolution_api_history_insert_policy OR Admins can insert for ot" ON "public"."evolution_api_history" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "evolution_api_history_select_policy OR Admins can view all" ON "public"."evolution_api_history" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "evolution_api_history_update_policy OR Admins can update for ot" ON "public"."evolution_api_history" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



ALTER TABLE "public"."evolution_logout_history" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "evolution_logout_history_delete_policy OR Admins can delete for" ON "public"."evolution_logout_history" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "evolution_logout_history_insert_policy OR Admins can insert for" ON "public"."evolution_logout_history" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "evolution_logout_history_select_policy OR Admins can view all" ON "public"."evolution_logout_history" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "evolution_logout_history_update_policy OR Admins can update for" ON "public"."evolution_logout_history" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



ALTER TABLE "public"."financial_entries" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."mercado_pago_charges" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."mercado_pago_configs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."n8n_message_sender_history" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "n8n_message_sender_history_delete_policy OR Admins can delete f" ON "public"."n8n_message_sender_history" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "n8n_message_sender_history_insert_policy OR Admins can insert f" ON "public"."n8n_message_sender_history" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "n8n_message_sender_history_select_policy OR Admins can view all" ON "public"."n8n_message_sender_history" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "n8n_message_sender_history_update_policy OR Admins can update f" ON "public"."n8n_message_sender_history" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



ALTER TABLE "public"."n8n_qr_code_history" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "n8n_qr_code_history_delete_policy OR Admins can delete for othe" ON "public"."n8n_qr_code_history" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "n8n_qr_code_history_insert_policy OR Admins can insert for othe" ON "public"."n8n_qr_code_history" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "n8n_qr_code_history_select_policy OR Admins can view all" ON "public"."n8n_qr_code_history" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "n8n_qr_code_history_update_policy OR Admins can update for othe" ON "public"."n8n_qr_code_history" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



ALTER TABLE "public"."pagbank_charges" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."pagbank_configs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."pending_sends" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."plans" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."profiles" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "profiles_insert_policy OR Admins can insert for others" ON "public"."profiles" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



ALTER TABLE "public"."scheduled_notifications" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."send_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."subscriber_automations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."subscriber_plans" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."subscriber_templates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."subscriptions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."templates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."url_configs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_instances" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_roles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."webhook_configs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."webhook_history" ENABLE ROW LEVEL SECURITY;




ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";






ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."connection_status";






GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";

















































































































































































GRANT ALL ON FUNCTION "public"."bytea_to_text"("data" "bytea") TO "postgres";
GRANT ALL ON FUNCTION "public"."bytea_to_text"("data" "bytea") TO "anon";
GRANT ALL ON FUNCTION "public"."bytea_to_text"("data" "bytea") TO "authenticated";
GRANT ALL ON FUNCTION "public"."bytea_to_text"("data" "bytea") TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_client_cancellation"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_client_cancellation"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_client_cancellation"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_client_overdue_status"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_client_overdue_status"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_client_overdue_status"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "service_role";



GRANT ALL ON FUNCTION "public"."http"("request" "public"."http_request") TO "postgres";
GRANT ALL ON FUNCTION "public"."http"("request" "public"."http_request") TO "anon";
GRANT ALL ON FUNCTION "public"."http"("request" "public"."http_request") TO "authenticated";
GRANT ALL ON FUNCTION "public"."http"("request" "public"."http_request") TO "service_role";



GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying, "content" character varying, "content_type" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying, "content" character varying, "content_type" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying, "content" character varying, "content_type" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying, "content" character varying, "content_type" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying, "data" "jsonb") TO "postgres";
GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying, "data" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying, "data" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying, "data" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."http_head"("uri" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_head"("uri" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_head"("uri" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_head"("uri" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_header"("field" character varying, "value" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_header"("field" character varying, "value" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_header"("field" character varying, "value" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_header"("field" character varying, "value" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_list_curlopt"() TO "postgres";
GRANT ALL ON FUNCTION "public"."http_list_curlopt"() TO "anon";
GRANT ALL ON FUNCTION "public"."http_list_curlopt"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_list_curlopt"() TO "service_role";



GRANT ALL ON FUNCTION "public"."http_patch"("uri" character varying, "content" character varying, "content_type" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_patch"("uri" character varying, "content" character varying, "content_type" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_patch"("uri" character varying, "content" character varying, "content_type" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_patch"("uri" character varying, "content" character varying, "content_type" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "data" "jsonb") TO "postgres";
GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "data" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "data" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "data" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "content" character varying, "content_type" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "content" character varying, "content_type" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "content" character varying, "content_type" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "content" character varying, "content_type" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_put"("uri" character varying, "content" character varying, "content_type" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_put"("uri" character varying, "content" character varying, "content_type" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_put"("uri" character varying, "content" character varying, "content_type" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_put"("uri" character varying, "content" character varying, "content_type" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_reset_curlopt"() TO "postgres";
GRANT ALL ON FUNCTION "public"."http_reset_curlopt"() TO "anon";
GRANT ALL ON FUNCTION "public"."http_reset_curlopt"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_reset_curlopt"() TO "service_role";



GRANT ALL ON FUNCTION "public"."http_set_curlopt"("curlopt" character varying, "value" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_set_curlopt"("curlopt" character varying, "value" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_set_curlopt"("curlopt" character varying, "value" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_set_curlopt"("curlopt" character varying, "value" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."prevent_default_plan_deletion"() TO "anon";
GRANT ALL ON FUNCTION "public"."prevent_default_plan_deletion"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."prevent_default_plan_deletion"() TO "service_role";



GRANT ALL ON FUNCTION "public"."process_automated_notifications"() TO "anon";
GRANT ALL ON FUNCTION "public"."process_automated_notifications"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_automated_notifications"() TO "service_role";



GRANT ALL ON FUNCTION "public"."process_notification_queue"() TO "anon";
GRANT ALL ON FUNCTION "public"."process_notification_queue"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_notification_queue"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_client_status_based_on_due_date"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_client_status_based_on_due_date"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_client_status_based_on_due_date"() TO "service_role";



GRANT ALL ON FUNCTION "public"."text_to_bytea"("data" "text") TO "postgres";
GRANT ALL ON FUNCTION "public"."text_to_bytea"("data" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."text_to_bytea"("data" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."text_to_bytea"("data" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_templates_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_templates_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_templates_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "service_role";



GRANT ALL ON FUNCTION "public"."urlencode"("string" "bytea") TO "postgres";
GRANT ALL ON FUNCTION "public"."urlencode"("string" "bytea") TO "anon";
GRANT ALL ON FUNCTION "public"."urlencode"("string" "bytea") TO "authenticated";
GRANT ALL ON FUNCTION "public"."urlencode"("string" "bytea") TO "service_role";



GRANT ALL ON FUNCTION "public"."urlencode"("data" "jsonb") TO "postgres";
GRANT ALL ON FUNCTION "public"."urlencode"("data" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."urlencode"("data" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."urlencode"("data" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."urlencode"("string" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."urlencode"("string" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."urlencode"("string" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."urlencode"("string" character varying) TO "service_role";
























GRANT ALL ON TABLE "public"."active_payment_gateway" TO "anon";
GRANT ALL ON TABLE "public"."active_payment_gateway" TO "authenticated";
GRANT ALL ON TABLE "public"."active_payment_gateway" TO "service_role";



GRANT ALL ON TABLE "public"."admin_financial_entries" TO "anon";
GRANT ALL ON TABLE "public"."admin_financial_entries" TO "authenticated";
GRANT ALL ON TABLE "public"."admin_financial_entries" TO "service_role";



GRANT ALL ON TABLE "public"."automations" TO "anon";
GRANT ALL ON TABLE "public"."automations" TO "authenticated";
GRANT ALL ON TABLE "public"."automations" TO "service_role";



GRANT ALL ON TABLE "public"."clients" TO "anon";
GRANT ALL ON TABLE "public"."clients" TO "authenticated";
GRANT ALL ON TABLE "public"."clients" TO "service_role";



GRANT ALL ON TABLE "public"."connection_status" TO "anon";
GRANT ALL ON TABLE "public"."connection_status" TO "authenticated";
GRANT ALL ON TABLE "public"."connection_status" TO "service_role";



GRANT ALL ON TABLE "public"."evolution_api_history" TO "anon";
GRANT ALL ON TABLE "public"."evolution_api_history" TO "authenticated";
GRANT ALL ON TABLE "public"."evolution_api_history" TO "service_role";



GRANT ALL ON TABLE "public"."evolution_logout_history" TO "anon";
GRANT ALL ON TABLE "public"."evolution_logout_history" TO "authenticated";
GRANT ALL ON TABLE "public"."evolution_logout_history" TO "service_role";



GRANT ALL ON TABLE "public"."financial_entries" TO "anon";
GRANT ALL ON TABLE "public"."financial_entries" TO "authenticated";
GRANT ALL ON TABLE "public"."financial_entries" TO "service_role";



GRANT ALL ON TABLE "public"."logs" TO "anon";
GRANT ALL ON TABLE "public"."logs" TO "authenticated";
GRANT ALL ON TABLE "public"."logs" TO "service_role";



GRANT ALL ON TABLE "public"."mercado_pago_charges" TO "anon";
GRANT ALL ON TABLE "public"."mercado_pago_charges" TO "authenticated";
GRANT ALL ON TABLE "public"."mercado_pago_charges" TO "service_role";



GRANT ALL ON TABLE "public"."mercado_pago_configs" TO "anon";
GRANT ALL ON TABLE "public"."mercado_pago_configs" TO "authenticated";
GRANT ALL ON TABLE "public"."mercado_pago_configs" TO "service_role";



GRANT ALL ON TABLE "public"."n8n_message_sender_history" TO "anon";
GRANT ALL ON TABLE "public"."n8n_message_sender_history" TO "authenticated";
GRANT ALL ON TABLE "public"."n8n_message_sender_history" TO "service_role";



GRANT ALL ON TABLE "public"."n8n_qr_code_history" TO "anon";
GRANT ALL ON TABLE "public"."n8n_qr_code_history" TO "authenticated";
GRANT ALL ON TABLE "public"."n8n_qr_code_history" TO "service_role";



GRANT ALL ON TABLE "public"."pagbank_charges" TO "anon";
GRANT ALL ON TABLE "public"."pagbank_charges" TO "authenticated";
GRANT ALL ON TABLE "public"."pagbank_charges" TO "service_role";



GRANT ALL ON TABLE "public"."pagbank_configs" TO "anon";
GRANT ALL ON TABLE "public"."pagbank_configs" TO "authenticated";
GRANT ALL ON TABLE "public"."pagbank_configs" TO "service_role";



GRANT ALL ON TABLE "public"."pending_sends" TO "anon";
GRANT ALL ON TABLE "public"."pending_sends" TO "authenticated";
GRANT ALL ON TABLE "public"."pending_sends" TO "service_role";



GRANT ALL ON TABLE "public"."plans" TO "anon";
GRANT ALL ON TABLE "public"."plans" TO "authenticated";
GRANT ALL ON TABLE "public"."plans" TO "service_role";



GRANT ALL ON TABLE "public"."profiles" TO "anon";
GRANT ALL ON TABLE "public"."profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."profiles" TO "service_role";



GRANT ALL ON TABLE "public"."scheduled_notifications" TO "anon";
GRANT ALL ON TABLE "public"."scheduled_notifications" TO "authenticated";
GRANT ALL ON TABLE "public"."scheduled_notifications" TO "service_role";



GRANT ALL ON TABLE "public"."send_history" TO "anon";
GRANT ALL ON TABLE "public"."send_history" TO "authenticated";
GRANT ALL ON TABLE "public"."send_history" TO "service_role";



GRANT ALL ON TABLE "public"."subscriber_automations" TO "anon";
GRANT ALL ON TABLE "public"."subscriber_automations" TO "authenticated";
GRANT ALL ON TABLE "public"."subscriber_automations" TO "service_role";



GRANT ALL ON TABLE "public"."subscriber_plans" TO "anon";
GRANT ALL ON TABLE "public"."subscriber_plans" TO "authenticated";
GRANT ALL ON TABLE "public"."subscriber_plans" TO "service_role";



GRANT ALL ON TABLE "public"."subscriber_templates" TO "anon";
GRANT ALL ON TABLE "public"."subscriber_templates" TO "authenticated";
GRANT ALL ON TABLE "public"."subscriber_templates" TO "service_role";



GRANT ALL ON TABLE "public"."subscriptions" TO "anon";
GRANT ALL ON TABLE "public"."subscriptions" TO "authenticated";
GRANT ALL ON TABLE "public"."subscriptions" TO "service_role";



GRANT ALL ON TABLE "public"."templates" TO "anon";
GRANT ALL ON TABLE "public"."templates" TO "authenticated";
GRANT ALL ON TABLE "public"."templates" TO "service_role";



GRANT ALL ON TABLE "public"."url_configs" TO "anon";
GRANT ALL ON TABLE "public"."url_configs" TO "authenticated";
GRANT ALL ON TABLE "public"."url_configs" TO "service_role";



GRANT ALL ON TABLE "public"."user_instances" TO "anon";
GRANT ALL ON TABLE "public"."user_instances" TO "authenticated";
GRANT ALL ON TABLE "public"."user_instances" TO "service_role";



GRANT ALL ON TABLE "public"."user_roles" TO "anon";
GRANT ALL ON TABLE "public"."user_roles" TO "authenticated";
GRANT ALL ON TABLE "public"."user_roles" TO "service_role";



GRANT ALL ON TABLE "public"."webhook_configs" TO "anon";
GRANT ALL ON TABLE "public"."webhook_configs" TO "authenticated";
GRANT ALL ON TABLE "public"."webhook_configs" TO "service_role";



GRANT ALL ON TABLE "public"."webhook_history" TO "anon";
GRANT ALL ON TABLE "public"."webhook_history" TO "authenticated";
GRANT ALL ON TABLE "public"."webhook_history" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";































RESET ALL;

