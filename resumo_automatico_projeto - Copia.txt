
.
|-- ACAO_IMEDIATA.md
|-- AI_RULES.md
|-- DIAGNOSTICO_AGENDAMENTOS.md
|-- README.md
|-- add_client_name_snapshot.sql
|-- bun.lock
|-- bun.lockb
|-- components.json
|-- convenção de versionamento.txt
|-- diagnostico_agendamentos.sql
|-- eslint.config.js
|-- gerar_resumo.sh
|-- gerar_resumo_V_360.sh
|-- gerar_resumo_V_final.sh
|-- index.html
|-- package-lock.json
|-- package.json
|-- pnpm-lock.yaml
|-- postcss.config.js
|-- public
|   |-- Icone.png
|   |-- favicon.ico
|   |-- placeholder.svg
|   `-- robots.txt
|-- rd
|-- resumo_automatico_projeto - Atual.txt
|-- resumo_automatico_projeto.txt
|-- src
|   |-- App.tsx
|   |-- assets
|   |-- components
|   |   |-- ProtectedRoute.tsx
|   |   |-- admin
|   |   |   |-- assinantes
|   |   |   |   |-- ConfigureSubscribersModal.tsx
|   |   |   |   |-- SubscriberAutomationDialog.tsx
|   |   |   |   |-- SubscriberAutomationRow.tsx
|   |   |   |   |-- SubscriberNotificationDialog.tsx
|   |   |   |   |-- SubscriberPlanDialog.tsx
|   |   |   |   |-- SubscriberTemplateDialog.tsx
|   |   |   |   `-- UpdateSubscriberSubscriptionDialog.tsx
|   |   |   `-- financeiro
|   |   |       `-- AdminFinancialEntryDialog.tsx
|   |   |-- automations
|   |   |   |-- AutomationRow.tsx
|   |   |   `-- ConfigureClients
|   |   |       `-- ConfigureClientsModal.tsx
|   |   |-- clients
|   |   |   |-- ClientDialog.tsx
|   |   |   `-- NotificationDialog.tsx
|   |   |-- connection
|   |   |   `-- WebhookDetailsDialog.tsx
|   |   |-- financeiro
|   |   |   |-- CustomTooltip.tsx
|   |   |   |-- EditFinancialEntryDialog.tsx
|   |   |   |-- ErrorState.tsx
|   |   |   |-- LoadingState.tsx
|   |   |   |-- charts
|   |   |   |   |-- ChartCard.tsx
|   |   |   |   |-- LostClientsByPlanChart.tsx
|   |   |   |   |-- MonthlyRevenueHistoryChart.tsx
|   |   |   |   |-- RevenueByPlanChart.tsx
|   |   |   |   |-- RevenueLast30DaysChart.tsx
|   |   |   |   `-- WeeklyRevenueComparisonChart.tsx
|   |   |   `-- kpis
|   |   |       |-- ChurnAnalysisSection.tsx
|   |   |       |-- KpiCard.tsx
|   |   |       `-- KpiSection.tsx
|   |   |-- layout
|   |   |   |-- AppSidebar.tsx
|   |   |   `-- MainLayout.tsx
|   |   |-- plans
|   |   |   `-- PlanDialog.tsx
|   |   |-- profile
|   |   |   |-- MercadoPagoPaymentModal.tsx
|   |   |   `-- PixPaymentModal.tsx
|   |   |-- templates
|   |   |   `-- TemplateDialog.tsx
|   |   `-- ui
|   |       |-- accordion.tsx
|   |       |-- alert-dialog.tsx
|   |       |-- alert.tsx
|   |       |-- aspect-ratio.tsx
|   |       |-- avatar.tsx
|   |       |-- badge.tsx
|   |       |-- breadcrumb.tsx
|   |       |-- button.tsx
|   |       |-- calendar.tsx
|   |       |-- card.tsx
|   |       |-- carousel.tsx
|   |       |-- chart.tsx
|   |       |-- checkbox.tsx
|   |       |-- collapsible.tsx
|   |       |-- command.tsx
|   |       |-- context-menu.tsx
|   |       |-- dialog.tsx
|   |       |-- drawer.tsx
|   |       |-- dropdown-menu.tsx
|   |       |-- form.tsx
|   |       |-- hover-card.tsx
|   |       |-- input-otp.tsx
|   |       |-- input.tsx
|   |       |-- label.tsx
|   |       |-- menubar.tsx
|   |       |-- navigation-menu.tsx
|   |       |-- pagination.tsx
|   |       |-- popover.tsx
|   |       |-- progress.tsx
|   |       |-- radio-group.tsx
|   |       |-- resizable.tsx
|   |       |-- scroll-area.tsx
|   |       |-- select.tsx
|   |       |-- separator.tsx
|   |       |-- sheet.tsx
|   |       |-- sidebar.tsx
|   |       |-- skeleton.tsx
|   |       |-- slider.tsx
|   |       |-- sonner.tsx
|   |       |-- switch.tsx
|   |       |-- table.tsx
|   |       |-- tabs.tsx
|   |       |-- textarea.tsx
|   |       |-- toggle-group.tsx
|   |       |-- toggle.tsx
|   |       `-- tooltip.tsx
|   |-- contexts
|   |   |-- Auth
|   |   `-- AuthContext.tsx
|   |-- hooks
|   |   |-- use-mobile.tsx
|   |   |-- useActiveGateway.ts
|   |   |-- useAdminFinancialData.ts
|   |   |-- useClients.ts
|   |   |-- useDashboardStats.ts
|   |   |-- useEvolutionLogoutHistory.ts
|   |   |-- useFinancialEntries.ts
|   |   |-- useMercadoPagoConfig.ts
|   |   |-- usePagbankConfig.ts
|   |   |-- usePlans.ts
|   |   |-- useProfileData.ts
|   |   |-- useSubscriberManagement.ts
|   |   |-- useTemplates.ts
|   |   |-- useWebhookConfig.ts
|   |   `-- useWebhookHistory.ts
|   |-- index.css
|   |-- integrations
|   |   `-- supabase
|   |       |-- client.ts
|   |       |-- schema.ts
|   |       `-- types.ts
|   |-- lib
|   |   `-- utils.ts
|   |-- main.tsx
|   |-- pages
|   |   |-- Auth.tsx
|   |   |-- Automations.tsx
|   |   |-- Clients.tsx
|   |   |-- Connection
|   |   |   |-- Metrics.tsx
|   |   |   `-- Webhooks.tsx
|   |   |-- Connection.tsx
|   |   |-- Dashboard.tsx
|   |   |-- NotFound.tsx
|   |   |-- Plans.tsx
|   |   |-- Profile.tsx
|   |   |-- Templates.tsx
|   |   |-- admin
|   |   |-- assinantes
|   |   |   |-- Automacoes.tsx
|   |   |   |-- Integracao.tsx
|   |   |   |-- Planos.tsx
|   |   |   |-- Templates.tsx
|   |   |   `-- Usuarios.tsx
|   |   |-- financeiro
|   |   |   |-- Analise.tsx
|   |   |   |-- Extrato.tsx
|   |   |   |-- Relatorios.tsx
|   |   |   `-- types.ts
|   |   `-- financeiroADM
|   |       |-- Analise.tsx
|   |       |-- Extrato.tsx
|   |       `-- Relatorios.tsx
|   `-- vite-env.d.ts
|-- supabase
|   |-- config.toml
|   |-- functions
|   |   |-- admin-financial-analysis
|   |   |   `-- index.ts
|   |   |-- admin-financial-entries
|   |   |   `-- index.ts
|   |   |-- admin-financial-summary
|   |   |   `-- index.ts
|   |   |-- apply-schema-migration
|   |   |   `-- index.ts
|   |   |-- connection-metrics
|   |   |   `-- index.ts
|   |   |-- crud-active-gateway
|   |   |   `-- index.ts
|   |   |-- crud-mercado-pago-configs
|   |   |   `-- index.ts
|   |   |-- crud-pagbank-configs
|   |   |   `-- index.ts
|   |   |-- crud-subscriber-automations
|   |   |   `-- index.ts
|   |   |-- crud-subscriber-plans
|   |   |   `-- index.ts
|   |   |-- crud-subscriber-templates
|   |   |   `-- index.ts
|   |   |-- delete-user
|   |   |   `-- index.ts
|   |   |-- evolution-webhook
|   |   |-- evolution-webhook-receiver
|   |   |   `-- index.ts
|   |   |-- financial-analysis
|   |   |   `-- index.ts
|   |   |-- financial-summary
|   |   |   `-- index.ts
|   |   |-- list-all-users
|   |   |   `-- index.ts
|   |   |-- log-n8n-qr-interaction
|   |   |   `-- index.ts
|   |   |-- mercado-pago-create-charge
|   |   |   `-- index.ts
|   |   |-- mercado-pago-webhook-receiver
|   |   |   `-- index.ts
|   |   |-- pagbank-create-charge
|   |   |   `-- index.ts
|   |   |-- pagbank-webhook-receiver
|   |   |   `-- index.ts
|   |   |-- populate-send-queue
|   |   |   `-- index.ts
|   |   |-- process-notification-queue
|   |   |-- process-queue-and-send
|   |   |   `-- index.ts
|   |   |-- renew-subscriber-subscription
|   |   |   `-- index.ts
|   |   |-- schedule-notifications-for-rule
|   |   |   `-- index.ts
|   |   |-- schedule-subscriber-notifications
|   |   |   `-- index.ts
|   |   |-- send-scheduled-notification
|   |   |   `-- index.ts
|   |   |-- set-subscriber-due-today
|   |   |   `-- index.ts
|   |   |-- setup-client-name-snapshot
|   |   |-- sync-pending-sends
|   |   |-- tsconfig.json
|   |   |-- update-instance-status
|   |   |-- update-user-instance-status
|   |   |   `-- index.ts
|   |   |-- update-user-role
|   |   |   `-- index.ts
|   |   `-- update-user-subscription
|   |       `-- index.ts
|   `-- migrations
|       |-- 0000_executando_um_script_sql_abrangente_e_corrigido_para_recriar_o_esquema_do_banco_de_dados_supabase_de_forma_idempotente_garantindo_que_apenas_o_c_digo_sql_v_lido_seja_executado_.sql
|       |-- 0001_atualizando_a_pol_tica_rls_de_inser_o_para_a_tabela_profiles_para_usar_uma_subquery_para_auth_uid_para_resolver_poss_veis_problemas_de_contexto_durante_a_cria_o_de_perfil_pelo_cliente_.sql
|       |-- 0002_criando_o_tipo_enum_transaction_type_e_a_tabela_financial_entries_com_rls_e_pol_ticas_de_seguran_a_.sql
|       |-- 0003_adicionando_pol_ticas_rls_para_update_e_delete_na_tabela_financial_entries_para_permitir_que_usu_rios_gerenciem_seus_pr_prios_lan_amentos_.sql
|       |-- 0004_adicionando_fun_o_e_gatilho_para_definir_o_status_do_cliente_com_base_na_data_de_vencimento_.sql
|       |-- 0005_criando_a_tabela_subscriptions_com_rls_e_trigger_para_gerenciar_assinaturas_de_usu_rios_.sql
|       |-- 0006_criando_a_tabela_automations_com_rls_e_trigger_para_gerenciar_regras_de_automa_o_.sql
|       |-- 0007_criando_as_tabelas_pending_sends_e_send_history_com_rls_para_gerenciar_a_fila_e_o_hist_rico_de_envios_de_mensagens_.sql
|       |-- 0008_criando_fun_o_e_gatilho_para_remover_clientes_inativos_de_automa_es_e_da_fila_de_envios_pendentes_.sql
|       |-- 0009_criando_fun_o_e_gatilho_para_remover_clientes_com_status_overdue_da_fila_de_envios_pendentes_.sql
|       |-- 0010_criando_a_tabela_user_instances_para_gerenciar_as_inst_ncias_do_whatsapp_por_usu_rio_com_rls_e_pol_ticas_de_seguran_a_.sql
|       |-- 0011_criando_a_tabela_url_configs_para_armazenar_urls_de_configura_o_do_sistema_com_rls_.sql
|       |-- 0013_criando_a_tabela_scheduled_notifications_com_rls_e_refer_ncias_a_clientes_templates_e_automa_es_.sql
|       |-- 0014_atualizando_a_fun_o_set_client_status_based_on_due_date_para_usar_o_fuso_hor_rio_local_america_sao_paulo_na_determina_o_do_status_do_cliente_.sql
|       |-- 0015_adicionando_colunas_request_payload_e_response_payload_tabela_webhook_history_e_atualizando_rls_.sql
|       |-- 0016_adicionando_colunas_client_id_e_template_id_tabela_webhook_history_e_criando_chaves_estrangeiras_.sql
|       |-- 0017_criando_as_tabelas_evolution_api_history_n8n_qr_code_history_e_n8n_message_sender_history_com_rls_e_chaves_estrangeiras_.sql
|       |-- 0018_criando_a_tabela_evolution_logout_history_com_rls_e_pol_ticas_de_seguran_a_.sql
|       |-- 0019_updating_rls_policies_for_all_user_specific_tables_to_ensure_multi_tenant_data_isolation_.sql
|       |-- 0020_updating_rls_policies_for_all_user_specific_tables_to_ensure_multi_tenant_data_isolation_.sql
|       |-- 0021_updating_rls_policies_for_all_user_specific_tables_and_webhook_configs_to_implement_role_based_access_control_rbac_.sql
|       |-- 0022_removendo_pol_ticas_rls_existentes_e_criando_novas_pol_ticas_n_o_recursivas_para_a_tabela_user_roles_.sql
|       |-- 0023_adicionando_a_coluna_pix_key_tabela_profiles_.sql
|       |-- 0024_migra_o_tornando_user_id_da_tabela_templates_nul_vel_e_adicionando_pix_key_tabela_profiles_se_ainda_n_o_existir_.sql
|       |-- 0025_migra_o_atualizando_as_pol_ticas_de_rls_para_a_tabela_templates_.sql
|       |-- 0026_criando_um_ndice_nico_parcial_na_coluna_name_da_tabela_templates_para_templates_padr_o_user_id_is_null_.sql
|       |-- 0027_adicionando_o_tipo_enum_template_type_e_a_coluna_type_tabela_templates_com_rls_atualizado_.sql
|       |-- 0028_removendo_a_coluna_category_da_tabela_templates_e_o_tipo_template_category_enum_.sql
|       |-- 0029_corrigindo_o_erro_ao_remover_a_coluna_category_da_tabela_templates_e_o_tipo_template_category_enum_usando_if_exists_.sql
|       |-- 0030_creating_new_tables_for_admin_financial_entries_subscriber_plans_subscriber_templates_and_subscriber_automations_along_with_their_rls_policies_.sql
|       |-- 0031_adding_type_column_to_scheduled_notifications_table_to_differentiate_between_client_and_subscriber_notifications_.sql
|       |-- 0032_contar_usu_rios_na_tabela_auth_users.sql
|       |-- 0033_contar_perfis_na_tabela_public_profiles.sql
|       |-- 0034_visualizar_os_primeiros_5_perfis.sql
|       |-- 0035_visualizar_os_primeiros_5_registros_de_fun_es_de_usu_rio.sql
|       |-- 0036_verificar_usu_rios_sem_perfil_correspondente.sql
|       |-- 0037_verificar_usu_rios_sem_fun_o_de_usu_rio_correspondente.sql
|       |-- 0038_verificar_status_do_gatilho_on_auth_user_created.sql
|       |-- 0039_update_fk_to_profiles_for_subscriptions_and_user_instances.sql
|       |-- 0040_verificar_chave_estrangeira_de_subscriptions_user_id.sql
|       |-- 0041_verificar_chave_estrangeira_de_user_instances_user_id.sql
|       |-- 0042_atualizando_a_fun_o_handle_new_user_para_criar_uma_assinatura_padr_o_para_novos_usu_rios_.sql
|       |-- 0043_corrigindo_a_chave_estrangeira_de_subscriptions_user_id_para_profiles_id_inserindo_o_plano_inicial_e_adicionando_gatilho_de_prote_o_.sql
|       |-- 0044_atualizando_a_fun_o_handle_new_user_para_usar_o_plano_inicial_dinamicamente_.sql
|       |-- 0045_limpando_registros_inconsistentes_em_user_instances_e_profiles_e_corrigindo_a_chave_estrangeira_para_user_instances_user_id_.sql
|       |-- 0046_desabilitando_temporariamente_o_gatilho_de_prote_o_consolidando_planos_plano_inicial_duplicados_e_reabilitando_o_gatilho_.sql
|       |-- 0047_adicionando_a_coluna_phone_tabela_profiles_e_atualizando_a_fun_o_handle_new_user_para_incluir_o_telefone_do_metadata_do_usu_rio_.sql
|       |-- 0048_criando_tabelas_pagbank_configs_e_pagbank_charges_com_rls_para_integra_o_pagbank_pix_.sql
|       |-- 0049_add_tax_id_to_profiles_table.sql
|       |-- 0049_adicionando_a_coluna_tax_id_cpf_cnpj_tabela_public_profiles_como_text_not_null_.sql
|       |-- 0050_adicionando_a_coluna_environment_e_o_tipo_enum_pagbank_environment_tabela_pagbank_configs_.sql
|       |-- 0051_corrigindo_a_migra_o_sql_para_adicionar_a_coluna_environment_tabela_pagbank_configs_apenas_se_ela_n_o_existir_garantindo_idempot_ncia_.sql
|       |-- 0052_creating_the_mercado_pago_configs_table_with_rls_policies_.sql
|       |-- 0053_creating_active_payment_gateway_table_with_rls_for_admin_users_.sql
|       |-- 0054_creating_the_mercado_pago_charges_table_with_rls_policies_for_mercado_pago_integration_.sql
|       |-- 0055_update_rls_policy_for_active_payment_gateway_to_allow_all_authenticated_users_to_read_.sql
|       |-- 0056_making_the_tax_id_column_in_the_public_profiles_table_nullable_.sql
|       |-- 0057_making_the_tax_id_column_in_the_public_profiles_table_nullable_.sql
|       |-- 0058_add_is_free_to_subscriber_plans_idempotently.sql
|       |-- 0059_create_or_replace_the_function_to_set_subscription_status_based_on_plan_and_due_date_and_create_the_trigger_.sql
|       |-- 20240801000000_populate_url_configs.sql
|       |-- 20240801103000_cleanup_old_cron_scheduler.sql
|       |-- 20240802000000_fix_security_warnings.sql
|       |-- 20240803000000_add_logging_to_process_notification_queue.sql
|       |-- 20240804000000_final_cron_cleanup.sql
|       |-- 20251007003528_102cc75e-094b-4867-af88-81f4a22932be.sql
|       |-- 20251008221742_04f85bc8-acba-4ba7-b6d0-7d68f700c615.sql
|       |-- 20251013211718_7199223e-79f3-455d-a284-7d422ac46b51.sql
|       |-- 20251013221600_fix_client_status_timezone.sql
|       |-- 20251016013741_aaf8b971-c037-421b-affa-f8e6241f5cd4.sql
|       |-- 20251016013854_c4128d56-0d29-430f-bf1b-44046107633e.sql
|       |-- 20251016020954_ea957f25-cd1a-4bb0-9173-0437ada06f90.sql
|       `-- 20251016022304_57e7bf3f-2807-4368-ad7d-e46877539e06.sql
|-- tailwind.config.ts
|-- tsconfig.app.json
|-- tsconfig.json
|-- tsconfig.node.json
|-- vercel.json
`-- vite.config.ts

70 directories, 264 files

{
  "@hookform/resolvers": "^3.10.0",
  "@radix-ui/react-accordion": "^1.2.11",
  "@radix-ui/react-alert-dialog": "^1.1.14",
  "@radix-ui/react-aspect-ratio": "^1.1.7",
  "@radix-ui/react-avatar": "^1.1.10",
  "@radix-ui/react-checkbox": "^1.3.2",
  "@radix-ui/react-collapsible": "^1.1.11",
  "@radix-ui/react-context-menu": "^2.2.15",
  "@radix-ui/react-dialog": "^1.1.14",
  "@radix-ui/react-dropdown-menu": "^2.1.15",
  "@radix-ui/react-hover-card": "^1.1.14",
  "@radix-ui/react-label": "^2.1.7",
  "@radix-ui/react-menubar": "^1.1.15",
  "@radix-ui/react-navigation-menu": "^1.2.13",
  "@radix-ui/react-popover": "^1.1.14",
  "@radix-ui/react-progress": "^1.1.7",
  "@radix-ui/react-radio-group": "^1.3.7",
  "@radix-ui/react-scroll-area": "^1.2.9",
  "@radix-ui/react-select": "^2.2.5",
  "@radix-ui/react-separator": "^1.1.7",
  "@radix-ui/react-slider": "^1.3.5",
  "@radix-ui/react-slot": "^1.2.3",
  "@radix-ui/react-switch": "^1.2.5",
  "@radix-ui/react-tabs": "^1.1.12",
  "@radix-ui/react-toast": "^1.2.14",
  "@radix-ui/react-toggle": "^1.1.9",
  "@radix-ui/react-toggle-group": "^1.1.10",
  "@radix-ui/react-tooltip": "^1.2.7",
  "@supabase/supabase-js": "^2.74.0",
  "@tanstack/react-query": "^5.83.0",
  "@types/luxon": "^3.7.1",
  "@types/recharts": "^2.0.1",
  "class-variance-authority": "^0.7.1",
  "clsx": "^2.1.1",
  "cmdk": "^1.1.1",
  "date-fns": "^3.6.0",
  "date-fns-tz": "^3.2.0",
  "embla-carousel": "^8.6.0",
  "embla-carousel-react": "^8.6.0",
  "input-otp": "^1.4.2",
  "lucide-react": "^0.462.0",
  "luxon": "^3.7.2",
  "nanoid": "^5.1.6",
  "next-themes": "^0.3.0",
  "react": "^18.3.1",
  "react-day-picker": "^8.10.1",
  "react-dom": "^18.3.1",
  "react-hook-form": "^7.61.1",
  "react-resizable-panels": "^2.1.9",
  "react-router-dom": "^6.30.1",
  "recharts": "^2.15.4",
  "sonner": "^1.7.4",
  "tailwind-merge": "^2.6.0",
  "tailwindcss-animate": "^1.0.7",
  "vaul": "^0.9.9",
  "zod": "^3.25.76"
}
{
  "@eslint/js": "latest",
  "@tailwindcss/typography": "^0.5.16",
  "@types/node": "^22.16.5",
  "@types/react": "^18.3.23",
  "@types/react-dom": "^18.3.7",
  "@vitejs/plugin-react-swc": "^3.11.0",
  "autoprefixer": "^10.4.21",
  "eslint": "^9.32.0",
  "eslint-plugin-react-hooks": "^5.2.0",
  "eslint-plugin-react-refresh": "^0.4.20",
  "globals": "^15.15.0",
  "lovable-tagger": "^1.1.10",
  "postcss": "^8.5.6",
  "supabase": "^2.53.6",
  "tailwindcss": "^3.4.17",
  "typescript": "^5.8.3",
  "typescript-eslint": "^8.38.0",
  "vite": "^5.4.19"
}

VITE_SUPABASE_PROJECT_ID="cgqyfpsfymhntumrmbzj"
VITE_SUPABASE_PUBLISHABLE_KEY="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNncXlmcHNmeW1obnR1bXJtYnpqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwNjQzOTcsImV4cCI6MjA3MzY0MDM5N30.8UNzCZP9tB4bP3jzhZBMhg5IwEIhxId_Ezg8wMLXm3Q"
VITE_SUPABASE_URL="https://cgqyfpsfymhntumrmbzj.supabase.co"

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  // Allows to automatically instantiate createClient with right options
  // instead of createClient<Database, { PostgrestVersion: 'XX' }>(URL, KEY)
  __InternalSupabase: {
    PostgrestVersion: "13.0.5"
  }
  public: {
    Tables: {
      active_payment_gateway: {
        Row: {
          gateway_name: string
          id: number
          updated_at: string | null
        }
        Insert: {
          gateway_name: string
          id?: number
          updated_at?: string | null
        }
        Update: {
          gateway_name?: string
          id?: number
          updated_at?: string | null
        }
        Relationships: []
      }
      admin_financial_entries: {
        Row: {
          admin_user_id: string
          created_at: string | null
          description: string
          id: string
          subscriber_id: string
          type: Database["public"]["Enums"]["transaction_type"]
          value: number
        }
        Insert: {
          admin_user_id: string
          created_at?: string | null
          description: string
          id?: string
          subscriber_id: string
          type: Database["public"]["Enums"]["transaction_type"]
          value: number
        }
        Update: {
          admin_user_id?: string
          created_at?: string | null
          description?: string
          id?: string
          subscriber_id?: string
          type?: Database["public"]["Enums"]["transaction_type"]
          value?: number
        }
        Relationships: [
          {
            foreignKeyName: "admin_financial_entries_admin_user_id_fkey"
            columns: ["admin_user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "admin_financial_entries_subscriber_id_fkey"
            columns: ["subscriber_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      automations: {
        Row: {
          client_ids: string[]
          created_at: string
          days_offset: number
          id: string
          scheduled_time: string
          template_id: string
          updated_at: string
          user_id: string
        }
        Insert: {
          client_ids: string[]
          created_at?: string
          days_offset: number
          id?: string
          scheduled_time?: string
          template_id: string
          updated_at?: string
          user_id: string
        }
        Update: {
          client_ids?: string[]
          created_at?: string
          days_offset?: number
          id?: string
          scheduled_time?: string
          template_id?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "automations_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "templates"
            referencedColumns: ["id"]
          },
        ]
      }
      clients: {
        Row: {
          created_at: string
          due_date: string
          email: string | null
          id: string
          name: string
          next_billing_date: string
          notes: string | null
          phone: string
          plan_id: string | null
          status: Database["public"]["Enums"]["client_status"]
          updated_at: string
          user_id: string
          value: number
        }
        Insert: {
          created_at?: string
          due_date: string
          email?: string | null
          id?: string
          name: string
          next_billing_date: string
          notes?: string | null
          phone: string
          plan_id?: string | null
          status?: Database["public"]["Enums"]["client_status"]
          updated_at?: string
          user_id: string
          value: number
        }
        Update: {
          created_at?: string
          due_date?: string
          email?: string | null
          id?: string
          name?: string
          next_billing_date?: string
          notes?: string | null
          phone?: string
          plan_id?: string | null
          status?: Database["public"]["Enums"]["client_status"]
          updated_at?: string
          user_id?: string
          value?: number
        }
        Relationships: [
          {
            foreignKeyName: "clients_plan_id_fkey"
            columns: ["plan_id"]
            isOneToOne: false
            referencedRelation: "plans"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "clients_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      connection_status: {
        Row: {
          id: string
          instance_name: string
          last_updated: string
          qr_code_base64: string | null
          status: string
          user_id: string
        }
        Insert: {
          id?: string
          instance_name: string
          last_updated?: string
          qr_code_base64?: string | null
          status?: string
          user_id: string
        }
        Update: {
          id?: string
          instance_name?: string
          last_updated?: string
          qr_code_base64?: string | null
          status?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "connection_status_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      evolution_api_history: {
        Row: {
          client_id: string | null
          client_name_snapshot: string | null
          id: string
          payload: Json
          request_payload: Json | null
          response_payload: Json | null
          status_code: number | null
          template_id: string | null
          timestamp: string
          user_id: string | null
          webhook_type: string
        }
        Insert: {
          client_id?: string | null
          client_name_snapshot?: string | null
          id?: string
          payload: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          user_id?: string | null
          webhook_type: string
        }
        Update: {
          client_id?: string | null
          client_name_snapshot?: string | null
          id?: string
          payload?: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          user_id?: string | null
          webhook_type?: string
        }
        Relationships: [
          {
            foreignKeyName: "evolution_api_history_client_id_fkey"
            columns: ["client_id"]
            isOneToOne: false
            referencedRelation: "clients"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "evolution_api_history_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "templates"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "evolution_api_history_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      evolution_logout_history: {
        Row: {
          client_id: string | null
          client_name_snapshot: string | null
          id: string
          payload: Json
          request_payload: Json | null
          response_payload: Json | null
          status_code: number | null
          template_id: string | null
          timestamp: string
          user_id: string | null
          webhook_type: string
        }
        Insert: {
          client_id?: string | null
          client_name_snapshot?: string | null
          id?: string
          payload: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          user_id?: string | null
          webhook_type: string
        }
        Update: {
          client_id?: string | null
          client_name_snapshot?: string | null
          id?: string
          payload?: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          user_id?: string | null
          webhook_type?: string
        }
        Relationships: [
          {
            foreignKeyName: "evolution_logout_history_client_id_fkey"
            columns: ["client_id"]
            isOneToOne: false
            referencedRelation: "clients"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "evolution_logout_history_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "templates"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "evolution_logout_history_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      financial_entries: {
        Row: {
          created_at: string | null
          description: string
          id: string
          type: Database["public"]["Enums"]["transaction_type"]
          user_id: string
          value: number
        }
        Insert: {
          created_at?: string | null
          description: string
          id?: string
          type: Database["public"]["Enums"]["transaction_type"]
          user_id: string
          value: number
        }
        Update: {
          created_at?: string | null
          description?: string
          id?: string
          type?: Database["public"]["Enums"]["transaction_type"]
          user_id?: string
          value?: number
        }
        Relationships: []
      }
      logs: {
        Row: {
          action: string
          created_at: string
          details: Json | null
          id: string
          user_id: string
        }
        Insert: {
          action: string
          created_at?: string
          details?: Json | null
          id?: string
          user_id: string
        }
        Update: {
          action?: string
          created_at?: string
          details?: Json | null
          id?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "logs_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      mercado_pago_charges: {
        Row: {
          created_at: string | null
          id: string
          mercado_pago_payment_id: string
          status: string
          subscription_id: string
          user_id: string
          value: number
        }
        Insert: {
          created_at?: string | null
          id?: string
          mercado_pago_payment_id: string
          status?: string
          subscription_id: string
          user_id: string
          value: number
        }
        Update: {
          created_at?: string | null
          id?: string
          mercado_pago_payment_id?: string
          status?: string
          subscription_id?: string
          user_id?: string
          value?: number
        }
        Relationships: [
          {
            foreignKeyName: "mercado_pago_charges_subscription_id_fkey"
            columns: ["subscription_id"]
            isOneToOne: false
            referencedRelation: "subscriptions"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "mercado_pago_charges_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      mercado_pago_configs: {
        Row: {
          id: number
          mercado_pago_access_token: string
          mercado_pago_client_id: string
          mercado_pago_client_secret: string
          mercado_pago_public_key: string
          updated_at: string | null
        }
        Insert: {
          id?: number
          mercado_pago_access_token: string
          mercado_pago_client_id: string
          mercado_pago_client_secret: string
          mercado_pago_public_key: string
          updated_at?: string | null
        }
        Update: {
          id?: number
          mercado_pago_access_token?: string
          mercado_pago_client_id?: string
          mercado_pago_client_secret?: string
          mercado_pago_public_key?: string
          updated_at?: string | null
        }
        Relationships: []
      }
      n8n_message_sender_history: {
        Row: {
          client_id: string | null
          client_name_snapshot: string | null
          id: string
          payload: Json
          request_payload: Json | null
          response_payload: Json | null
          status_code: number | null
          template_id: string | null
          timestamp: string
          user_id: string | null
          webhook_type: string
        }
        Insert: {
          client_id?: string | null
          client_name_snapshot?: string | null
          id?: string
          payload: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          user_id?: string | null
          webhook_type: string
        }
        Update: {
          client_id?: string | null
          id?: string
          payload?: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          user_id?: string | null
          webhook_type?: string
        }
        Relationships: [
          {
            foreignKeyName: "n8n_message_sender_history_client_id_fkey"
            columns: ["client_id"]
            isOneToOne: false
            referencedRelation: "clients"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "n8n_message_sender_history_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "templates"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "n8n_message_sender_history_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      n8n_qr_code_history: {
        Row: {
          client_id: string | null
          client_name_snapshot: string | null
          id: string
          payload: Json
          request_payload: Json | null
          response_payload: Json | null
          status_code: number | null
          template_id: string | null
          timestamp: string
          user_id: string | null
          webhook_type: string
        }
        Insert: {
          client_id?: string | null
          client_name_snapshot?: string | null
          id?: string
          payload: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          user_id?: string | null
          webhook_type: string
        }
        Update: {
          client_id?: string | null
          client_name_snapshot?: string | null
          id?: string
          payload?: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          user_id?: string | null
          webhook_type?: string
        }
        Relationships: [
          {
            foreignKeyName: "n8n_qr_code_history_client_id_fkey"
            columns: ["client_id"]
            isOneToOne: false
            referencedRelation: "clients"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "n8n_qr_code_history_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "templates"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "n8n_qr_code_history_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      pagbank_charges: {
        Row: {
          created_at: string | null
          id: string
          pagbank_charge_id: string
          status: string
          subscription_id: string
          user_id: string
          value: number
        }
        Insert: {
          created_at?: string | null
          id?: string
          pagbank_charge_id: string
          status?: string
          subscription_id: string
          user_id: string
          value: number
        }
        Update: {
          created_at?: string | null
          id?: string
          pagbank_charge_id?: string
          status?: string
          subscription_id?: string
          user_id?: string
          value?: number
        }
        Relationships: [
          {
            foreignKeyName: "pagbank_charges_subscription_id_fkey"
            columns: ["subscription_id"]
            isOneToOne: false
            referencedRelation: "subscriptions"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "pagbank_charges_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      pagbank_configs: {
        Row: {
          id: number
          pagbank_email: string
          pagbank_pix_key: string
          pagbank_token: string
          updated_at: string | null
          environment: Database["public"]["Enums"]["pagbank_environment"]
        }
        Insert: {
          id?: number
          pagbank_email: string
          pagbank_pix_key: string
          pagbank_token: string
          updated_at?: string | null
          environment?: Database["public"]["Enums"]["pagbank_environment"]
        }
        Update: {
          id?: number
          pagbank_email?: string
          pagbank_pix_key?: string
          pagbank_token?: string
          updated_at?: string | null
          environment?: Database["public"]["Enums"]["pagbank_environment"]
        }
        Relationships: []
      }
      pending_sends: {
        Row: {
          automation_id: string
          client_id: string
          created_at: string
          id: string
          scheduled_for: string
          template_id: string
          user_id: string
        }
        Insert: {
          automation_id: string
          client_id: string
          created_at?: string
          id?: string
          scheduled_for: string
          template_id: string
          user_id: string
        }
        Update: {
          automation_id?: string
          client_id?: string
          created_at?: string
          id?: string
          scheduled_for?: string
          template_id?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "pending_sends_automation_id_fkey"
            columns: ["automation_id"]
            isOneToOne: false
            referencedRelation: "automations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "pending_sends_client_id_fkey"
            columns: ["client_id"]
            isOneToOne: false
            referencedRelation: "clients"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "pending_sends_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "templates"
            referencedColumns: ["id"]
          },
        ]
      }
      plans: {
        Row: {
          created_at: string
          id: string
          name: string
          period_days: number
          updated_at: string
          user_id: string
          value: number
        }
        Insert: {
          created_at?: string
          id?: string
          name: string
          period_days: number
          updated_at?: string
          user_id: string
          value: number
        }
        Update: {
          created_at?: string
          id?: string
          name?: string
          period_days?: number
          updated_at?: string
          user_id?: string
          value?: number
        }
        Relationships: [
          {
            foreignKeyName: "plans_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      profiles: {
        Row: {
          created_at: string
          email: string
          id: string
          name: string
          updated_at: string
          pix_key: string | null
          phone: string | null
          tax_id: string | null
        }
        Insert: {
          created_at?: string
          email: string
          id: string
          name: string
          updated_at?: string
          pix_key?: string | null
          phone?: string | null
          tax_id?: string | null
        }
        Update: {
          created_at?: string
          email?: string
          id?: string
          name?: string
          updated_at?: string
          pix_key?: string | null
          phone?: string | null
          tax_id?: string | null
        }
        Relationships: []
      }
      scheduled_notifications: {
        Row: {
          automation_id: string
          client_id: string
          created_at: string | null
          id: string
          send_at: string
          status: string
          template_id: string
          user_id: string
          type: string
        }
        Insert: {
          automation_id: string
          client_id: string
          created_at?: string | null
          id?: string
          send_at: string
          status?: string
          template_id: string
          user_id: string
          type?: string
        }
        Update: {
          automation_id?: string
          client_id?: string
          created_at?: string | null
          id?: string
          send_at?: string
          status?: string
          template_id?: string
          user_id?: string
          type?: string
        }
        Relationships: [
          {
            foreignKeyName: "scheduled_notifications_automation_id_fkey"
            columns: ["automation_id"]
            isOneToOne: false
            referencedRelation: "automations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "scheduled_notifications_client_id_fkey"
            columns: ["client_id"]
            isOneToOne: false
            referencedRelation: "clients"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "scheduled_notifications_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "templates"
            referencedColumns: ["id"]
          },
        ]
      }
      send_history: {
        Row: {
          client_id: string
          error_message: string | null
          id: string
          sent_at: string
          status: string
          template_id: string
          user_id: string
        }
        Insert: {
          client_id: string
          error_message?: string | null
          id?: string
          sent_at?: string
          status: string
          template_id: string
          user_id: string
        }
        Update: {
          client_id?: string
          error_message?: string | null
          id?: string
          sent_at?: string
          status?: string
          template_id?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "send_history_client_id_fkey"
            columns: ["client_id"]
            isOneToOne: false
            referencedRelation: "clients"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "send_history_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "templates"
            referencedColumns: ["id"]
          },
        ]
      }
      subscriber_automations: {
        Row: {
          admin_user_id: string
          created_at: string
          days_offset: number
          id: string
          scheduled_time: string
          subscriber_ids: string[]
          subscriber_template_id: string
          updated_at: string
        }
        Insert: {
          admin_user_id: string
          created_at?: string
          days_offset: number
          id?: string
          scheduled_time?: string
          subscriber_ids: string[]
          subscriber_template_id: string
          updated_at?: string
        }
        Update: {
          admin_user_id?: string
          created_at?: string
          days_offset?: number
          id?: string
          scheduled_time?: string
          subscriber_ids?: string[]
          subscriber_template_id?: string
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "subscriber_automations_admin_user_id_fkey"
            columns: ["admin_user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "subscriber_automations_subscriber_template_id_fkey"
            columns: ["subscriber_template_id"]
            isOneToOne: false
            referencedRelation: "subscriber_templates"
            referencedColumns: ["id"]
          },
        ]
      }
      subscriber_plans: {
        Row: {
          created_at: string
          id: string
          name: string
          period_days: number
          updated_at: string
          value: number
          is_free: boolean // Adicionado
        }
        Insert: {
          created_at?: string
          id?: string
          name: string
          period_days: number
          updated_at?: string
          value: number
          is_free?: boolean // Adicionado
        }
        Update: {
          created_at?: string
          id?: string
          name?: string
          period_days?: number
          updated_at?: string
          value?: number
          is_free?: boolean // Adicionado
        }
        Relationships: []
      }
      subscriber_templates: {
        Row: {
          admin_user_id: string | null
          content: string
          created_at: string
          id: string
          name: string
          type: Database["public"]["Enums"]["template_type"]
          updated_at: string
        }
        Insert: {
          admin_user_id?: string | null
          content: string
          created_at?: string
          id?: string
          name: string
          type?: Database["public"]["Enums"]["template_type"]
          updated_at?: string
        }
        Update: {
          admin_user_id?: string | null
          content?: string
          created_at?: string
          id?: string
          name?: string
          type?: Database["public"]["Enums"]["template_type"]
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "subscriber_templates_admin_user_id_fkey"
            columns: ["admin_user_id"]
            isOneToOne: false
            referencedRelation: "users"
            referencedColumns: ["id"]
          },
        ]
      }
      subscriptions: {
        Row: {
          created_at: string
          id: string
          next_billing_date: string
          plan_name: string
          price: number
          status: string
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          next_billing_date: string
          plan_name: string
          price: number
          status?: string
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          next_billing_date?: string
          plan_name?: string
          price?: number
          status?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      templates: {
        Row: {
          content: string
          created_at: string
          id: string
          name: string
          updated_at: string
          user_id: string | null
          type: Database["public"]["Enums"]["template_type"]
        }
        Insert: {
          content: string
          created_at?: string
          id?: string
          name: string
          updated_at?: string
          user_id?: string | null
          type?: Database["public"]["Enums"]["template_type"]
        }
        Update: {
          content?: string
          created_at?: string
          id?: string
          name?: string
          updated_at?: string
          user_id?: string | null
          type?: Database["public"]["Enums"]["template_type"]
        }
        Relationships: [
          {
            foreignKeyName: "templates_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      url_configs: {
        Row: {
          evolution_listener_url: string
          id: number
          n8n_webhook_url: string
        }
        Insert: {
          evolution_listener_url: string
          id?: number
          n8n_webhook_url: string
        }
        Update: {
          evolution_listener_url?: string
          id?: number
          n8n_webhook_url?: string
        }
        Relationships: []
      }
      user_instances: {
        Row: {
          created_at: string
          id: string
          instance_name: string
          qr_code_base64: string | null
          status: string
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          instance_name: string
          qr_code_base64?: string | null
          status?: string
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          instance_name?: string
          qr_code_base64?: string | null
          status?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      user_roles: {
        Row: {
          created_at: string
          id: string
          role: Database["public"]["Enums"]["app_role"]
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          role?: Database["public"]["Enums"]["app_role"]
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          role?: Database["public"]["Enums"]["app_role"]
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "user_roles_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      webhook_configs: {
        Row: {
          client_name_snapshot: string | null
          created_at: string
          id: string
          payload: Json
          request_payload: Json | null
          response_payload: Json | null
          status_code: number | null
          template_id: string | null
          timestamp: string
          type: string
          updated_at: string
          url: string
          user_id: string
        }
        Insert: {
          client_name_snapshot?: string | null
          created_at?: string
          id?: string
          payload: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          type: string
          updated_at?: string
          url: string
          user_id: string
        }
        Update: {
          client_name_snapshot?: string | null
          created_at?: string
          id?: string
          payload?: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          type?: string
          updated_at?: string
          url?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "webhook_configs_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      webhook_history: {
        Row: {
          client_id: string | null
          id: string
          payload: Json
          request_payload: Json | null
          response_payload: Json | null
          status_code: number | null
          template_id: string | null
          timestamp: string
          user_id: string
          webhook_type: string
        }
        Insert: {
          client_id?: string | null
          id?: string
          payload: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          user_id: string
          webhook_type: string
        }
        Update: {
          client_id?: string | null
          id?: string
          payload?: Json
          request_payload?: Json | null
          response_payload?: Json | null
          status_code?: number | null
          template_id?: string | null
          timestamp?: string
          user_id?: string
          webhook_type?: string
        }
        Relationships: [
          {
            foreignKeyName: "webhook_history_client_id_fkey"
            columns: ["client_id"]
            isOneToOne: false
            referencedRelation: "clients"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "webhook_history_template_id_fkey"
            columns: ["template_id"]
            isOneToOne: false
            referencedRelation: "templates"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "webhook_history_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      bytea_to_text: {
        Args: { data: string }
        Returns: string
      }
      http: {
        Args: { request: Database["public"]["CompositeTypes"]["http_request"] }
        Returns: Database["public"]["CompositeTypes"]["http_response"]
      }
      http_delete: {
        Args:
          | { content: string; content_type: string; uri: string }
          | { uri: string }
        Returns: Database["public"]["CompositeTypes"]["http_response"]
      }
      http_get: {
        Args: { data: Json; uri: string } | { uri: string }
        Returns: Database["public"]["CompositeTypes"]["http_response"]
      }
      http_head: {
        Args: { uri: string }
        Returns: Database["public"]["CompositeTypes"]["http_response"]
      }
      http_header: {
        Args: { field: string; value: string }
        Returns: Database["public"]["CompositeTypes"]["http_header"]
      }
      http_list_curlopt: {
        Args: Record<PropertyKey, never>
        Returns: {
          curlopt: string
          value: string
        }[]
      }
      http_patch: {
        Args: { content: string; content_type: string; uri: string }
        Returns: Database["public"]["CompositeTypes"]["http_response"]
      }
      http_post: {
        Args:
          | { content: string; content_type: string; uri: string }
          | { data: Json; uri: string }
        Returns: Database["public"]["CompositeTypes"]["http_response"]
      }
      http_put: {
        Args: { content: string; content_type: string; uri: string }
        Returns: Database["public"]["CompositeTypes"]["http_response"]
      }
      http_reset_curlopt: {
        Args: Record<PropertyKey, never>
        Returns: boolean
      }
      http_set_curlopt: {
        Args: { curlopt: string; value: string }
        Returns: boolean
      }
      process_automated_notifications: {
        Args: Record<PropertyKey, never>
        Returns: undefined
      }
      process_notification_queue: {
        Args: Record<PropertyKey, never>
        Returns: undefined
      }
      text_to_bytea: {
        Args: { data: string }
        Returns: string
      }
      urlencode: {
        Args: { data: Json } | { string: string } | { string: string }
        Returns: string
      }
    }
    Enums: {
      app_role: "admin" | "user"
      client_status: "active" | "inactive" | "overdue"
      transaction_type: "credit" | "debit"
      template_type: "normal" | "global"
      pagbank_environment: "sandbox" | "production"
    }
    CompositeTypes: {
      http_header: {
        field: string | null
        value: string | null
      }
      http_request: {
        method: unknown | null
        uri: string | null
        headers: Database["public"]["CompositeTypes"]["http_header"][] | null
        content_type: string | null
        content: string | null
      }
      http_response: {
        status: number | null
        content_type: string | null
        headers: Database["public"]["CompositeTypes"]["http_header"][] | null
        content: string | null
      }
    }
  }
}

type DatabaseWithoutInternals = Omit<Database, "__InternalSupabase">

type DefaultSchema = DatabaseWithoutInternals[Extract<keyof Database, "public">]

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      DefaultSchema["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof DatabaseWithoutInternals },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof DatabaseWithoutInternals },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never

export const Constants = {
  public: {
    Enums: {
      app_role: ["admin", "user"],
      client_status: ["active", "inactive", "overdue"],
      transaction_type: ["credit", "debit"],
      template_type: ["normal", "global"],
      pagbank_environment: ["sandbox", "production"],
    },
  },
} as const
import { Toaster as Sonner } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { BrowserRouter, Routes, Route, Navigate } from "react-router-dom";
import Auth from "./pages/Auth";
import Dashboard from "./pages/Dashboard";
import Clients from "./pages/Clients";
import Plans from "./pages/Plans";
import Templates from "./pages/Templates";
import Automations from "./pages/Automations";
import Connection from "./pages/Connection";
import ConnectionMetrics from "@/pages/Connection/Metrics";
import Webhooks from "@/pages/Connection/Webhooks";
import Extrato from "./pages/financeiro/Extrato";
import Relatorios from "./pages/financeiro/Relatorios";
import Analise from "./pages/financeiro/Analise";
import Profile from "./pages/Profile";
import NotFound from "./pages/NotFound";
import { ProtectedRoute } from "./components/ProtectedRoute";
import { MainLayout } from "./components/layout/MainLayout";
import { AuthProvider } from "./contexts/AuthContext"; // Import AuthProvider

// NOVO: Importar pÃ¡ginas de admin
import AdminExtrato from "./pages/financeiroADM/Extrato";
import AdminRelatorios from "./pages/financeiroADM/Relatorios";
import AdminAnalise from "./pages/financeiroADM/Analise";
import AdminUsuarios from "./pages/assinantes/Usuarios";
import AdminPlanos from "./pages/assinantes/Planos";
import AdminTemplates from "./pages/assinantes/Templates";
import AdminAutomacoes from "./pages/assinantes/Automacoes";
import IntegracaoPagbank from "./pages/assinantes/Integracao";


const queryClient = new QueryClient();

const App = () => (
  <QueryClientProvider client={queryClient}>
    <TooltipProvider>
      <Sonner />
      <BrowserRouter>
        <AuthProvider> {/* Wrap the entire application with AuthProvider */}
          <Routes>
            <Route path="/" element={<Navigate to="/dashboard" replace />} />
            <Route path="/auth" element={<Auth />} />
            <Route
              path="/dashboard"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <Dashboard />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/clients"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <Clients />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/plans"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <Plans />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/templates"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <Templates />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            {/* Rotas para a seÃ§Ã£o ConexÃ£o */}
            <Route
              path="/connection/whatsapp"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <Connection />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/connection/automations"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <Automations />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/connection/metrics"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <ConnectionMetrics />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/connection/webhooks"
              element={
                <ProtectedRoute requiredRole="admin">
                  <MainLayout>
                    <Webhooks />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/profile"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <Profile />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            {/* Rotas para a seÃ§Ã£o Financeiro */}
            <Route
              path="/financeiro/extrato"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <Extrato />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/financeiro/relatorios"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <Relatorios />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/financeiro/analise"
              element={
                <ProtectedRoute>
                  <MainLayout>
                    <Analise />
                  </MainLayout>
                </ProtectedRoute>
              }
            />

            {/* NOVO: Rotas para a seÃ§Ã£o Financeiro Admin */}
            <Route
              path="/financeiroADM/extrato"
              element={
                <ProtectedRoute requiredRole="admin">
                  <MainLayout>
                    <AdminExtrato />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/financeiroADM/relatorios"
              element={
                <ProtectedRoute requiredRole="admin">
                  <MainLayout>
                    <AdminRelatorios />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/financeiroADM/analise"
              element={
                <ProtectedRoute requiredRole="admin">
                  <MainLayout>
                    <AdminAnalise />
                  </MainLayout>
                </ProtectedRoute>
              }
            />

            {/* NOVO: Rotas para a seÃ§Ã£o Gerenciamento de Assinantes */}
            <Route
              path="/assinantes/usuarios"
              element={
                <ProtectedRoute requiredRole="admin">
                  <MainLayout>
                    <AdminUsuarios />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/assinantes/planos"
              element={
                <ProtectedRoute requiredRole="admin">
                  <MainLayout>
                    <AdminPlanos />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/assinantes/templates"
              element={
                <ProtectedRoute requiredRole="admin">
                  <MainLayout>
                    <AdminTemplates />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            <Route
              path="/assinantes/automacoes"
              element={
                <ProtectedRoute requiredRole="admin">
                  <MainLayout>
                    <AdminAutomacoes />
                  </MainLayout>
                </ProtectedRoute>
              }
            />
            {/* NOVO: Rota para integraÃ§Ã£o PagBank */}
            <Route
              path="/assinantes/integracao"
              element={
                <ProtectedRoute requiredRole="admin">
                  <MainLayout>
                    <IntegracaoPagbank />
                  </MainLayout>
                </ProtectedRoute>
              }
            />

            <Route path="*" element={<NotFound />} />
          </Routes>
        </AuthProvider>
      </BrowserRouter>
    </TooltipProvider>
  </QueryClientProvider>
);

export default App;

--- ConteÃºdo de: supabase/migrations/0000_executando_um_script_sql_abrangente_e_corrigido_para_recriar_o_esquema_do_banco_de_dados_supabase_de_forma_idempotente_garantindo_que_apenas_o_c_digo_sql_v_lido_seja_executado_.sql ---
-- Desabilitar verificaÃ§Ãµes de chaves estrangeiras temporariamente para permitir a exclusÃ£o de tabelas em qualquer ordem
SET session_replication_role = 'replica';

-- 1. Remover Triggers existentes (se houver)
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users CASCADE;
DROP TRIGGER IF EXISTS update_profiles_updated_at ON public.profiles CASCADE;
DROP TRIGGER IF EXISTS update_plans_updated_at ON public.plans CASCADE;
DROP TRIGGER IF EXISTS update_clients_updated_at ON public.clients CASCADE;
DROP TRIGGER IF EXISTS update_templates_updated_at ON public.templates CASCADE;

-- 2. Remover PolÃ­ticas RLS existentes (se houver)
DROP POLICY IF EXISTS "Users can view their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can view their own roles" ON public.user_roles;
DROP POLICY IF EXISTS "Users can manage their own plans" ON public.plans;
DROP POLICY IF EXISTS "Users can manage their own clients" ON public.clients;
DROP POLICY IF EXISTS "Users can manage their own templates" ON public.templates;
DROP POLICY IF EXISTS "Users can view their own logs" ON public.logs;
DROP POLICY IF EXISTS "Users can create their own logs" ON public.logs;

-- 3. Remover Tabelas existentes (se houver, em ordem inversa de dependÃªncia)
DROP TABLE IF EXISTS public.logs CASCADE;
DROP TABLE IF EXISTS public.clients CASCADE;
DROP TABLE IF EXISTS public.plans CASCADE;
DROP TABLE IF EXISTS public.user_roles CASCADE;
DROP TABLE IF EXISTS public.templates CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

-- 4. Remover FunÃ§Ãµes existentes (se houver)
DROP FUNCTION IF EXISTS public.handle_new_user CASCADE;
DROP FUNCTION IF EXISTS public.update_updated_at_column CASCADE;

-- 5. Remover Tipos ENUM existentes (se houver)
DROP TYPE IF EXISTS public.app_role CASCADE;
DROP TYPE IF EXISTS public.client_status CASCADE;
DROP TYPE IF EXISTS public.template_category CASCADE;

-- Reabilitar verificaÃ§Ãµes de chaves estrangeiras
SET session_replication_role = 'origin';

-- InÃ­cio da recriaÃ§Ã£o do esquema

-- 1. Criar Tipos ENUM
CREATE TYPE public.app_role AS ENUM ('admin', 'user');
CREATE TYPE public.client_status AS ENUM ('active', 'inactive', 'overdue');
CREATE TYPE public.template_category AS ENUM ('pre_due', 'due_today', 'overdue', 'celebratory');

-- 2. Criar FunÃ§Ãµes
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, name, email)
  VALUES (NEW.id, COALESCE(NEW.raw_user_meta_data->>'name', split_part(NEW.email, '@', 1)), NEW.email);
  INSERT INTO public.user_roles (user_id, role)
  VALUES (NEW.id, 'user');
  RETURN NEW;
END;
$$;

-- 3. Criar Tabelas
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE public.user_roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  role app_role NOT NULL DEFAULT 'user',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(user_id, role)
);

CREATE TABLE public.plans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  value DECIMAL(10, 2) NOT NULL,
  period_days INTEGER NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE public.clients (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  phone TEXT NOT NULL,
  email TEXT,
  notes TEXT,
  plan_id UUID REFERENCES public.plans(id) ON DELETE SET NULL,
  due_date DATE NOT NULL,
  next_billing_date DATE NOT NULL,
  status client_status NOT NULL DEFAULT 'active',
  value DECIMAL(10, 2) NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE public.templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  category template_category NOT NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE public.logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  action TEXT NOT NULL,
  details JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- 4. Habilitar Row Level Security
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.clients ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.logs ENABLE ROW LEVEL SECURITY;

-- 5. Criar PolÃ­ticas RLS
CREATE POLICY "Users can view their own profile" ON public.profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Users can update their own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "Users can view their own roles" ON public.user_roles FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can manage their own plans" ON public.plans FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can manage their own clients" ON public.clients FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can manage their own templates" ON public.templates FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can view their own logs" ON public.logs FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can create their own logs" ON public.logs FOR INSERT WITH CHECK (auth.uid() = user_id);

-- 6. Criar Triggers
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

CREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE TRIGGER update_plans_updated_at BEFORE UPDATE ON public.plans FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE TRIGGER update_clients_updated_at BEFORE UPDATE ON public.clients FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
CREATE TRIGGER update_templates_updated_at BEFORE UPDATE ON public.templates FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
--- ConteÃºdo de: supabase/migrations/0001_atualizando_a_pol_tica_rls_de_inser_o_para_a_tabela_profiles_para_usar_uma_subquery_para_auth_uid_para_resolver_poss_veis_problemas_de_contexto_durante_a_cria_o_de_perfil_pelo_cliente_.sql ---
-- Remover a polÃ­tica de inserÃ§Ã£o existente para perfis
DROP POLICY IF EXISTS "profiles_insert_policy" ON public.profiles;

-- Criar uma nova polÃ­tica de inserÃ§Ã£o para perfis usando uma subquery para auth.uid()
CREATE POLICY "profiles_insert_policy" ON public.profiles
FOR INSERT TO authenticated WITH CHECK (id = (SELECT auth.uid()));
--- ConteÃºdo de: supabase/migrations/0002_criando_o_tipo_enum_transaction_type_e_a_tabela_financial_entries_com_rls_e_pol_ticas_de_seguran_a_.sql ---
-- Create ENUM for transaction types
DO $$ BEGIN
  CREATE TYPE public.transaction_type AS ENUM ('credit', 'debit');
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

-- Create financial_entries table
CREATE TABLE public.financial_entries (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  description TEXT NOT NULL,
  value NUMERIC(10, 2) NOT NULL,
  type public.transaction_type NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable RLS (REQUIRED)
ALTER TABLE public.financial_entries ENABLE ROW LEVEL SECURITY;

-- Policies for financial_entries
CREATE POLICY "Users can view their own financial entries" ON public.financial_entries
FOR SELECT TO authenticated USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own financial entries" ON public.financial_entries
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);

-- No update or delete policies by default for financial entries to maintain an immutable ledger.
-- If updates/deletes are needed, specific policies should be added.
--- ConteÃºdo de: supabase/migrations/0003_adicionando_pol_ticas_rls_para_update_e_delete_na_tabela_financial_entries_para_permitir_que_usu_rios_gerenciem_seus_pr_prios_lan_amentos_.sql ---
-- Add UPDATE policy for financial_entries
CREATE POLICY "Users can update their own financial entries" ON public.financial_entries
FOR UPDATE TO authenticated USING (auth.uid() = user_id);

-- Add DELETE policy for financial_entries
CREATE POLICY "Users can delete their own financial entries" ON public.financial_entries
FOR DELETE TO authenticated USING (auth.uid() = user_id);
--- ConteÃºdo de: supabase/migrations/0004_adicionando_fun_o_e_gatilho_para_definir_o_status_do_cliente_com_base_na_data_de_vencimento_.sql ---
-- 1. Criar a funÃ§Ã£o que serÃ¡ executada pelo gatilho
CREATE OR REPLACE FUNCTION public.set_client_status_based_on_due_date()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- Verifica se o status atual nÃ£o Ã© 'inativo'. NÃ£o queremos reativar um cliente cancelado automaticamente.
  IF NEW.status != 'inactive' THEN
    -- Se a data de vencimento for anterior a hoje, define o status como 'vencido'.
    IF NEW.next_billing_date < CURRENT_DATE THEN
      NEW.status := 'overdue';
    -- Caso contrÃ¡rio, define o status como 'ativo'.
    ELSE
      NEW.status := 'active';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;

-- 2. Criar o gatilho que executa a funÃ§Ã£o antes de qualquer inserÃ§Ã£o ou atualizaÃ§Ã£o na tabela de clientes
-- Primeiro, remove o gatilho antigo se ele existir, para evitar erros
DROP TRIGGER IF EXISTS trigger_set_client_status ON public.clients;

-- Cria o novo gatilho
CREATE TRIGGER trigger_set_client_status
BEFORE INSERT OR UPDATE ON public.clients
FOR EACH ROW
EXECUTE FUNCTION public.set_client_status_based_on_due_date();
--- ConteÃºdo de: supabase/migrations/0005_criando_a_tabela_subscriptions_com_rls_e_trigger_para_gerenciar_assinaturas_de_usu_rios_.sql ---
-- Tabela para armazenar detalhes da assinatura de cada utilizador
CREATE TABLE public.subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
  plan_name TEXT NOT NULL,
  price DECIMAL(10, 2) NOT NULL,
  status TEXT NOT NULL DEFAULT 'inactive', -- ex: 'active', 'inactive', 'past_due'
  next_billing_date DATE NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Habilitar Row Level Security
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;

-- PolÃ­ticas de SeguranÃ§a: Utilizadores sÃ³ podem ver e gerir a sua prÃ³pria assinatura
CREATE POLICY "Users can view their own subscription" ON public.subscriptions
FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can update their own subscription" ON public.subscriptions
FOR UPDATE USING (auth.uid() = user_id);

-- Trigger para atualizar 'updated_at'
CREATE TRIGGER update_subscriptions_updated_at 
BEFORE UPDATE ON public.subscriptions 
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
--- ConteÃºdo de: supabase/migrations/0006_criando_a_tabela_automations_com_rls_e_trigger_para_gerenciar_regras_de_automa_o_.sql ---
-- Tabela para armazenar as regras de envio automÃ¡tico
CREATE TABLE public.automations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  days_offset INT NOT NULL, -- Ex: -3 (3 dias antes), 0 (no dia), 1 (1 dia depois)
  template_id UUID NOT NULL REFERENCES public.templates(id) ON DELETE CASCADE,
  client_ids UUID[] NOT NULL, -- Array de IDs de clientes
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Habilitar Row Level Security
ALTER TABLE public.automations ENABLE ROW LEVEL SECURITY;

-- PolÃ­ticas de SeguranÃ§a: Utilizadores sÃ³ podem gerir as suas prÃ³prias automaÃ§Ãµes
CREATE POLICY "Users can manage their own automations" 
ON public.automations FOR ALL USING (auth.uid() = user_id);

-- Trigger para atualizar 'updated_at'
CREATE TRIGGER update_automations_updated_at 
BEFORE UPDATE ON public.automations 
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
--- ConteÃºdo de: supabase/migrations/0007_criando_as_tabelas_pending_sends_e_send_history_com_rls_para_gerenciar_a_fila_e_o_hist_rico_de_envios_de_mensagens_.sql ---
-- Tabela 1: Fila de envios pendentes
-- Esta tabela irÃ¡ conter todas as mensagens que estÃ£o agendadas para serem enviadas.
CREATE TABLE public.pending_sends (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  client_id UUID NOT NULL REFERENCES public.clients(id) ON DELETE CASCADE,
  automation_id UUID NOT NULL REFERENCES public.automations(id) ON DELETE CASCADE,
  template_id UUID NOT NULL REFERENCES public.templates(id) ON DELETE CASCADE,
  scheduled_for DATE NOT NULL, -- Data exata para a qual o envio estÃ¡ agendado
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  -- Garante que nÃ£o haja agendamentos duplicados para o mesmo cliente na mesma data pela mesma regra
  UNIQUE(client_id, automation_id, scheduled_for) 
);

-- Habilitar Row Level Security
ALTER TABLE public.pending_sends ENABLE ROW LEVEL SECURITY;
-- PolÃ­ticas: Utilizadores sÃ³ podem ver e gerir os seus prÃ³prios envios pendentes
CREATE POLICY "Users can manage their own pending sends" 
ON public.pending_sends FOR ALL USING (auth.uid() = user_id);


-- Tabela 2: HistÃ³rico de envios
-- Esta tabela Ã© um log de todas as tentativas de envio, bem-sucedidas ou nÃ£o.
CREATE TABLE public.send_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  client_id UUID NOT NULL REFERENCES public.clients(id) ON DELETE CASCADE,
  template_id UUID NOT NULL REFERENCES public.templates(id) ON DELETE CASCADE,
  sent_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  status TEXT NOT NULL CHECK (status IN ('success', 'failed')), -- Status final do envio
  error_message TEXT -- Opcional: para armazenar a razÃ£o da falha
);

-- Habilitar Row Level Security
ALTER TABLE public.send_history ENABLE ROW LEVEL SECURITY;
-- PolÃ­ticas: Utilizadores sÃ³ podem ver o seu prÃ³prio histÃ³rico
CREATE POLICY "Users can view their own send history" 
ON public.send_history FOR SELECT USING (auth.uid() = user_id);
--- ConteÃºdo de: supabase/migrations/0008_criando_fun_o_e_gatilho_para_remover_clientes_inativos_de_automa_es_e_da_fila_de_envios_pendentes_.sql ---
-- 1. Criar a funÃ§Ã£o que contÃ©m a lÃ³gica de remoÃ§Ã£o
CREATE OR REPLACE FUNCTION public.handle_client_cancellation()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- A funÃ§Ã£o sÃ³ executa se o status foi alterado PARA 'inactive'
  IF NEW.status = 'inactive' AND OLD.status != 'inactive' THEN
    
    -- AÃ§Ã£o 1: Remover o cliente de todas as futuras mensagens agendadas
    DELETE FROM public.pending_sends
    WHERE client_id = NEW.id;

    -- AÃ§Ã£o 2: Remover o ID do cliente de todas as regras de automaÃ§Ã£o
    -- onde ele possa estar presente.
    UPDATE public.automations
    SET client_ids = array_remove(client_ids, NEW.id)
    WHERE user_id = NEW.user_id AND NEW.id = ANY(client_ids);

  END IF;
  
  RETURN NEW;
END;
$$;

-- 2. Criar o gatilho que executa a funÃ§Ã£o APÃS uma atualizaÃ§Ã£o na tabela de clientes
-- Primeiro, remove o gatilho antigo se ele existir, para evitar erros
DROP TRIGGER IF EXISTS trigger_handle_client_cancellation ON public.clients;

-- Cria o novo gatilho
CREATE TRIGGER trigger_handle_client_cancellation
AFTER UPDATE ON public.clients
FOR EACH ROW
EXECUTE FUNCTION public.handle_client_cancellation();
--- ConteÃºdo de: supabase/migrations/0009_criando_fun_o_e_gatilho_para_remover_clientes_com_status_overdue_da_fila_de_envios_pendentes_.sql ---
-- 1. Criar a funÃ§Ã£o que serÃ¡ executada pelo gatilho
CREATE OR REPLACE FUNCTION public.handle_client_overdue_status()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- A funÃ§Ã£o sÃ³ executa se o status foi alterado PARA 'overdue'
  IF NEW.status = 'overdue' AND OLD.status != 'overdue' THEN
    
    -- AÃ§Ã£o: Remove o cliente de todas as futuras mensagens agendadas
    DELETE FROM public.pending_sends
    WHERE client_id = NEW.id;

  END IF;
  
  RETURN NEW;
END;
$$;

-- 2. Criar o gatilho que executa a funÃ§Ã£o APÃS uma atualizaÃ§Ã£o na tabela de clientes
-- Primeiro, remove o gatilho antigo se ele existir, para evitar erros
DROP TRIGGER IF EXISTS trigger_handle_client_overdue_status ON public.clients;

-- Cria o novo gatilho
CREATE TRIGGER trigger_handle_client_overdue_status
AFTER UPDATE ON public.clients
FOR EACH ROW
EXECUTE FUNCTION public.handle_client_overdue_status();
--- ConteÃºdo de: supabase/migrations/0010_criando_a_tabela_user_instances_para_gerenciar_as_inst_ncias_do_whatsapp_por_usu_rio_com_rls_e_pol_ticas_de_seguran_a_.sql ---
-- Tabela para mapear utilizadores a nomes de instÃ¢ncia da Evolution API
CREATE TABLE public.user_instances (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
  instance_name TEXT NOT NULL UNIQUE,
  status TEXT NOT NULL DEFAULT 'disconnected', -- ex: 'disconnected', 'connecting', 'connected'
  qr_code_base64 TEXT, -- Para armazenar o QR Code temporariamente
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Habilitar Row Level Security
ALTER TABLE public.user_instances ENABLE ROW LEVEL SECURITY;

-- PolÃ­ticas: Utilizadores sÃ³ podem gerir a sua prÃ³pria instÃ¢ncia
CREATE POLICY "Users can manage their own instance mapping" 
ON public.user_instances FOR ALL USING (auth.uid() = user_id);

-- Trigger para atualizar 'updated_at' automaticamente
CREATE TRIGGER update_user_instances_updated_at
BEFORE UPDATE ON public.user_instances
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column();
--- ConteÃºdo de: supabase/migrations/0011_criando_a_tabela_url_configs_para_armazenar_urls_de_configura_o_do_sistema_com_rls_.sql ---
-- Tabela para armazenar URLs de configuraÃ§Ã£o
CREATE TABLE public.url_configs (
  id INT PRIMARY KEY DEFAULT 1,
  n8n_webhook_url TEXT NOT NULL,
  evolution_listener_url TEXT NOT NULL,
  -- Apenas uma linha pode existir nesta tabela
  CONSTRAINT single_row_check CHECK (id = 1)
);

-- Habilitar Row Level Security (RLS)
ALTER TABLE public.url_configs ENABLE ROW LEVEL SECURITY;

-- PolÃ­ticas: Apenas utilizadores autenticados podem ler.
CREATE POLICY "Authenticated users can read url configs" 
ON public.url_configs FOR SELECT TO authenticated USING (true);
--- ConteÃºdo de: supabase/migrations/0013_criando_a_tabela_scheduled_notifications_com_rls_e_refer_ncias_a_clientes_templates_e_automa_es_.sql ---
-- Criar a tabela scheduled_notifications
CREATE TABLE public.scheduled_notifications (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  client_id UUID NOT NULL REFERENCES public.clients(id) ON DELETE CASCADE,
  template_id UUID NOT NULL REFERENCES public.templates(id) ON DELETE CASCADE,
  automation_id UUID NOT NULL REFERENCES public.automations(id) ON DELETE CASCADE, -- Adicionado para vincular Ã  automaÃ§Ã£o
  send_at TIMESTAMPTZ NOT NULL,
  status TEXT DEFAULT 'pending' NOT NULL, -- 'pending', 'processing', 'sent', 'failed'
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Habilitar RLS (OBRIGATÃRIO para seguranÃ§a)
ALTER TABLE public.scheduled_notifications ENABLE ROW LEVEL SECURITY;

-- PolÃ­ticas RLS: UsuÃ¡rios sÃ³ podem gerenciar suas prÃ³prias tarefas agendadas
CREATE POLICY "Users can view their own scheduled notifications" ON public.scheduled_notifications
FOR SELECT TO authenticated USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own scheduled notifications" ON public.scheduled_notifications
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own scheduled notifications" ON public.scheduled_notifications
FOR UPDATE TO authenticated USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own scheduled notifications" ON public.scheduled_notifications
FOR DELETE TO authenticated USING (auth.uid() = user_id);
--- ConteÃºdo de: supabase/migrations/0014_atualizando_a_fun_o_set_client_status_based_on_due_date_para_usar_o_fuso_hor_rio_local_america_sao_paulo_na_determina_o_do_status_do_cliente_.sql ---
CREATE OR REPLACE FUNCTION public.set_client_status_based_on_due_date()
RETURNS trigger
LANGUAGE plpgsql
AS $function$
DECLARE
  local_today DATE;
BEGIN
  -- ObtÃ©m a data de hoje no fuso horÃ¡rio 'America/Sao_Paulo'
  local_today := (NOW() AT TIME ZONE 'America/Sao_Paulo')::DATE;

  -- Apenas atualiza o status se nÃ£o for 'inactive' (cancelado)
  IF NEW.status != 'inactive' THEN
    -- Se a data de vencimento for anterior a local_today, define o status como 'overdue'
    IF NEW.next_billing_date < local_today THEN
      NEW.status := 'overdue';
    -- Caso contrÃ¡rio, se for local_today ou no futuro, define o status como 'active'
    ELSE
      NEW.status := 'active';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$function$;
--- ConteÃºdo de: supabase/migrations/0015_adicionando_colunas_request_payload_e_response_payload_tabela_webhook_history_e_atualizando_rls_.sql ---
-- Adicionar colunas request_payload e response_payload Ã  tabela webhook_history
ALTER TABLE public.webhook_history
ADD COLUMN request_payload JSONB,
ADD COLUMN response_payload JSONB;

-- Atualizar polÃ­ticas RLS para incluir as novas colunas
-- A polÃ­tica de INSERT jÃ¡ permite a inserÃ§Ã£o de todas as colunas por padrÃ£o,
-- mas Ã© bom revisar para garantir que nÃ£o haja restriÃ§Ãµes inesperadas.
-- Se a polÃ­tica de INSERT for 'WITH CHECK (auth.uid() = user_id)', ela jÃ¡ cobre as novas colunas.
-- Se for 'true', tambÃ©m cobre.

-- Exemplo de revisÃ£o/criaÃ§Ã£o de polÃ­tica de INSERT (se necessÃ¡rio, ajuste conforme sua polÃ­tica existente)
-- CREATE OR REPLACE POLICY "Users can insert their own webhook history" ON public.webhook_history
-- FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);

-- A polÃ­tica de SELECT tambÃ©m deve permitir a leitura das novas colunas.
-- CREATE OR REPLACE POLICY "Users can view their own webhook history" ON public.webhook_history
-- FOR SELECT TO authenticated USING (auth.uid() = user_id);

-- Se as polÃ­ticas existentes jÃ¡ sÃ£o abrangentes (e.g., SELECT USING (true) ou INSERT WITH CHECK (true)),
-- nÃ£o Ã© necessÃ¡rio alterÃ¡-las explicitamente para as novas colunas.
-- No entanto, se houver polÃ­ticas mais restritivas, elas precisariam ser atualizadas.
-- Com base no seu schema, as polÃ­ticas existentes para webhook_history sÃ£o:
-- "Users can view their own webhook history" ON webhook_history FOR SELECT USING (auth.uid() = user_id);
-- "Users can insert their own webhook history" ON webhook_history FOR INSERT;
-- A polÃ­tica de INSERT atual Ã© muito permissiva. Vamos ajustÃ¡-la para ser mais segura.

DROP POLICY IF EXISTS "Users can insert their own webhook history" ON public.webhook_history;
CREATE POLICY "Users can insert their own webhook history" ON public.webhook_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);

-- A polÃ­tica de SELECT jÃ¡ estÃ¡ boa.
--- ConteÃºdo de: supabase/migrations/0016_adicionando_colunas_client_id_e_template_id_tabela_webhook_history_e_criando_chaves_estrangeiras_.sql ---
ALTER TABLE public.webhook_history
ADD COLUMN client_id UUID REFERENCES public.clients(id) ON DELETE SET NULL,
ADD COLUMN template_id UUID REFERENCES public.templates(id) ON DELETE SET NULL;

-- As polÃ­ticas RLS existentes para webhook_history jÃ¡ cobrem a inserÃ§Ã£o e seleÃ§Ã£o de todas as colunas
-- para o user_id autenticado, entÃ£o nÃ£o precisam de modificaÃ§Ã£o explÃ­cita para as novas colunas.
-- A polÃ­tica de INSERT jÃ¡ foi ajustada na etapa anterior para ser mais segura.
--- ConteÃºdo de: supabase/migrations/0017_criando_as_tabelas_evolution_api_history_n8n_qr_code_history_e_n8n_message_sender_history_com_rls_e_chaves_estrangeiras_.sql ---
-- Create evolution_api_history table
CREATE TABLE public.evolution_api_history (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  webhook_type TEXT NOT NULL,
  payload JSONB NOT NULL,
  request_payload JSONB,
  response_payload JSONB,
  status_code INTEGER,
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  client_id UUID REFERENCES public.clients(id) ON DELETE SET NULL,
  template_id UUID REFERENCES public.templates(id) ON DELETE SET NULL,
  client_name_snapshot TEXT
);

-- Enable RLS for evolution_api_history
ALTER TABLE public.evolution_api_history ENABLE ROW LEVEL SECURITY;

-- Policies for evolution_api_history
CREATE POLICY "evolution_api_history_select_policy" ON public.evolution_api_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "evolution_api_history_insert_policy" ON public.evolution_api_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "evolution_api_history_update_policy" ON public.evolution_api_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "evolution_api_history_delete_policy" ON public.evolution_api_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Create n8n_qr_code_history table
CREATE TABLE public.n8n_qr_code_history (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  webhook_type TEXT NOT NULL,
  payload JSONB NOT NULL,
  request_payload JSONB,
  response_payload JSONB,
  status_code INTEGER,
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  client_id UUID REFERENCES public.clients(id) ON DELETE SET NULL,
  template_id UUID REFERENCES public.templates(id) ON DELETE SET NULL,
  client_name_snapshot TEXT
);

-- Enable RLS for n8n_qr_code_history
ALTER TABLE public.n8n_qr_code_history ENABLE ROW LEVEL SECURITY;

-- Policies for n8n_qr_code_history
CREATE POLICY "n8n_qr_code_history_select_policy" ON public.n8n_qr_code_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_qr_code_history_insert_policy" ON public.n8n_qr_code_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "n8n_qr_code_history_update_policy" ON public.n8n_qr_code_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_qr_code_history_delete_policy" ON public.n8n_qr_code_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Create n8n_message_sender_history table
CREATE TABLE public.n8n_message_sender_history (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  webhook_type TEXT NOT NULL,
  payload JSONB NOT NULL,
  request_payload JSONB,
  response_payload JSONB,
  status_code INTEGER,
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  client_id UUID REFERENCES public.clients(id) ON DELETE SET NULL,
  template_id UUID REFERENCES public.templates(id) ON DELETE SET NULL,
  client_name_snapshot TEXT
);

-- Enable RLS for n8n_message_sender_history
ALTER TABLE public.n8n_message_sender_history ENABLE ROW LEVEL SECURITY;

-- Policies for n8n_message_sender_history
CREATE POLICY "n8n_message_sender_history_select_policy" ON public.n8n_message_sender_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_message_sender_history_insert_policy" ON public.n8n_message_sender_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "n8n_message_sender_history_update_policy" ON public.n8n_message_sender_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_message_sender_history_delete_policy" ON public.n8n_message_sender_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);
--- ConteÃºdo de: supabase/migrations/0018_criando_a_tabela_evolution_logout_history_com_rls_e_pol_ticas_de_seguran_a_.sql ---
-- Create evolution_logout_history table
CREATE TABLE public.evolution_logout_history (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  webhook_type TEXT NOT NULL,
  payload JSONB NOT NULL,
  request_payload JSONB,
  response_payload JSONB,
  status_code INTEGER,
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  client_id UUID REFERENCES public.clients(id) ON DELETE SET NULL,
  template_id UUID REFERENCES public.templates(id) ON DELETE SET NULL,
  client_name_snapshot TEXT
);

-- Enable RLS (REQUIRED)
ALTER TABLE public.evolution_logout_history ENABLE ROW LEVEL SECURITY;

-- Create policies for each operation
CREATE POLICY "evolution_logout_history_select_policy" ON public.evolution_logout_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);

CREATE POLICY "evolution_logout_history_insert_policy" ON public.evolution_logout_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);

CREATE POLICY "evolution_logout_history_update_policy" ON public.evolution_logout_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);

CREATE POLICY "evolution_logout_history_delete_policy" ON public.evolution_logout_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);
--- ConteÃºdo de: supabase/migrations/0019_updating_rls_policies_for_all_user_specific_tables_to_ensure_multi_tenant_data_isolation_.sql ---
-- Enable RLS on all tables that store user-specific data if not already enabled
ALTER TABLE public.clients ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.automations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.financial_entries ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.scheduled_notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.webhook_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_instances ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.connection_status ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.evolution_api_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.n8n_qr_code_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.n8n_message_sender_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.evolution_logout_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Recreate or update RLS policies for 'clients' table
DROP POLICY IF EXISTS "Users can manage their own clients" ON public.clients;
CREATE POLICY "Users can manage their own clients" ON public.clients
FOR ALL TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Recreate or update RLS policies for 'plans' table
DROP POLICY IF EXISTS "Users can manage their own plans" ON public.plans;
CREATE POLICY "Users can manage their own plans" ON public.plans
FOR ALL TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Recreate or update RLS policies for 'templates' table
DROP POLICY IF EXISTS "Users can manage their own templates" ON public.templates;
CREATE POLICY "Users can manage their own templates" ON public.templates
FOR ALL TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Recreate or update RLS policies for 'automations' table
DROP POLICY IF EXISTS "Users can manage their own automations" ON public.automations;
CREATE POLICY "Users can manage their own automations" ON public.automations
FOR ALL TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Recreate or update RLS policies for 'financial_entries' table
DROP POLICY IF EXISTS "Users can view their own financial entries" ON public.financial_entries;
DROP POLICY IF EXISTS "Users can insert their own financial entries" ON public.financial_entries;
DROP POLICY IF EXISTS "Users can update their own financial entries" ON public.financial_entries;
DROP POLICY IF EXISTS "Users can delete their own financial entries" ON public.financial_entries;
CREATE POLICY "Users can view their own financial entries" ON public.financial_entries
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own financial entries" ON public.financial_entries
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own financial entries" ON public.financial_entries
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own financial entries" ON public.financial_entries
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'scheduled_notifications' table
DROP POLICY IF EXISTS "Users can view their own scheduled notifications" ON public.scheduled_notifications;
DROP POLICY IF EXISTS "Users can insert their own scheduled notifications" ON public.scheduled_notifications;
DROP POLICY IF EXISTS "Users can update their own scheduled notifications" ON public.scheduled_notifications;
DROP POLICY IF EXISTS "Users can delete their own scheduled notifications" ON public.scheduled_notifications;
CREATE POLICY "Users can view their own scheduled notifications" ON public.scheduled_notifications
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own scheduled notifications" ON public.scheduled_notifications
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own scheduled notifications" ON public.scheduled_notifications
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own scheduled notifications" ON public.scheduled_notifications
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'webhook_history' table
DROP POLICY IF EXISTS "Users can view their own webhook history" ON public.webhook_history;
DROP POLICY IF EXISTS "Users can insert their own webhook history" ON public.webhook_history;
CREATE POLICY "Users can view their own webhook history" ON public.webhook_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own webhook history" ON public.webhook_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
-- Add UPDATE and DELETE policies for webhook_history
DROP POLICY IF EXISTS "Users can update their own webhook history" ON public.webhook_history;
DROP POLICY IF EXISTS "Users can delete their own webhook history" ON public.webhook_history;
CREATE POLICY "Users can update their own webhook history" ON public.webhook_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own webhook history" ON public.webhook_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'user_instances' table
DROP POLICY IF EXISTS "Users can manage their own instance mapping" ON public.user_instances;
CREATE POLICY "Users can manage their own instance mapping" ON public.user_instances
FOR ALL TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Recreate or update RLS policies for 'connection_status' table
DROP POLICY IF EXISTS "Users can view their own connection status" ON public.connection_status;
DROP POLICY IF EXISTS "Users can insert their own connection status" ON public.connection_status;
DROP POLICY IF EXISTS "Users can update their own connection status" ON public.connection_status;
DROP POLICY IF EXISTS "Users can delete their own connection status" ON public.connection_status;
CREATE POLICY "Users can view their own connection status" ON public.connection_status
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own connection status" ON public.connection_status
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own connection status" ON public.connection_status
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own connection status" ON public.connection_status
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'evolution_api_history' table
DROP POLICY IF EXISTS "evolution_api_history_select_policy" ON public.evolution_api_history;
DROP POLICY IF EXISTS "evolution_api_history_insert_policy" ON public.evolution_api_history;
DROP POLICY IF EXISTS "evolution_api_history_update_policy" ON public.evolution_api_history;
DROP POLICY IF EXISTS "evolution_api_history_delete_policy" ON public.evolution_api_history;
CREATE POLICY "evolution_api_history_select_policy" ON public.evolution_api_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "evolution_api_history_insert_policy" ON public.evolution_api_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "evolution_api_history_update_policy" ON public.evolution_api_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "evolution_api_history_delete_policy" ON public.evolution_api_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'n8n_qr_code_history' table
DROP POLICY IF EXISTS "n8n_qr_code_history_select_policy" ON public.n8n_qr_code_history;
DROP POLICY IF EXISTS "n8n_qr_code_history_insert_policy" ON public.n8n_qr_code_history;
DROP POLICY IF EXISTS "n8n_qr_code_history_update_policy" ON public.n8n_qr_code_history;
DROP POLICY IF EXISTS "n8n_qr_code_history_delete_policy" ON public.n8n_qr_code_history;
CREATE POLICY "n8n_qr_code_history_select_policy" ON public.n8n_qr_code_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_qr_code_history_insert_policy" ON public.n8n_qr_code_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "n8n_qr_code_history_update_policy" ON public.n8n_qr_code_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_qr_code_history_delete_policy" ON public.n8n_qr_code_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'n8n_message_sender_history' table
DROP POLICY IF EXISTS "n8n_message_sender_history_select_policy" ON public.n8n_message_sender_history;
DROP POLICY IF EXISTS "n8n_message_sender_history_insert_policy" ON public.n8n_message_sender_history;
DROP POLICY IF EXISTS "n8n_message_sender_history_update_policy" ON public.n8n_message_sender_history;
DROP POLICY IF EXISTS "n8n_message_sender_history_delete_policy" ON public.n8n_message_sender_history;
CREATE POLICY "n8n_message_sender_history_select_policy" ON public.n8n_message_sender_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_message_sender_history_insert_policy" ON public.n8n_message_sender_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "n8n_message_sender_history_update_policy" ON public.n8n_message_sender_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_message_sender_history_delete_policy" ON public.n8n_message_sender_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'evolution_logout_history' table
DROP POLICY IF EXISTS "evolution_logout_history_select_policy" ON public.evolution_logout_history;
DROP POLICY IF EXISTS "evolution_logout_history_insert_policy" ON public.evolution_logout_history;
DROP POLICY IF EXISTS "evolution_logout_history_update_policy" ON public.evolution_logout_history;
DROP POLICY IF EXISTS "evolution_logout_history_delete_policy" ON public.evolution_logout_history;
CREATE POLICY "evolution_logout_history_select_policy" ON public.evolution_logout_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "evolution_logout_history_insert_policy" ON public.evolution_logout_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "evolution_logout_history_update_policy" ON public.evolution_logout_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "evolution_logout_history_delete_policy" ON public.evolution_logout_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'logs' table
DROP POLICY IF EXISTS "Users can view their own logs" ON public.logs;
DROP POLICY IF EXISTS "Users can create their own logs" ON public.logs;
CREATE POLICY "Users can view their own logs" ON public.logs
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can create their own logs" ON public.logs
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
-- Add UPDATE and DELETE policies for logs
DROP POLICY IF EXISTS "Users can update their own logs" ON public.logs;
DROP POLICY IF EXISTS "Users can delete their own logs" ON public.logs;
CREATE POLICY "Users can update their own logs" ON public.logs
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own logs" ON public.logs
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'subscriptions' table
DROP POLICY IF EXISTS "Users can view their own subscription" ON public.subscriptions;
DROP POLICY IF EXISTS "Users can update their own subscription" ON public.subscriptions;
CREATE POLICY "Users can view their own subscription" ON public.subscriptions
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can update their own subscription" ON public.subscriptions
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
-- Add INSERT and DELETE policies for subscriptions
DROP POLICY IF EXISTS "Users can insert their own subscription" ON public.subscriptions;
DROP POLICY IF EXISTS "Users can delete their own subscription" ON public.subscriptions;
CREATE POLICY "Users can insert their own subscription" ON public.subscriptions
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can delete their own subscription" ON public.subscriptions
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'user_roles' table
DROP POLICY IF EXISTS "Users can view their own roles" ON public.user_roles;
CREATE POLICY "Users can view their own roles" ON public.user_roles
FOR SELECT TO authenticated USING (auth.uid() = user_id);
-- Add INSERT, UPDATE, DELETE policies for user_roles
DROP POLICY IF EXISTS "Users can insert their own roles" ON public.user_roles;
DROP POLICY IF EXISTS "Users can update their own roles" ON public.user_roles;
DROP POLICY IF EXISTS "Users can delete their own roles" ON public.user_roles;
CREATE POLICY "Users can insert their own roles" ON public.user_roles
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own roles" ON public.user_roles
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own roles" ON public.user_roles
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'profiles' table
DROP POLICY IF EXISTS "Users can view their own profile" ON public.profiles;
DROP POLICY IF EXISTS "profiles_insert_policy" ON public.profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;
CREATE POLICY "Users can view their own profile" ON public.profiles
FOR SELECT TO authenticated USING (auth.uid() = id);
CREATE POLICY "profiles_insert_policy" ON public.profiles
FOR INSERT TO authenticated WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile" ON public.profiles
FOR UPDATE TO authenticated USING (auth.uid() = id);
-- Add DELETE policy for profiles
DROP POLICY IF EXISTS "Users can delete their own profile" ON public.profiles;
CREATE POLICY "Users can delete their own profile" ON public.profiles
FOR DELETE TO authenticated USING (auth.uid() = id);

-- Recreate or update RLS policies for 'webhook_configs' table
DROP POLICY IF EXISTS "Users can view their own webhook configs" ON public.webhook_configs;
DROP POLICY IF EXISTS "Users can insert their own webhook configs" ON public.webhook_configs;
DROP POLICY IF EXISTS "Users can update their own webhook configs" ON public.webhook_configs;
DROP POLICY IF EXISTS "Users can delete their own webhook configs" ON public.webhook_configs;
CREATE POLICY "Users can view their own webhook configs" ON public.webhook_configs
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own webhook configs" ON public.webhook_configs
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own webhook configs" ON public.webhook_configs
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own webhook configs" ON public.webhook_configs
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- RLS for 'send_history' table
DROP POLICY IF EXISTS "Users can view their own send history" ON public.send_history;
DROP POLICY IF EXISTS "Users can insert their own send history" ON public.send_history;
DROP POLICY IF EXISTS "Users can update their own send history" ON public.send_history;
DROP POLICY IF EXISTS "Users can delete their own send history" ON public.send_history;
CREATE POLICY "Users can view their own send history" ON public.send_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own send history" ON public.send_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own send history" ON public.send_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own send history" ON public.send_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- The 'url_configs' table is for global configurations, so public read access for authenticated users is appropriate.
-- No changes needed for 'Authenticated users can read url configs' policy.
--- ConteÃºdo de: supabase/migrations/0020_updating_rls_policies_for_all_user_specific_tables_to_ensure_multi_tenant_data_isolation_.sql ---
-- Enable RLS on all tables that store user-specific data if not already enabled
ALTER TABLE public.clients ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.automations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.financial_entries ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.scheduled_notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.webhook_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_instances ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.connection_status ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.evolution_api_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.n8n_qr_code_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.n8n_message_sender_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.evolution_logout_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Recreate or update RLS policies for 'clients' table
DROP POLICY IF EXISTS "Users can manage their own clients" ON public.clients;
CREATE POLICY "Users can manage their own clients" ON public.clients
FOR ALL TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Recreate or update RLS policies for 'plans' table
DROP POLICY IF EXISTS "Users can manage their own plans" ON public.plans;
CREATE POLICY "Users can manage their own plans" ON public.plans
FOR ALL TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Recreate or update RLS policies for 'templates' table
DROP POLICY IF EXISTS "Users can manage their own templates" ON public.templates;
CREATE POLICY "Users can manage their own templates" ON public.templates
FOR ALL TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Recreate or update RLS policies for 'automations' table
DROP POLICY IF EXISTS "Users can manage their own automations" ON public.automations;
CREATE POLICY "Users can manage their own automations" ON public.automations
FOR ALL TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Recreate or update RLS policies for 'financial_entries' table
DROP POLICY IF EXISTS "Users can view their own financial entries" ON public.financial_entries;
DROP POLICY IF EXISTS "Users can insert their own financial entries" ON public.financial_entries;
DROP POLICY IF EXISTS "Users can update their own financial entries" ON public.financial_entries;
DROP POLICY IF EXISTS "Users can delete their own financial entries" ON public.financial_entries;
CREATE POLICY "Users can view their own financial entries" ON public.financial_entries
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own financial entries" ON public.financial_entries
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own financial entries" ON public.financial_entries
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own financial entries" ON public.financial_entries
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'scheduled_notifications' table
DROP POLICY IF EXISTS "Users can view their own scheduled notifications" ON public.scheduled_notifications;
DROP POLICY IF EXISTS "Users can insert their own scheduled notifications" ON public.scheduled_notifications;
DROP POLICY IF EXISTS "Users can update their own scheduled notifications" ON public.scheduled_notifications;
DROP POLICY IF EXISTS "Users can delete their own scheduled notifications" ON public.scheduled_notifications;
CREATE POLICY "Users can view their own scheduled notifications" ON public.scheduled_notifications
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own scheduled notifications" ON public.scheduled_notifications
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own scheduled notifications" ON public.scheduled_notifications
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own scheduled notifications" ON public.scheduled_notifications
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'webhook_history' table
DROP POLICY IF EXISTS "Users can view their own webhook history" ON public.webhook_history;
DROP POLICY IF EXISTS "Users can insert their own webhook history" ON public.webhook_history;
CREATE POLICY "Users can view their own webhook history" ON public.webhook_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own webhook history" ON public.webhook_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
-- Add UPDATE and DELETE policies for webhook_history
DROP POLICY IF EXISTS "Users can update their own webhook history" ON public.webhook_history;
DROP POLICY IF EXISTS "Users can delete their own webhook history" ON public.webhook_history;
CREATE POLICY "Users can update their own webhook history" ON public.webhook_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own webhook history" ON public.webhook_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'user_instances' table
DROP POLICY IF EXISTS "Users can manage their own instance mapping" ON public.user_instances;
CREATE POLICY "Users can manage their own instance mapping" ON public.user_instances
FOR ALL TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Recreate or update RLS policies for 'connection_status' table
DROP POLICY IF EXISTS "Users can view their own connection status" ON public.connection_status;
DROP POLICY IF EXISTS "Users can insert their own connection status" ON public.connection_status;
DROP POLICY IF EXISTS "Users can update their own connection status" ON public.connection_status;
DROP POLICY IF EXISTS "Users can delete their own connection status" ON public.connection_status;
CREATE POLICY "Users can view their own connection status" ON public.connection_status
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own connection status" ON public.connection_status
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own connection status" ON public.connection_status
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own connection status" ON public.connection_status
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'evolution_api_history' table
DROP POLICY IF EXISTS "evolution_api_history_select_policy" ON public.evolution_api_history;
DROP POLICY IF EXISTS "evolution_api_history_insert_policy" ON public.evolution_api_history;
DROP POLICY IF EXISTS "evolution_api_history_update_policy" ON public.evolution_api_history;
DROP POLICY IF EXISTS "evolution_api_history_delete_policy" ON public.evolution_api_history;
CREATE POLICY "evolution_api_history_select_policy" ON public.evolution_api_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "evolution_api_history_insert_policy" ON public.evolution_api_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "evolution_api_history_update_policy" ON public.evolution_api_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "evolution_api_history_delete_policy" ON public.evolution_api_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'n8n_qr_code_history' table
DROP POLICY IF EXISTS "n8n_qr_code_history_select_policy" ON public.n8n_qr_code_history;
DROP POLICY IF EXISTS "n8n_qr_code_history_insert_policy" ON public.n8n_qr_code_history;
DROP POLICY IF EXISTS "n8n_qr_code_history_update_policy" ON public.n8n_qr_code_history;
DROP POLICY IF EXISTS "n8n_qr_code_history_delete_policy" ON public.n8n_qr_code_history;
CREATE POLICY "n8n_qr_code_history_select_policy" ON public.n8n_qr_code_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_qr_code_history_insert_policy" ON public.n8n_qr_code_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "n8n_qr_code_history_update_policy" ON public.n8n_qr_code_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_qr_code_history_delete_policy" ON public.n8n_qr_code_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'n8n_message_sender_history' table
DROP POLICY IF EXISTS "n8n_message_sender_history_select_policy" ON public.n8n_message_sender_history;
DROP POLICY IF EXISTS "n8n_message_sender_history_insert_policy" ON public.n8n_message_sender_history;
DROP POLICY IF EXISTS "n8n_message_sender_history_update_policy" ON public.n8n_message_sender_history;
DROP POLICY IF EXISTS "n8n_message_sender_history_delete_policy" ON public.n8n_message_sender_history;
CREATE POLICY "n8n_message_sender_history_select_policy" ON public.n8n_message_sender_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_message_sender_history_insert_policy" ON public.n8n_message_sender_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "n8n_message_sender_history_update_policy" ON public.n8n_message_sender_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "n8n_message_sender_history_delete_policy" ON public.n8n_message_sender_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'evolution_logout_history' table
DROP POLICY IF EXISTS "evolution_logout_history_select_policy" ON public.evolution_logout_history;
DROP POLICY IF EXISTS "evolution_logout_history_insert_policy" ON public.evolution_logout_history;
DROP POLICY IF EXISTS "evolution_logout_history_update_policy" ON public.evolution_logout_history;
DROP POLICY IF EXISTS "evolution_logout_history_delete_policy" ON public.evolution_logout_history;
CREATE POLICY "evolution_logout_history_select_policy" ON public.evolution_logout_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "evolution_logout_history_insert_policy" ON public.evolution_logout_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "evolution_logout_history_update_policy" ON public.evolution_logout_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "evolution_logout_history_delete_policy" ON public.evolution_logout_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'logs' table
DROP POLICY IF EXISTS "Users can view their own logs" ON public.logs;
DROP POLICY IF EXISTS "Users can create their own logs" ON public.logs;
CREATE POLICY "Users can view their own logs" ON public.logs
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can create their own logs" ON public.logs
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
-- Add UPDATE and DELETE policies for logs
DROP POLICY IF EXISTS "Users can update their own logs" ON public.logs;
DROP POLICY IF EXISTS "Users can delete their own logs" ON public.logs;
CREATE POLICY "Users can update their own logs" ON public.logs
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own logs" ON public.logs
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'subscriptions' table
DROP POLICY IF EXISTS "Users can view their own subscription" ON public.subscriptions;
DROP POLICY IF EXISTS "Users can update their own subscription" ON public.subscriptions;
CREATE POLICY "Users can view their own subscription" ON public.subscriptions
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can update their own subscription" ON public.subscriptions
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
-- Add INSERT and DELETE policies for subscriptions
DROP POLICY IF EXISTS "Users can insert their own subscription" ON public.subscriptions;
DROP POLICY IF EXISTS "Users can delete their own subscription" ON public.subscriptions;
CREATE POLICY "Users can insert their own subscription" ON public.subscriptions
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can delete their own subscription" ON public.subscriptions
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'user_roles' table
DROP POLICY IF EXISTS "Users can view their own roles" ON public.user_roles;
CREATE POLICY "Users can view their own roles" ON public.user_roles
FOR SELECT TO authenticated USING (auth.uid() = user_id);
-- Add INSERT, UPDATE, DELETE policies for user_roles
DROP POLICY IF EXISTS "Users can insert their own roles" ON public.user_roles;
DROP POLICY IF EXISTS "Users can update their own roles" ON public.user_roles;
DROP POLICY IF EXISTS "Users can delete their own roles" ON public.user_roles;
CREATE POLICY "Users can insert their own roles" ON public.user_roles
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own roles" ON public.user_roles
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own roles" ON public.user_roles
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Recreate or update RLS policies for 'profiles' table
DROP POLICY IF EXISTS "Users can view their own profile" ON public.profiles;
DROP POLICY IF EXISTS "profiles_insert_policy" ON public.profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;
CREATE POLICY "Users can view their own profile" ON public.profiles
FOR SELECT TO authenticated USING (auth.uid() = id);
CREATE POLICY "profiles_insert_policy" ON public.profiles
FOR INSERT TO authenticated WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile" ON public.profiles
FOR UPDATE TO authenticated USING (auth.uid() = id);
-- Add DELETE policy for profiles
DROP POLICY IF EXISTS "Users can delete their own profile" ON public.profiles;
CREATE POLICY "Users can delete their own profile" ON public.profiles
FOR DELETE TO authenticated USING (auth.uid() = id);

-- Recreate or update RLS policies for 'webhook_configs' table
DROP POLICY IF EXISTS "Users can view their own webhook configs" ON public.webhook_configs;
DROP POLICY IF EXISTS "Users can insert their own webhook configs" ON public.webhook_configs;
DROP POLICY IF EXISTS "Users can update their own webhook configs" ON public.webhook_configs;
DROP POLICY IF EXISTS "Users can delete their own webhook configs" ON public.webhook_configs;
CREATE POLICY "Users can view their own webhook configs" ON public.webhook_configs
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own webhook configs" ON public.webhook_configs
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own webhook configs" ON public.webhook_configs
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own webhook configs" ON public.webhook_configs
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- RLS for 'send_history' table
DROP POLICY IF EXISTS "Users can view their own send history" ON public.send_history;
DROP POLICY IF EXISTS "Users can insert their own send history" ON public.send_history;
DROP POLICY IF EXISTS "Users can update their own send history" ON public.send_history;
DROP POLICY IF EXISTS "Users can delete their own send history" ON public.send_history;
CREATE POLICY "Users can view their own send history" ON public.send_history
FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own send history" ON public.send_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own send history" ON public.send_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own send history" ON public.send_history
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- The 'url_configs' table is for global configurations, so public read access for authenticated users is appropriate.
-- No changes needed for 'Authenticated users can read url configs' policy.
--- ConteÃºdo de: supabase/migrations/0021_updating_rls_policies_for_all_user_specific_tables_and_webhook_configs_to_implement_role_based_access_control_rbac_.sql ---
-- Etapa 1: Modificar PolÃ­ticas RLS para Acesso de Admin em tabelas com user_id
-- Aplicar o padrÃ£o "Users can manage their own data OR Admins can manage all"

-- Tables with FOR ALL policies
-- clients
DROP POLICY IF EXISTS "Users can manage their own clients" ON public.clients;
CREATE POLICY "Users can manage their own clients OR Admins can manage all" ON public.clients
FOR ALL TO authenticated
USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin')
WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- plans
DROP POLICY IF EXISTS "Users can manage their own plans" ON public.plans;
CREATE POLICY "Users can manage their own plans OR Admins can manage all" ON public.plans
FOR ALL TO authenticated
USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin')
WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- templates
DROP POLICY IF EXISTS "Users can manage their own templates" ON public.templates;
CREATE POLICY "Users can manage their own templates OR Admins can manage all" ON public.templates
FOR ALL TO authenticated
USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin')
WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- automations
DROP POLICY IF EXISTS "Users can manage their own automations" ON public.automations;
CREATE POLICY "Users can manage their own automations OR Admins can manage all" ON public.automations
FOR ALL TO authenticated
USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin')
WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- user_instances
DROP POLICY IF EXISTS "Users can manage their own instance mapping" ON public.user_instances;
CREATE POLICY "Users can manage their own instance mapping OR Admins can manage all" ON public.user_instances
FOR ALL TO authenticated
USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin')
WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- Tables with specific SELECT/INSERT/UPDATE/DELETE policies
-- financial_entries
DROP POLICY IF EXISTS "Users can view their own financial entries" ON public.financial_entries;
DROP POLICY IF EXISTS "Users can insert their own financial entries" ON public.financial_entries;
DROP POLICY IF EXISTS "Users can update their own financial entries" ON public.financial_entries;
DROP POLICY IF EXISTS "Users can delete their own financial entries" ON public.financial_entries;
CREATE POLICY "Users can view their own financial entries OR Admins can view all" ON public.financial_entries
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can insert their own financial entries OR Admins can insert for others" ON public.financial_entries
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can update their own financial entries OR Admins can update for others" ON public.financial_entries
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can delete their own financial entries OR Admins can delete for others" ON public.financial_entries
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- scheduled_notifications
DROP POLICY IF EXISTS "Users can view their own scheduled notifications" ON public.scheduled_notifications;
DROP POLICY IF EXISTS "Users can insert their own scheduled notifications" ON public.scheduled_notifications;
DROP POLICY IF EXISTS "Users can update their own scheduled notifications" ON public.scheduled_notifications;
DROP POLICY IF EXISTS "Users can delete their own scheduled notifications" ON public.scheduled_notifications;
CREATE POLICY "Users can view their own scheduled notifications OR Admins can view all" ON public.scheduled_notifications
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can insert their own scheduled notifications OR Admins can insert for others" ON public.scheduled_notifications
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can update their own scheduled notifications OR Admins can update for others" ON public.scheduled_notifications
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can delete their own scheduled notifications OR Admins can delete for others" ON public.scheduled_notifications
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- webhook_history
DROP POLICY IF EXISTS "Users can view their own webhook history" ON public.webhook_history;
DROP POLICY IF EXISTS "Users can insert their own webhook history" ON public.webhook_history;
DROP POLICY IF EXISTS "Users can update their own webhook history" ON public.webhook_history;
DROP POLICY IF EXISTS "Users can delete their own webhook history" ON public.webhook_history;
CREATE POLICY "Users can view their own webhook history OR Admins can view all" ON public.webhook_history
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can insert their own webhook history OR Admins can insert for others" ON public.webhook_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can update their own webhook history OR Admins can update for others" ON public.webhook_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can delete their own webhook history OR Admins can delete for others" ON public.webhook_history
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- connection_status
DROP POLICY IF EXISTS "Users can view their own connection status" ON public.connection_status;
DROP POLICY IF EXISTS "Users can insert their own connection status" ON public.connection_status;
DROP POLICY IF EXISTS "Users can update their own connection status" ON public.connection_status;
DROP POLICY IF EXISTS "Users can delete their own connection status" ON public.connection_status;
CREATE POLICY "Users can view their own connection status OR Admins can view all" ON public.connection_status
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can insert their own connection status OR Admins can insert for others" ON public.connection_status
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can update their own connection status OR Admins can update for others" ON public.connection_status
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can delete their own connection status OR Admins can delete for others" ON public.connection_status
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- evolution_api_history
DROP POLICY IF EXISTS "evolution_api_history_select_policy" ON public.evolution_api_history;
DROP POLICY IF EXISTS "evolution_api_history_insert_policy" ON public.evolution_api_history;
DROP POLICY IF EXISTS "evolution_api_history_update_policy" ON public.evolution_api_history;
DROP POLICY IF EXISTS "evolution_api_history_delete_policy" ON public.evolution_api_history;
CREATE POLICY "evolution_api_history_select_policy OR Admins can view all" ON public.evolution_api_history
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "evolution_api_history_insert_policy OR Admins can insert for others" ON public.evolution_api_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "evolution_api_history_update_policy OR Admins can update for others" ON public.evolution_api_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "evolution_api_history_delete_policy OR Admins can delete for others" ON public.evolution_api_history
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- n8n_qr_code_history
DROP POLICY IF EXISTS "n8n_qr_code_history_select_policy" ON public.n8n_qr_code_history;
DROP POLICY IF EXISTS "n8n_qr_code_history_insert_policy" ON public.n8n_qr_code_history;
DROP POLICY IF EXISTS "n8n_qr_code_history_update_policy" ON public.n8n_qr_code_history;
DROP POLICY IF EXISTS "n8n_qr_code_history_delete_policy" ON public.n8n_qr_code_history;
CREATE POLICY "n8n_qr_code_history_select_policy OR Admins can view all" ON public.n8n_qr_code_history
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "n8n_qr_code_history_insert_policy OR Admins can insert for others" ON public.n8n_qr_code_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "n8n_qr_code_history_update_policy OR Admins can update for others" ON public.n8n_qr_code_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "n8n_qr_code_history_delete_policy OR Admins can delete for others" ON public.n8n_qr_code_history
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- n8n_message_sender_history
DROP POLICY IF EXISTS "n8n_message_sender_history_select_policy" ON public.n8n_message_sender_history;
DROP POLICY IF EXISTS "n8n_message_sender_history_insert_policy" ON public.n8n_message_sender_history;
DROP POLICY IF EXISTS "n8n_message_sender_history_update_policy" ON public.n8n_message_sender_history;
DROP POLICY IF EXISTS "n8n_message_sender_history_delete_policy" ON public.n8n_message_sender_history;
CREATE POLICY "n8n_message_sender_history_select_policy OR Admins can view all" ON public.n8n_message_sender_history
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "n8n_message_sender_history_insert_policy OR Admins can insert for others" ON public.n8n_message_sender_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "n8n_message_sender_history_update_policy OR Admins can update for others" ON public.n8n_message_sender_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "n8n_message_sender_history_delete_policy OR Admins can delete for others" ON public.n8n_message_sender_history
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- evolution_logout_history
DROP POLICY IF EXISTS "evolution_logout_history_select_policy" ON public.evolution_logout_history;
DROP POLICY IF EXISTS "evolution_logout_history_insert_policy" ON public.evolution_logout_history;
DROP POLICY IF EXISTS "evolution_logout_history_update_policy" ON public.evolution_logout_history;
DROP POLICY IF EXISTS "evolution_logout_history_delete_policy" ON public.evolution_logout_history;
CREATE POLICY "evolution_logout_history_select_policy OR Admins can view all" ON public.evolution_logout_history
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "evolution_logout_history_insert_policy OR Admins can insert for others" ON public.evolution_logout_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "evolution_logout_history_update_policy OR Admins can update for others" ON public.evolution_logout_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "evolution_logout_history_delete_policy OR Admins can delete for others" ON public.evolution_logout_history
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- logs
DROP POLICY IF EXISTS "Users can view their own logs" ON public.logs;
DROP POLICY IF EXISTS "Users can create their own logs" ON public.logs;
DROP POLICY IF EXISTS "Users can update their own logs" ON public.logs;
DROP POLICY IF EXISTS "Users can delete their own logs" ON public.logs;
CREATE POLICY "Users can view their own logs OR Admins can view all" ON public.logs
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can insert their own logs OR Admins can insert for others" ON public.logs
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can update their own logs OR Admins can update for others" ON public.logs
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can delete their own logs OR Admins can delete for others" ON public.logs
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- subscriptions
DROP POLICY IF EXISTS "Users can view their own subscription" ON public.subscriptions;
DROP POLICY IF EXISTS "Users can update their own subscription" ON public.subscriptions;
DROP POLICY IF EXISTS "Users can insert their own subscription" ON public.subscriptions;
DROP POLICY IF EXISTS "Users can delete their own subscription" ON public.subscriptions;
CREATE POLICY "Users can view their own subscription OR Admins can view all" ON public.subscriptions
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can insert their own subscription OR Admins can insert for others" ON public.subscriptions
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can update their own subscription OR Admins can update for others" ON public.subscriptions
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can delete their own subscription OR Admins can delete for others" ON public.subscriptions
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- user_roles
DROP POLICY IF EXISTS "Users can view their own roles" ON public.user_roles;
DROP POLICY IF EXISTS "Users can insert their own roles" ON public.user_roles;
DROP POLICY IF EXISTS "Users can update their own roles" ON public.user_roles;
DROP POLICY IF EXISTS "Users can delete their own roles" ON public.user_roles;
CREATE POLICY "Users can view their own roles OR Admins can view all" ON public.user_roles
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Admins can manage user roles" ON public.user_roles
FOR ALL TO authenticated USING ((SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin')
WITH CHECK ((SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- profiles (uses 'id' instead of 'user_id')
DROP POLICY IF EXISTS "Users can view their own profile" ON public.profiles;
DROP POLICY IF EXISTS "profiles_insert_policy" ON public.profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can delete their own profile" ON public.profiles;
CREATE POLICY "Users can view their own profile OR Admins can view all" ON public.profiles
FOR SELECT TO authenticated USING (auth.uid() = id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "profiles_insert_policy OR Admins can insert for others" ON public.profiles
FOR INSERT TO authenticated WITH CHECK (auth.uid() = id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can update their own profile OR Admins can update for others" ON public.profiles
FOR UPDATE TO authenticated USING (auth.uid() = id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can delete their own profile OR Admins can delete for others" ON public.profiles
FOR DELETE TO authenticated USING (auth.uid() = id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- send_history
DROP POLICY IF EXISTS "Users can view their own send history" ON public.send_history;
DROP POLICY IF EXISTS "Users can insert their own send history" ON public.send_history;
DROP POLICY IF EXISTS "Users can update their own send history" ON public.send_history;
DROP POLICY IF EXISTS "Users can delete their own send history" ON public.send_history;
CREATE POLICY "Users can view their own send history OR Admins can view all" ON public.send_history
FOR SELECT TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can insert their own send history OR Admins can insert for others" ON public.send_history
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can update their own send history OR Admins can update for others" ON public.send_history
FOR UPDATE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');
CREATE POLICY "Users can delete their own send history OR Admins can delete for others" ON public.send_history
FOR DELETE TO authenticated USING (auth.uid() = user_id OR (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');


-- Etapa 2: Ajustar LÃ³gica e RLS da Tabela `webhook_configs`
-- Remove existing policies
DROP POLICY IF EXISTS "Users can view their own webhook configs" ON public.webhook_configs;
DROP POLICY IF EXISTS "Users can insert their own webhook configs" ON public.webhook_configs;
DROP POLICY IF EXISTS "Users can update their own webhook configs" ON public.webhook_configs;
DROP POLICY IF EXISTS "Users can delete their own webhook configs" ON public.webhook_configs;

-- New RLS policies for `webhook_configs`
-- SELECT: Allow any authenticated user to read (global config)
CREATE POLICY "Authenticated users can read webhook configs" ON public.webhook_configs
FOR SELECT TO authenticated USING (true);

-- INSERT, UPDATE, DELETE: Allow only Admins to manage
CREATE POLICY "Admins can manage webhook configs" ON public.webhook_configs
FOR ALL TO authenticated
USING ((SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin')
WITH CHECK ((SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin');

-- The 'url_configs' table is for global configurations, so public read access for authenticated users is appropriate.
-- No changes needed for 'Authenticated users can read url configs' policy.
--- ConteÃºdo de: supabase/migrations/0022_removendo_pol_ticas_rls_existentes_e_criando_novas_pol_ticas_n_o_recursivas_para_a_tabela_user_roles_.sql ---
-- Remover polÃ­ticas RLS existentes na tabela user_roles para evitar recursÃ£o infinita
DROP POLICY IF EXISTS "Users can view their own roles OR Admins can view all" ON public.user_roles;
DROP POLICY IF EXISTS "Admins can manage user roles" ON public.user_roles;

-- Criar polÃ­tica RLS para SELECT: UsuÃ¡rios podem ver apenas seu prÃ³prio papel
CREATE POLICY "Users can view their own role" ON public.user_roles
FOR SELECT TO authenticated USING (auth.uid() = user_id);

-- Criar polÃ­tica RLS para INSERT, UPDATE, DELETE: UsuÃ¡rios podem gerenciar apenas seu prÃ³prio papel
CREATE POLICY "Users can manage their own role" ON public.user_roles
FOR ALL TO authenticated USING (auth.uid() = user_id);

-- Opcional: Se vocÃª precisa que administradores vejam *todos* os papÃ©is via RLS no frontend,
-- e nÃ£o apenas atravÃ©s de funÃ§Ãµes de backend com service_role, vocÃª precisaria de uma funÃ§Ã£o
-- SECURITY INVOKER para verificar o papel de admin sem recursÃ£o.
-- Por enquanto, a abordagem Ã© que o frontend sÃ³ busca o prÃ³prio papel do usuÃ¡rio,
-- e operaÃ§Ãµes de admin em massa sÃ£o feitas via backend (Edge Functions com service_role).

-- Backfill: Inserir papel 'user' para usuÃ¡rios existentes que nÃ£o tÃªm um
INSERT INTO public.user_roles (user_id, role)
SELECT
    au.id,
    'user'::app_role
FROM
    auth.users au
LEFT JOIN
    public.user_roles ur ON au.id = ur.user_id
WHERE
    ur.user_id IS NULL;
--- ConteÃºdo de: supabase/migrations/0023_adicionando_a_coluna_pix_key_tabela_profiles_.sql ---
ALTER TABLE public.profiles
ADD COLUMN pix_key TEXT NULL;

COMMENT ON COLUMN public.profiles.pix_key IS 'Chave PIX do usuÃ¡rio para recebimento de pagamentos.';
--- ConteÃºdo de: supabase/migrations/0024_migra_o_tornando_user_id_da_tabela_templates_nul_vel_e_adicionando_pix_key_tabela_profiles_se_ainda_n_o_existir_.sql ---
-- MigraÃ§Ã£o: Tornando user_id da tabela templates nulÃ¡vel
ALTER TABLE public.templates
ALTER COLUMN user_id DROP NOT NULL;

-- MigraÃ§Ã£o: Adicionando pix_key Ã  tabela profiles (se ainda nÃ£o existir)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'pix_key') THEN
        ALTER TABLE public.profiles ADD COLUMN pix_key TEXT NULL;
        COMMENT ON COLUMN public.profiles.pix_key IS 'Chave PIX do usuÃ¡rio para recebimento de pagamentos.';
    END IF;
END
$$;
--- ConteÃºdo de: supabase/migrations/0025_migra_o_atualizando_as_pol_ticas_de_rls_para_a_tabela_templates_.sql ---
-- MigraÃ§Ã£o: Atualizando as polÃ­ticas de RLS para a tabela templates

-- Desabilitar RLS temporariamente para remover polÃ­ticas existentes
ALTER TABLE public.templates DISABLE ROW LEVEL SECURITY;

-- Remover polÃ­ticas existentes para templates
DROP POLICY IF EXISTS "Users can manage their own templates OR Admins can manage all" ON public.templates;

-- Reabilitar RLS
ALTER TABLE public.templates ENABLE ROW LEVEL SECURITY;

-- PolÃ­tica SELECT: Permitir que usuÃ¡rios autenticados leiam seus prÃ³prios templates ou templates padrÃ£o
CREATE POLICY "Allow authenticated users to read their own or standard templates"
ON public.templates FOR SELECT TO authenticated
USING ((auth.uid() = user_id) OR (user_id IS NULL));

-- PolÃ­tica INSERT: Permitir que usuÃ¡rios autenticados insiram seus prÃ³prios templates
CREATE POLICY "Allow authenticated users to insert their own templates"
ON public.templates FOR INSERT TO authenticated
WITH CHECK (auth.uid() = user_id);

-- PolÃ­tica UPDATE: Permitir que proprietÃ¡rios ou administradores atualizem templates
CREATE POLICY "Allow owners or admins to update templates"
ON public.templates FOR UPDATE TO authenticated
USING (
    (auth.uid() = user_id) OR
    (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'))
)
WITH CHECK (
    (auth.uid() = user_id) OR
    (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'))
);

-- PolÃ­tica DELETE: Permitir que proprietÃ¡rios ou administradores excluam templates
CREATE POLICY "Allow owners or admins to delete templates"
ON public.templates FOR DELETE TO authenticated
USING (
    (auth.uid() = user_id) OR
    (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'))
);
--- ConteÃºdo de: supabase/migrations/0026_criando_um_ndice_nico_parcial_na_coluna_name_da_tabela_templates_para_templates_padr_o_user_id_is_null_.sql ---
-- Criando um Ã­ndice Ãºnico parcial na coluna 'name' da tabela 'templates' para templates padrÃ£o (user_id IS NULL)
CREATE UNIQUE INDEX IF NOT EXISTS unique_standard_template_name ON public.templates (name) WHERE user_id IS NULL;
--- ConteÃºdo de: supabase/migrations/0027_adicionando_o_tipo_enum_template_type_e_a_coluna_type_tabela_templates_com_rls_atualizado_.sql ---
-- Adicionar o tipo ENUM 'template_type' se nÃ£o existir
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'template_type') THEN
        CREATE TYPE public.template_type AS ENUM ('normal', 'global');
    END IF;
END $$;

-- Adicionar a coluna 'type' Ã  tabela 'templates' se nÃ£o existir
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'templates' AND column_name = 'type') THEN
        ALTER TABLE public.templates ADD COLUMN type public.template_type DEFAULT 'normal' NOT NULL;
    END IF;
END $$;

-- Remover polÃ­ticas RLS antigas para templates
DROP POLICY IF EXISTS "Allow authenticated users to read their own or standard templat" ON public.templates;
DROP POLICY IF EXISTS "Allow authenticated users to insert their own templates" ON public.templates;
DROP POLICY IF EXISTS "Allow owners or admins to update templates" ON public.templates;
DROP POLICY IF EXISTS "Allow owners or admins to delete templates" ON public.templates;

-- Criar novas polÃ­ticas RLS para templates com base no novo campo 'type' e roles
-- SELECT: UsuÃ¡rios autenticados podem ler seus prÃ³prios templates, templates padrÃ£o (user_id IS NULL) e templates globais.
CREATE POLICY "Allow authenticated users to read their own, standard, or global templates"
ON public.templates FOR SELECT TO authenticated
USING (
    (auth.uid() = user_id) OR (user_id IS NULL) OR (type = 'global')
);

-- INSERT: UsuÃ¡rios normais podem inserir seus prÃ³prios templates 'normal'. Admins podem inserir qualquer tipo.
CREATE POLICY "Allow users to insert normal templates and admins to insert any type"
ON public.templates FOR INSERT TO authenticated
WITH CHECK (
    (auth.uid() = user_id AND type = 'normal') OR
    (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'))
);

-- UPDATE: UsuÃ¡rios normais podem atualizar seus prÃ³prios templates 'normal'. Admins podem atualizar qualquer tipo.
CREATE POLICY "Allow users to update normal templates and admins to update any type"
ON public.templates FOR UPDATE TO authenticated
USING (
    (auth.uid() = user_id AND type = 'normal') OR
    (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'))
)
WITH CHECK (
    (auth.uid() = user_id AND type = 'normal') OR
    (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'))
);

-- DELETE: UsuÃ¡rios normais podem deletar seus prÃ³prios templates 'normal'. Admins podem deletar qualquer tipo.
CREATE POLICY "Allow users to delete normal templates and admins to delete any type"
ON public.templates FOR DELETE TO authenticated
USING (
    (auth.uid() = user_id AND type = 'normal') OR
    (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'))
);
--- ConteÃºdo de: supabase/migrations/0028_removendo_a_coluna_category_da_tabela_templates_e_o_tipo_template_category_enum_.sql ---
-- 1. Remover a coluna 'category' da tabela 'templates'
ALTER TABLE public.templates DROP COLUMN category;

-- 2. Remover o tipo ENUM 'template_category'
DROP TYPE public.template_category;
--- ConteÃºdo de: supabase/migrations/0029_corrigindo_o_erro_ao_remover_a_coluna_category_da_tabela_templates_e_o_tipo_template_category_enum_usando_if_exists_.sql ---
-- 1. Remover a coluna 'category' da tabela 'templates' (se existir)
ALTER TABLE public.templates DROP COLUMN IF EXISTS category;

-- 2. Remover o tipo ENUM 'template_category' (se existir)
DROP TYPE IF EXISTS public.template_category;
--- ConteÃºdo de: supabase/migrations/0030_creating_new_tables_for_admin_financial_entries_subscriber_plans_subscriber_templates_and_subscriber_automations_along_with_their_rls_policies_.sql ---
-- Create admin_financial_entries table
CREATE TABLE public.admin_financial_entries (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  admin_user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  subscriber_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  description TEXT NOT NULL,
  value NUMERIC NOT NULL,
  type public.transaction_type NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable RLS for admin_financial_entries
ALTER TABLE public.admin_financial_entries ENABLE ROW LEVEL SECURITY;

-- RLS Policies for admin_financial_entries (Admin only)
CREATE POLICY "Admins can view all admin financial entries" ON public.admin_financial_entries
FOR SELECT TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can insert admin financial entries" ON public.admin_financial_entries
FOR INSERT TO authenticated WITH CHECK (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can update admin financial entries" ON public.admin_financial_entries
FOR UPDATE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can delete admin financial entries" ON public.admin_financial_entries
FOR DELETE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));


-- Create subscriber_plans table
CREATE TABLE public.subscriber_plans (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  name TEXT NOT NULL,
  value NUMERIC NOT NULL,
  period_days INTEGER NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable RLS for subscriber_plans
ALTER TABLE public.subscriber_plans ENABLE ROW LEVEL SECURITY;

-- RLS Policies for subscriber_plans (Admin only)
CREATE POLICY "Admins can view all subscriber plans" ON public.subscriber_plans
FOR SELECT TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can insert subscriber plans" ON public.subscriber_plans
FOR INSERT TO authenticated WITH CHECK (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can update subscriber plans" ON public.subscriber_plans
FOR UPDATE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can delete subscriber plans" ON public.subscriber_plans
FOR DELETE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));


-- Create subscriber_templates table
CREATE TABLE public.subscriber_templates (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  admin_user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- Can be NULL for global templates
  name TEXT NOT NULL,
  content TEXT NOT NULL,
  type public.template_type DEFAULT 'normal' NOT NULL, -- 'normal' or 'global'
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable RLS for subscriber_templates
ALTER TABLE public.subscriber_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies for subscriber_templates (Admin only)
CREATE POLICY "Admins can view all subscriber templates" ON public.subscriber_templates
FOR SELECT TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can insert subscriber templates" ON public.subscriber_templates
FOR INSERT TO authenticated WITH CHECK (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can update subscriber templates" ON public.subscriber_templates
FOR UPDATE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can delete subscriber templates" ON public.subscriber_templates
FOR DELETE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));


-- Create subscriber_automations table
CREATE TABLE public.subscriber_automations (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  admin_user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  days_offset INTEGER NOT NULL,
  subscriber_template_id UUID REFERENCES public.subscriber_templates(id) ON DELETE CASCADE,
  subscriber_ids UUID[] NOT NULL, -- Array of profiles.id
  scheduled_time TIME WITHOUT TIME ZONE DEFAULT '09:00:00' NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable RLS for subscriber_automations
ALTER TABLE public.subscriber_automations ENABLE ROW LEVEL SECURITY;

-- RLS Policies for subscriber_automations (Admin only)
CREATE POLICY "Admins can view all subscriber automations" ON public.subscriber_automations
FOR SELECT TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can insert subscriber automations" ON public.subscriber_automations
FOR INSERT TO authenticated WITH CHECK (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can update subscriber automations" ON public.subscriber_automations
FOR UPDATE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

CREATE POLICY "Admins can delete subscriber automations" ON public.subscriber_automations
FOR DELETE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'));

-- Add triggers for updated_at columns
CREATE TRIGGER update_subscriber_plans_updated_at
BEFORE UPDATE ON public.subscriber_plans
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_subscriber_templates_updated_at
BEFORE UPDATE ON public.subscriber_templates
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_subscriber_automations_updated_at
BEFORE UPDATE ON public.subscriber_automations
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
--- ConteÃºdo de: supabase/migrations/0031_adding_type_column_to_scheduled_notifications_table_to_differentiate_between_client_and_subscriber_notifications_.sql ---
ALTER TABLE public.scheduled_notifications
ADD COLUMN type TEXT DEFAULT 'client_notification' NOT NULL;

COMMENT ON COLUMN public.scheduled_notifications.type IS 'Type of notification: client_notification or subscriber_notification.';

-- Update RLS policies for scheduled_notifications to include the new 'type' column
-- Existing policy: Users can view their own scheduled notifications OR Admins can view all
DROP POLICY IF EXISTS "Users can view their own scheduled notifications OR Admins can " ON public.scheduled_notifications;
CREATE POLICY "Users can view their own scheduled notifications OR Admins can view all" ON public.scheduled_notifications
FOR SELECT TO authenticated USING (
  (auth.uid() = user_id AND type = 'client_notification') OR
  (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'))
);

-- Existing policy: Users can insert their own scheduled notifications OR Admins ca
DROP POLICY IF EXISTS "Users can insert their own scheduled notifications OR Admins ca" ON public.scheduled_notifications;
CREATE POLICY "Users can insert their own scheduled notifications OR Admins can insert for others" ON public.scheduled_notifications
FOR INSERT TO authenticated WITH CHECK (
  (auth.uid() = user_id AND type = 'client_notification') OR
  (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'))
);

-- Existing policy: Users can update their own scheduled notifications OR Admins ca
DROP POLICY IF EXISTS "Users can update their own scheduled notifications OR Admins ca" ON public.scheduled_notifications;
CREATE POLICY "Users can update their own scheduled notifications OR Admins can update for others" ON public.scheduled_notifications
FOR UPDATE TO authenticated USING (
  (auth.uid() = user_id AND type = 'client_notification') OR
  (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'))
);

-- Existing policy: Users can delete their own scheduled notifications OR Admins ca
DROP POLICY IF EXISTS "Users can delete their own scheduled notifications OR Admins ca" ON public.scheduled_notifications;
CREATE POLICY "Users can delete their own scheduled notifications OR Admins can delete for others" ON public.scheduled_notifications
FOR DELETE TO authenticated USING (
  (auth.uid() = user_id AND type = 'client_notification') OR
  (EXISTS (SELECT 1 FROM public.user_roles WHERE user_roles.user_id = auth.uid() AND user_roles.role = 'admin'))
);
--- ConteÃºdo de: supabase/migrations/0032_contar_usu_rios_na_tabela_auth_users.sql ---
SELECT count(*) FROM auth.users;
--- ConteÃºdo de: supabase/migrations/0033_contar_perfis_na_tabela_public_profiles.sql ---
SELECT count(*) FROM public.profiles;
--- ConteÃºdo de: supabase/migrations/0034_visualizar_os_primeiros_5_perfis.sql ---
SELECT id, name, email, created_at FROM public.profiles LIMIT 5;
--- ConteÃºdo de: supabase/migrations/0035_visualizar_os_primeiros_5_registros_de_fun_es_de_usu_rio.sql ---
SELECT user_id, role FROM public.user_roles LIMIT 5;
--- ConteÃºdo de: supabase/migrations/0036_verificar_usu_rios_sem_perfil_correspondente.sql ---
SELECT au.id, au.email
    FROM auth.users au
    LEFT JOIN public.profiles pp ON au.id = pp.id
    WHERE pp.id IS NULL;
--- ConteÃºdo de: supabase/migrations/0037_verificar_usu_rios_sem_fun_o_de_usu_rio_correspondente.sql ---
SELECT au.id, au.email
    FROM auth.users au
    LEFT JOIN public.user_roles ur ON au.id = ur.user_id
    WHERE ur.user_id IS NULL;
--- ConteÃºdo de: supabase/migrations/0038_verificar_status_do_gatilho_on_auth_user_created.sql ---
SELECT event_object_table, event_manipulation, action_statement, action_timing, event_object_schema
    FROM information_schema.triggers
    WHERE trigger_name = 'on_auth_user_created';
--- ConteÃºdo de: supabase/migrations/0039_update_fk_to_profiles_for_subscriptions_and_user_instances.sql ---
-- Remover a chave estrangeira existente de subscriptions.user_id para auth.users
ALTER TABLE public.subscriptions DROP CONSTRAINT subscriptions_user_id_fkey;

-- Adicionar uma nova chave estrangeira de subscriptions.user_id para public.profiles.id
ALTER TABLE public.subscriptions
ADD CONSTRAINT subscriptions_user_id_fkey
FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;

-- Remover a chave estrangeira existente de user_instances.user_id para auth.users
ALTER TABLE public.user_instances DROP CONSTRAINT user_instances_user_id_fkey;

-- Adicionar uma nova chave estrangeira de user_instances.user_id para public.profiles.id
ALTER TABLE public.user_instances
ADD CONSTRAINT user_instances_user_id_fkey
FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;
--- ConteÃºdo de: supabase/migrations/0040_verificar_chave_estrangeira_de_subscriptions_user_id.sql ---
-- Remover a chave estrangeira existente de subscriptions.user_id para auth.users ou profiles, se existir
ALTER TABLE public.subscriptions DROP CONSTRAINT IF EXISTS subscriptions_user_id_fkey;

-- Adicionar uma nova chave estrangeira de subscriptions.user_id para public.profiles.id
ALTER TABLE public.subscriptions
ADD CONSTRAINT subscriptions_user_id_fkey
FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;
--- ConteÃºdo de: supabase/migrations/0041_verificar_chave_estrangeira_de_user_instances_user_id.sql ---
-- Remover a chave estrangeira existente de user_instances.user_id para auth.users ou profiles, se existir
ALTER TABLE public.user_instances DROP CONSTRAINT IF EXISTS user_instances_user_id_fkey;

-- Adicionar uma nova chave estrangeira de user_instances.user_id para public.profiles.id
ALTER TABLE public.user_instances
ADD CONSTRAINT user_instances_user_id_fkey
FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;
--- ConteÃºdo de: supabase/migrations/0042_atualizando_a_fun_o_handle_new_user_para_criar_uma_assinatura_padr_o_para_novos_usu_rios_.sql ---
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE PLPGSQL
SECURITY DEFINER SET search_path = 'public'
AS $$
BEGIN
  -- Insert into profiles
  INSERT INTO public.profiles (id, name, email)
  VALUES (NEW.id, COALESCE(NEW.raw_user_meta_data->>'name', split_part(NEW.email, '@', 1)), NEW.email);

  -- Insert into user_roles
  INSERT INTO public.user_roles (user_id, role)
  VALUES (NEW.id, 'user');

  -- Insert into subscriptions with a default free plan
  INSERT INTO public.subscriptions (user_id, plan_name, price, status, next_billing_date)
  VALUES (NEW.id, 'Plano Gratuito', 0.00, 'active', (NOW() + INTERVAL '30 days')::date); -- Default to active for 30 days

  RETURN NEW;
END;
$$;
--- ConteÃºdo de: supabase/migrations/0043_corrigindo_a_chave_estrangeira_de_subscriptions_user_id_para_profiles_id_inserindo_o_plano_inicial_e_adicionando_gatilho_de_prote_o_.sql ---
-- 1. Remover a chave estrangeira existente em subscriptions.user_id
ALTER TABLE public.subscriptions
DROP CONSTRAINT IF EXISTS subscriptions_user_id_fkey;

-- 2. Adicionar nova chave estrangeira em subscriptions.user_id referenciando public.profiles.id
ALTER TABLE public.subscriptions
ADD CONSTRAINT subscriptions_user_id_fkey
FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;

-- 3. Inserir o "Plano Inicial" na tabela subscriber_plans se nÃ£o existir
INSERT INTO public.subscriber_plans (name, value, period_days)
SELECT 'Plano Inicial', 25.00, 30
WHERE NOT EXISTS (SELECT 1 FROM public.subscriber_plans WHERE name = 'Plano Inicial');

-- 4. Criar funÃ§Ã£o para impedir a exclusÃ£o do "Plano Inicial"
CREATE OR REPLACE FUNCTION public.prevent_default_plan_deletion()
RETURNS TRIGGER
LANGUAGE PLPGSQL
SECURITY DEFINER
SET search_path = 'public'
AS $$
BEGIN
  IF OLD.name = 'Plano Inicial' THEN
    RAISE EXCEPTION 'NÃ£o Ã© permitido excluir o Plano Inicial. VocÃª pode editÃ¡-lo se necessÃ¡rio.';
  END IF;
  RETURN OLD;
END;
$$;

-- 5. Criar gatilho para a funÃ§Ã£o prevent_default_plan_deletion
DROP TRIGGER IF EXISTS prevent_default_plan_deletion_trigger ON public.subscriber_plans;
CREATE TRIGGER prevent_default_plan_deletion_trigger
BEFORE DELETE ON public.subscriber_plans
FOR EACH ROW EXECUTE FUNCTION public.prevent_default_plan_deletion();
--- ConteÃºdo de: supabase/migrations/0044_atualizando_a_fun_o_handle_new_user_para_usar_o_plano_inicial_dinamicamente_.sql ---
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE PLPGSQL
SECURITY DEFINER SET search_path = 'public'
AS $$
DECLARE
  default_plan RECORD;
BEGIN
  -- 1. Inserir na tabela profiles
  INSERT INTO public.profiles (id, name, email)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'name', split_part(NEW.email, '@', 1)),
    NEW.email
  );

  -- 2. Inserir na tabela user_roles
  INSERT INTO public.user_roles (user_id, role)
  VALUES (NEW.id, 'user');

  -- 3. Buscar o "Plano Inicial" dinamicamente
  SELECT name, value, period_days
  INTO default_plan
  FROM public.subscriber_plans
  WHERE name = 'Plano Inicial'
  LIMIT 1;

  -- 4. Inserir na tabela subscriptions usando o Plano Inicial
  IF default_plan IS NOT NULL THEN
    INSERT INTO public.subscriptions (user_id, plan_name, price, status, next_billing_date)
    VALUES (
      NEW.id,
      default_plan.name,
      default_plan.value,
      'active',
      (NOW() + (default_plan.period_days || ' days')::INTERVAL)::date
    );
  ELSE
    -- Fallback: Se o Plano Inicial nÃ£o existir, usar valores padrÃ£o
    INSERT INTO public.subscriptions (user_id, plan_name, price, status, next_billing_date)
    VALUES (NEW.id, 'Plano Gratuito', 0.00, 'active', (NOW() + INTERVAL '30 days')::date);
  END IF;

  RETURN NEW;
END;
$$;
--- ConteÃºdo de: supabase/migrations/0045_limpando_registros_inconsistentes_em_user_instances_e_profiles_e_corrigindo_a_chave_estrangeira_para_user_instances_user_id_.sql ---
-- 1. Deletar registros em user_instances onde o user_id nÃ£o existe em auth.users
-- Isso remove instÃ¢ncias que apontam para usuÃ¡rios que nÃ£o existem mais no sistema de autenticaÃ§Ã£o.
DELETE FROM public.user_instances
WHERE user_id NOT IN (SELECT id FROM auth.users);

-- 2. Inserir perfis ausentes para user_ids que existem em auth.users mas nÃ£o em public.profiles
-- Isso garante que todo user_id referenciado em user_instances tenha um perfil correspondente.
INSERT INTO public.profiles (id, name, email)
SELECT
    au.id,
    -- Tenta usar o nome do metadata, senÃ£o usa a parte do email antes do '@', senÃ£o 'UsuÃ¡rio'
    COALESCE(au.raw_user_meta_data->>'name', split_part(au.email, '@', 1), 'UsuÃ¡rio'),
    au.email -- Usa o email do auth.users
FROM auth.users au
WHERE au.id IN (
    SELECT ui.user_id
    FROM public.user_instances ui
    LEFT JOIN public.profiles p ON ui.user_id = p.id
    WHERE p.id IS NULL
)
AND au.id NOT IN (SELECT id FROM public.profiles); -- Evita duplicatas se o perfil jÃ¡ foi criado por outro meio

-- 3. Remover a chave estrangeira existente em user_instances.user_id (se existir)
ALTER TABLE public.user_instances
DROP CONSTRAINT IF EXISTS user_instances_user_id_fkey;

-- 4. Adicionar a nova chave estrangeira em user_instances.user_id referenciando public.profiles.id
ALTER TABLE public.user_instances
ADD CONSTRAINT user_instances_user_id_fkey
FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;
--- ConteÃºdo de: supabase/migrations/0046_desabilitando_temporariamente_o_gatilho_de_prote_o_consolidando_planos_plano_inicial_duplicados_e_reabilitando_o_gatilho_.sql ---
-- 1. Desabilitar temporariamente o gatilho de proteÃ§Ã£o
ALTER TABLE public.subscriber_plans DISABLE TRIGGER prevent_default_plan_deletion_trigger;

-- 2. Consolidar entradas duplicadas de 'Plano Inicial' na tabela subscriber_plans
WITH plan_to_keep AS (
    SELECT id
    FROM public.subscriber_plans
    WHERE name = 'Plano Inicial'
    ORDER BY created_at ASC
    LIMIT 1
)
DELETE FROM public.subscriber_plans
WHERE name = 'Plano Inicial'
  AND id NOT IN (SELECT id FROM plan_to_keep);

-- 3. Reabilitar o gatilho de proteÃ§Ã£o
ALTER TABLE public.subscriber_plans ENABLE TRIGGER prevent_default_plan_deletion_trigger;
--- ConteÃºdo de: supabase/migrations/0047_adicionando_a_coluna_phone_tabela_profiles_e_atualizando_a_fun_o_handle_new_user_para_incluir_o_telefone_do_metadata_do_usu_rio_.sql ---
-- Adicionar a coluna 'phone' Ã  tabela 'profiles' se ela nÃ£o existir
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'phone') THEN
        ALTER TABLE public.profiles ADD COLUMN phone TEXT;
        -- Adicionar um Ã­ndice para consultas mais rÃ¡pidas, se necessÃ¡rio
        CREATE INDEX IF NOT EXISTS idx_profiles_phone ON public.profiles(phone);
        COMMENT ON COLUMN public.profiles.phone IS 'NÃºmero de telefone do usuÃ¡rio, obrigatÃ³rio para usuÃ¡rios nÃ£o-admin.';
    END IF;
END
$$;

-- Atualizar a funÃ§Ã£o handle_new_user para incluir o campo 'phone'
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE PLPGSQL
SECURITY DEFINER SET search_path = ''
AS $$
DECLARE
  default_plan RECORD;
BEGIN
  -- 1. Inserir na tabela profiles
  INSERT INTO public.profiles (id, name, email, phone) -- Adicionado 'phone'
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'name', split_part(NEW.email, '@', 1)),
    NEW.email,
    NEW.raw_user_meta_data->>'phone' -- Tenta pegar o telefone do metadata
  );

  -- 2. Inserir na tabela user_roles
  INSERT INTO public.user_roles (user_id, role)
  VALUES (NEW.id, 'user');

  -- 3. Buscar o "Plano Inicial" dinamicamente
  SELECT name, value, period_days
  INTO default_plan
  FROM public.subscriber_plans
  WHERE name = 'Plano Inicial'
  LIMIT 1;

  -- 4. Inserir na tabela subscriptions usando o Plano Inicial
  IF default_plan IS NOT NULL THEN
    INSERT INTO public.subscriptions (user_id, plan_name, price, status, next_billing_date)
    VALUES (
      NEW.id,
      default_plan.name,
      default_plan.value,
      'active',
      (NOW() + (default_plan.period_days || ' days')::INTERVAL)::date
    );
  ELSE
    -- Fallback: Se o Plano Inicial nÃ£o existir, usar valores padrÃ£o
    INSERT INTO public.subscriptions (user_id, plan_name, price, status, next_billing_date)
    VALUES (NEW.id, 'Plano Gratuito', 0.00, 'active', (NOW() + INTERVAL '30 days')::date);
  END IF;

  RETURN NEW;
END;
$$;
--- ConteÃºdo de: supabase/migrations/0048_criando_tabelas_pagbank_configs_e_pagbank_charges_com_rls_para_integra_o_pagbank_pix_.sql ---
-- Tabela: pagbank_configs
-- Armazena as credenciais da API do PagBank de forma segura.
CREATE TABLE public.pagbank_configs (
  id BIGINT PRIMARY KEY DEFAULT 1, -- Garante uma Ãºnica linha de configuraÃ§Ã£o
  pagbank_email TEXT NOT NULL,
  pagbank_token TEXT NOT NULL,
  pagbank_pix_key TEXT NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Habilitar RLS (Row Level Security)
ALTER TABLE public.pagbank_configs ENABLE ROW LEVEL SECURITY;

-- PolÃ­ticas de RLS para pagbank_configs: Apenas admins podem ler e escrever
CREATE POLICY "Admins can view PagBank configs" ON public.pagbank_configs
FOR SELECT TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

CREATE POLICY "Admins can insert PagBank configs" ON public.pagbank_configs
FOR INSERT TO authenticated WITH CHECK (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

CREATE POLICY "Admins can update PagBank configs" ON public.pagbank_configs
FOR UPDATE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

-- Tabela: pagbank_charges
-- Rastreia cada cobranÃ§a PIX gerada.
CREATE TABLE public.pagbank_charges (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  subscription_id UUID NOT NULL REFERENCES public.subscriptions(id) ON DELETE CASCADE,
  pagbank_charge_id TEXT NOT NULL UNIQUE,
  status TEXT NOT NULL DEFAULT 'PENDING', -- PENDING, PAID, EXPIRED
  value NUMERIC NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Habilitar RLS (Row Level Security)
ALTER TABLE public.pagbank_charges ENABLE ROW LEVEL SECURITY;

-- PolÃ­ticas de RLS para pagbank_charges:
-- UsuÃ¡rios podem ler apenas suas prÃ³prias cobranÃ§as. Admins podem ler todas.
CREATE POLICY "Users can view their own PagBank charges" ON public.pagbank_charges
FOR SELECT TO authenticated USING (auth.uid() = user_id OR EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

-- NinguÃ©m pode inserir, atualizar ou deletar via RLS diretamente (apenas via Edge Functions com service_role_key)
-- As Edge Functions usarÃ£o o service_role_key para manipular esta tabela, ignorando RLS.
--- ConteÃºdo de: supabase/migrations/0049_add_tax_id_to_profiles_table.sql ---
-- Adicionando a coluna tax_id (CPF/CNPJ) Ã  tabela public.profiles como TEXT NOT NULL.
ALTER TABLE public.profiles
ADD COLUMN tax_id TEXT NOT NULL DEFAULT '';

COMMENT ON COLUMN public.profiles.tax_id IS 'CPF ou CNPJ do usuÃ¡rio (apenas nÃºmeros). ObrigatÃ³rio.';

-- Atualiza registros existentes para ter um valor padrÃ£o vÃ¡lido (ex: '00000000000')
-- Isso Ã© necessÃ¡rio porque a coluna Ã© NOT NULL e pode haver perfis existentes sem esse campo.
-- O usuÃ¡rio deverÃ¡ atualizar seu perfil com um CPF/CNPJ real.
UPDATE public.profiles
SET tax_id = '00000000000'
WHERE tax_id IS NULL OR tax_id = '';
--- ConteÃºdo de: supabase/migrations/0049_adicionando_a_coluna_tax_id_cpf_cnpj_tabela_public_profiles_como_text_not_null_.sql ---
ALTER TABLE public.profiles
ADD COLUMN tax_id TEXT NOT NULL DEFAULT '';

COMMENT ON COLUMN public.profiles.tax_id IS 'CPF ou CNPJ do usuÃ¡rio (apenas nÃºmeros). ObrigatÃ³rio.';

-- Atualiza registros existentes para ter um valor padrÃ£o vÃ¡lido (ex: '00000000000')
-- Isso Ã© necessÃ¡rio porque a coluna Ã© NOT NULL e pode haver perfis existentes sem esse campo.
-- O usuÃ¡rio deverÃ¡ atualizar seu perfil com um CPF/CNPJ real.
UPDATE public.profiles
SET tax_id = '00000000000'
WHERE tax_id IS NULL OR tax_id = '';
--- ConteÃºdo de: supabase/migrations/0050_adicionando_a_coluna_environment_e_o_tipo_enum_pagbank_environment_tabela_pagbank_configs_.sql ---
-- Create the enum type if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'pagbank_environment') THEN
        CREATE TYPE public.pagbank_environment AS ENUM ('sandbox', 'production');
    END IF;
END
$$;

-- Add the 'environment' column to 'pagbank_configs' table
ALTER TABLE public.pagbank_configs
ADD COLUMN environment public.pagbank_environment NOT NULL DEFAULT 'sandbox'::public.pagbank_environment;

-- Add a comment to the new column
COMMENT ON COLUMN public.pagbank_configs.environment IS 'Ambiente da API PagBank a ser utilizado (sandbox ou production).';
--- ConteÃºdo de: supabase/migrations/0051_corrigindo_a_migra_o_sql_para_adicionar_a_coluna_environment_tabela_pagbank_configs_apenas_se_ela_n_o_existir_garantindo_idempot_ncia_.sql ---
-- Create the enum type if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'pagbank_environment') THEN
        CREATE TYPE public.pagbank_environment AS ENUM ('sandbox', 'production');
    END IF;
END
$$;

-- Add the 'environment' column to 'pagbank_configs' table if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_schema = 'public'
        AND table_name = 'pagbank_configs'
        AND column_name = 'environment'
    ) THEN
        ALTER TABLE public.pagbank_configs
        ADD COLUMN environment public.pagbank_environment NOT NULL DEFAULT 'sandbox'::public.pagbank_environment;

        -- Add a comment to the new column
        COMMENT ON COLUMN public.pagbank_configs.environment IS 'Ambiente da API PagBank a ser utilizado (sandbox ou production).';
    END IF;
END
$$;
--- ConteÃºdo de: supabase/migrations/0052_creating_the_mercado_pago_configs_table_with_rls_policies_.sql ---
CREATE TABLE public.mercado_pago_configs (
  id BIGINT PRIMARY KEY DEFAULT 1,
  mercado_pago_public_key TEXT NOT NULL,
  mercado_pago_access_token TEXT NOT NULL,
  mercado_pago_client_id TEXT NOT NULL,
  mercado_pago_client_secret TEXT NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

ALTER TABLE public.mercado_pago_configs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins can view Mercado Pago configs" ON public.mercado_pago_configs
FOR SELECT TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

CREATE POLICY "Admins can manage Mercado Pago configs" ON public.mercado_pago_configs
FOR ALL TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

-- Ensure only one row exists
ALTER TABLE public.mercado_pago_configs ADD CONSTRAINT enforce_single_row CHECK (id = 1);
--- ConteÃºdo de: supabase/migrations/0053_creating_active_payment_gateway_table_with_rls_for_admin_users_.sql ---
-- Create active_payment_gateway table
CREATE TABLE public.active_payment_gateway (
  id BIGINT PRIMARY KEY DEFAULT 1,
  gateway_name TEXT NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable RLS (REQUIRED)
ALTER TABLE public.active_payment_gateway ENABLE ROW LEVEL SECURITY;

-- Policy: Admins can view the active payment gateway
CREATE POLICY "Admins can view active payment gateway" ON public.active_payment_gateway
FOR SELECT TO authenticated
USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

-- Policy: Admins can update the active payment gateway
CREATE POLICY "Admins can update active payment gateway" ON public.active_payment_gateway
FOR UPDATE TO authenticated
USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

-- Policy: Admins can insert the active payment gateway (for initial setup)
CREATE POLICY "Admins can insert active payment gateway" ON public.active_payment_gateway
FOR INSERT TO authenticated
WITH CHECK (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

-- Ensure only one row exists by preventing inserts if id=1 already exists
-- This is handled by the Edge Function's upsert logic, but a unique constraint on id=1 is good.
-- No need for a specific trigger here, the primary key default 1 handles it.
--- ConteÃºdo de: supabase/migrations/0054_creating_the_mercado_pago_charges_table_with_rls_policies_for_mercado_pago_integration_.sql ---
-- Create mercado_pago_charges table
CREATE TABLE public.mercado_pago_charges (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  subscription_id UUID NOT NULL REFERENCES public.subscriptions(id) ON DELETE CASCADE,
  mercado_pago_payment_id TEXT NOT NULL UNIQUE,
  status TEXT NOT NULL DEFAULT 'pending', -- e.g., 'pending', 'approved', 'rejected', 'cancelled'
  value NUMERIC NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable RLS (REQUIRED for security)
ALTER TABLE public.mercado_pago_charges ENABLE ROW LEVEL SECURITY;

-- RLS Policies for mercado_pago_charges
-- Users can view their own Mercado Pago charges
CREATE POLICY "Users can view their own Mercado Pago charges" ON public.mercado_pago_charges
FOR SELECT TO authenticated USING (auth.uid() = user_id);

-- Users can insert their own Mercado Pago charges (e.g., when initiating a payment)
CREATE POLICY "Users can insert their own Mercado Pago charges" ON public.mercado_pago_charges
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);

-- Users can update their own Mercado Pago charges (e.g., if status changes on client-side)
CREATE POLICY "Users can update their own Mercado Pago charges" ON public.mercado_pago_charges
FOR UPDATE TO authenticated USING (auth.uid() = user_id);

-- Users can delete their own Mercado Pago charges (if needed, though usually not for payments)
CREATE POLICY "Users can delete their own Mercado Pago charges" ON public.mercado_pago_charges
FOR DELETE TO authenticated USING (auth.uid() = user_id);

-- Admin policies (optional, but good for full control)
-- Admins can view all Mercado Pago charges
CREATE POLICY "Admins can view all Mercado Pago charges" ON public.mercado_pago_charges
FOR SELECT TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

-- Admins can insert Mercado Pago charges for any user
CREATE POLICY "Admins can insert Mercado Pago charges" ON public.mercado_pago_charges
FOR INSERT TO authenticated WITH CHECK (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

-- Admins can update Mercado Pago charges for any user
CREATE POLICY "Admins can update Mercado Pago charges" ON public.mercado_pago_charges
FOR UPDATE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));

-- Admins can delete Mercado Pago charges for any user
CREATE POLICY "Admins can delete Mercado Pago charges" ON public.mercado_pago_charges
FOR DELETE TO authenticated USING (EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin'));
--- ConteÃºdo de: supabase/migrations/0055_update_rls_policy_for_active_payment_gateway_to_allow_all_authenticated_users_to_read_.sql ---
DROP POLICY IF EXISTS "Admins can view active payment gateway" ON public.active_payment_gateway;
CREATE POLICY "Authenticated users can view active payment gateway" ON public.active_payment_gateway
FOR SELECT TO authenticated USING (true);
--- ConteÃºdo de: supabase/migrations/0056_making_the_tax_id_column_in_the_public_profiles_table_nullable_.sql ---
ALTER TABLE public.profiles ALTER COLUMN tax_id DROP NOT NULL;
--- ConteÃºdo de: supabase/migrations/0057_making_the_tax_id_column_in_the_public_profiles_table_nullable_.sql ---
ALTER TABLE public.profiles ALTER COLUMN tax_id DROP NOT NULL;
--- ConteÃºdo de: supabase/migrations/0058_add_is_free_to_subscriber_plans_idempotently.sql ---
DO $$
BEGIN
    -- Check if the column 'is_free' does NOT exist in public.subscriber_plans
    IF NOT EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_schema = 'public'
        AND table_name = 'subscriber_plans'
        AND column_name = 'is_free'
    ) THEN
        RAISE NOTICE 'Adding column "is_free" to "public.subscriber_plans"...';
        -- Add the column as nullable first
        ALTER TABLE public.subscriber_plans
        ADD COLUMN is_free BOOLEAN;

        -- Update existing rows to set a default value (FALSE)
        UPDATE public.subscriber_plans
        SET is_free = FALSE
        WHERE is_free IS NULL;

        -- Set the default value for new rows
        ALTER TABLE public.subscriber_plans
        ALTER COLUMN is_free SET DEFAULT FALSE;

        -- Finally, set the column to NOT NULL
        ALTER TABLE public.subscriber_plans
        ALTER COLUMN is_free SET NOT NULL;

        RAISE NOTICE 'Column "is_free" added to "public.subscriber_plans" with DEFAULT FALSE NOT NULL.';
    ELSE
        -- If the column exists, ensure it has the correct default and NOT NULL constraint
        RAISE NOTICE 'Column "is_free" already exists in "public.subscriber_plans". Checking constraints...';
        
        -- Check if it's nullable and fix if necessary
        IF EXISTS (
            SELECT 1
            FROM information_schema.columns
            WHERE table_schema = 'public'
            AND table_name = 'subscriber_plans'
            AND column_name = 'is_free'
            AND is_nullable = 'YES'
        ) THEN
            RAISE NOTICE 'Column "is_free" in "public.subscriber_plans" is nullable. Updating to NOT NULL.';
            UPDATE public.subscriber_plans
            SET is_free = FALSE
            WHERE is_free IS NULL;
            ALTER TABLE public.subscriber_plans
            ALTER COLUMN is_free SET NOT NULL;
        END IF;

        -- Check if the default is not 'false' and fix if necessary
        IF EXISTS (
            SELECT 1
            FROM information_schema.columns
            WHERE table_schema = 'public'
            AND table_name = 'subscriber_plans'
            AND column_name = 'is_free'
            AND column_default IS DISTINCT FROM 'false'
        ) THEN
            RAISE NOTICE 'Column "is_free" in "public.subscriber_plans" has incorrect default. Updating default.';
            ALTER TABLE public.subscriber_plans
            ALTER COLUMN is_free SET DEFAULT FALSE;
        END IF;
        RAISE NOTICE 'Constraints for "is_free" in "public.subscriber_plans" checked and applied if needed.';
    END IF;
END $$;
--- ConteÃºdo de: supabase/migrations/0059_create_or_replace_the_function_to_set_subscription_status_based_on_plan_and_due_date_and_create_the_trigger_.sql ---
CREATE OR REPLACE FUNCTION public.set_subscription_status_based_on_plan_and_due_date()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  plan_is_free BOOLEAN;
  local_today DATE;
BEGIN
  -- ObtÃ©m a data de hoje no fuso horÃ¡rio 'America/Sao_Paulo'
  local_today := (NOW() AT TIME ZONE 'America/Sao_Paulo')::DATE;

  -- Busca se o plano associado Ã© gratuito
  SELECT sp.is_free INTO plan_is_free
  FROM public.subscriber_plans sp
  WHERE sp.name = NEW.plan_name
  LIMIT 1;

  -- Se o plano for gratuito, o status Ã© sempre 'active' e next_billing_date Ã© NULL
  IF plan_is_free THEN
    NEW.status := 'active';
    NEW.next_billing_date := NULL;
  ELSE
    -- Se o plano nÃ£o for gratuito, verifica a data de vencimento
    IF NEW.next_billing_date IS NULL THEN
      -- Se nÃ£o for gratuito e nÃ£o tiver data de vencimento, Ã© inativo
      NEW.status := 'inactive';
    ELSIF NEW.next_billing_date < local_today THEN
      NEW.status := 'overdue';
    ELSE
      NEW.status := 'active';
    END IF;
  END IF;

  RETURN NEW;
END;
$function$;

-- Drop existing triggers if they exist to avoid duplicates or conflicts
DROP TRIGGER IF EXISTS trigger_set_subscription_status ON public.subscriptions;

-- Create the trigger for INSERT and UPDATE operations
CREATE TRIGGER trigger_set_subscription_status
BEFORE INSERT OR UPDATE ON public.subscriptions
FOR EACH ROW EXECUTE FUNCTION public.set_subscription_status_based_on_plan_and_due_date();
--- ConteÃºdo de: supabase/migrations/20240801000000_populate_url_configs.sql ---
-- Este script insere a linha de configuraÃ§Ã£o na tabela url_configs.
-- Se a linha com id=1 jÃ¡ existir, ele atualiza os valores (operaÃ§Ã£o idempotente).

INSERT INTO public.url_configs (id, n8n_webhook_url, evolution_listener_url)
VALUES (
  1,
  -- URL do n8n para criar a instÃ¢ncia (fornecida pelo utilizador)
  'https://tragic-crayfish-noxius-cyberwork-redes2-f82088fb.koyeb.app/webhook/ffd0c002-d429-48a1-8d0d-101d312497c5',
  -- URL do "ouvinte" (a sua Supabase Function).
  'https://cgqyfpsfymhntumrmbzj.supabase.co/functions/v1/evolution-webhook-receiver'
)
ON CONFLICT (id) 
DO UPDATE SET 
  n8n_webhook_url = EXCLUDED.n8n_webhook_url,
  evolution_listener_url = EXCLUDED.evolution_listener_url;
--- ConteÃºdo de: supabase/migrations/20240801103000_cleanup_old_cron_scheduler.sql ---
-- Desativar e remover todos os cron jobs conhecidos
SELECT cron.unschedule('process-notification-queue-job');
SELECT cron.unschedule('process-automated-notifications-job');

-- Remover funÃ§Ãµes SQL que usam tipos da extensÃ£o http ou sÃ£o parte dela
-- Usamos CASCADE para remover quaisquer objetos dependentes (como triggers, se houver)
DROP FUNCTION IF EXISTS public.http_post(character varying, jsonb) CASCADE;
DROP FUNCTION IF EXISTS public.http_post(character varying, character varying, character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http_set_curlopt(character varying, character varying) CASCADE;
DROP FUNCTION IF EXISTS public.bytea_to_text(bytea) CASCADE;
DROP FUNCTION IF EXISTS public.http_header(character varying, character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http_delete(character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http_delete(character varying, character varying, character varying) CASCADE;
DROP FUNCTION IF EXISTS public.urlencode(bytea) CASCADE;
DROP FUNCTION IF EXISTS public.urlencode(character varying) CASCADE;
DROP FUNCTION IF EXISTS public.urlencode(jsonb) CASCADE;
DROP FUNCTION IF EXISTS public.http_head(character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http_list_curlopt() CASCADE;
DROP FUNCTION IF EXISTS public.text_to_bytea(text) CASCADE;
DROP FUNCTION IF EXISTS public.http_reset_curlopt() CASCADE;
DROP FUNCTION IF EXISTS public.http_get(character varying, jsonb) CASCADE;
DROP FUNCTION IF EXISTS public.http_get(character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http(http_request) CASCADE;
DROP FUNCTION IF EXISTS public.http_put(character varying, character varying, character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http_patch(character varying, character varying, character varying) CASCADE;

-- Remover as funÃ§Ãµes de agendamento que foram substituÃ­das
DROP FUNCTION IF EXISTS public.process_notification_queue CASCADE;
DROP FUNCTION IF EXISTS public.process_automated_notifications CASCADE;

-- Remover a extensÃ£o http (pg_net) e seus tipos
DROP EXTENSION IF EXISTS http CASCADE;
DROP TYPE IF EXISTS public.http_request CASCADE;
DROP TYPE IF EXISTS public.http_response CASCADE;
DROP TYPE IF EXISTS public.http_header CASCADE;
--- ConteÃºdo de: supabase/migrations/20240802000000_fix_security_warnings.sql ---
-- CorreÃ§Ã£o de Alertas de SeguranÃ§a do Banco de Dados Supabase

-- 1. Corrigir o search_path das FunÃ§Ãµes para 'public'

-- FunÃ§Ã£o: public.set_client_status_based_on_due_date
CREATE OR REPLACE FUNCTION public.set_client_status_based_on_due_date()
RETURNS trigger
LANGUAGE plpgsql
AS $function$
BEGIN
  -- Verifica se o status atual nÃ£o Ã© 'inativo'. NÃ£o queremos reativar um cliente cancelado automaticamente.
  IF NEW.status != 'inactive' THEN
    -- Se a data de vencimento for anterior a hoje, define o status como 'vencido'.
    IF NEW.next_billing_date < CURRENT_DATE THEN
      NEW.status := 'overdue';
    -- Caso contrÃ¡rio, define o status como 'ativo'.
    ELSE
      NEW.status := 'active';
    END IF;
  END IF;

  RETURN NEW;
END;
$function$
SET search_path = public;

-- FunÃ§Ã£o: public.handle_client_cancellation
CREATE OR REPLACE FUNCTION public.handle_client_cancellation()
RETURNS trigger
LANGUAGE plpgsql
AS $function$
BEGIN
  -- A funÃ§Ã£o sÃ³ executa se o status foi alterado PARA 'inactive'
  IF NEW.status = 'inactive' AND OLD.status != 'inactive' THEN

    -- AÃ§Ã£o 1: Remover o cliente de todas as futuras mensagens agendadas
    DELETE FROM public.pending_sends
    WHERE client_id = NEW.id;

    -- AÃ§Ã£o 2: Remover o ID do cliente de todas as regras de automaÃ§Ã£o
    -- onde ele possa estar presente.
    UPDATE public.automations
    SET client_ids = array_remove(client_ids, NEW.id)
    WHERE user_id = NEW.user_id AND NEW.id = ANY(client_ids);

  END IF;

  RETURN NEW;
END;
$function$
SET search_path = public;

-- FunÃ§Ã£o: public.handle_client_overdue_status
CREATE OR REPLACE FUNCTION public.handle_client_overdue_status()
RETURNS trigger
LANGUAGE plpgsql
AS $function$
BEGIN
  -- A funÃ§Ã£o sÃ³ executa se o status foi alterado PARA 'overdue'
  IF NEW.status = 'overdue' AND OLD.status != 'overdue' THEN

    -- AÃ§Ã£o: Remove o cliente de todas as futuras mensagens agendadas
    DELETE FROM public.pending_sends
    WHERE client_id = NEW.id;

  END IF;

  RETURN NEW;
END;
$function$
SET search_path = public;

-- FunÃ§Ã£o: public.update_updated_at_column
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS trigger
LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
SET search_path = public;

-- FunÃ§Ã£o: public.process_notification_queue
-- Nota: Esta funÃ§Ã£o jÃ¡ tinha SECURITY DEFINER SET search_path = '', que serÃ¡ substituÃ­do por SET search_path = public.
CREATE OR REPLACE FUNCTION public.process_notification_queue()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
DECLARE
    notification_record RECORD;
    edge_function_url TEXT;
    supabase_project_id TEXT := 'cgqyfpsfymhntumrmbzj'; -- Substitua pelo seu Project ID do Supabase
    edge_function_name TEXT := 'send-scheduled-notification';
BEGIN
    -- ConstrÃ³i a URL da Edge Function
    edge_function_url := 'https://' || supabase_project_id || '.supabase.co/functions/v1/' || edge_function_name;

    -- Seleciona notificaÃ§Ãµes pendentes que estÃ£o vencidas ou para vencer agora
    FOR notification_record IN
        SELECT id, user_id, client_id, template_id, send_at
        FROM public.scheduled_notifications
        WHERE status = 'pending' AND send_at <= NOW()
        FOR UPDATE SKIP LOCKED -- Bloqueia as linhas selecionadas e pula se jÃ¡ estiverem bloqueadas
    LOOP
        -- Atualiza o status para 'processing' para evitar reprocessamento
        UPDATE public.scheduled_notifications
        SET status = 'processing'
        WHERE id = notification_record.id;

        -- Invoca a Edge Function assincronamente usando pg_net
        PERFORM extensions.http_post( -- Usar extensions.http_post
            url := edge_function_url,
            headers := ARRAY[
                extensions.http_header('Content-Type', 'application/json') -- Usar extensions.http_header
            ],
            body := jsonb_build_object('id', notification_record.id)
        );

        RAISE NOTICE 'NotificaÃ§Ã£o agendada % para o usuÃ¡rio % enviada para a Edge Function para processamento.', notification_record.id, notification_record.user_id;
    END LOOP;
END;
$function$
SET search_path = public;


-- 2. Isolar a ExtensÃ£o 'http' no schema 'extensions'

-- Criar um schema dedicado para extensÃµes, se ainda nÃ£o existir.
CREATE SCHEMA IF NOT EXISTS extensions;

-- Mover a extensÃ£o 'http' do schema 'public' para o schema 'extensions'.
ALTER EXTENSION http SET SCHEMA extensions;
--- ConteÃºdo de: supabase/migrations/20240803000000_add_logging_to_process_notification_queue.sql ---
-- Adicionando logs Ã  funÃ§Ã£o public.process_notification_queue para diagnÃ³stico

CREATE OR REPLACE FUNCTION public.process_notification_queue()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
DECLARE
    notification_record RECORD;
    edge_function_url TEXT;
    supabase_project_id TEXT := 'cgqyfpsfymhntumrmbzj'; -- Substitua pelo seu Project ID do Supabase
    edge_function_name TEXT := 'send-scheduled-notification';
    pending_count INTEGER;
BEGIN
    RAISE NOTICE 'process_notification_queue: FunÃ§Ã£o iniciada pelo cron job.';

    -- ConstrÃ³i a URL da Edge Function
    edge_function_url := 'https://' || supabase_project_id || '.supabase.co/functions/v1/' || edge_function_name;

    -- Seleciona notificaÃ§Ãµes pendentes que estÃ£o vencidas ou para vencer agora
    SELECT COUNT(*)
    INTO pending_count
    FROM public.scheduled_notifications
    WHERE status = 'pending' AND send_at <= NOW();

    RAISE NOTICE 'process_notification_queue: Encontrados % agendamentos pendentes para processar.', pending_count;

    FOR notification_record IN
        SELECT id, user_id, client_id, template_id, send_at, automation_id
        FROM public.scheduled_notifications
        WHERE status = 'pending' AND send_at <= NOW()
        FOR UPDATE SKIP LOCKED -- Bloqueia as linhas selecionadas e pula se jÃ¡ estiverem bloqueadas
    LOOP
        RAISE NOTICE 'process_notification_queue: Processando notificaÃ§Ã£o agendada ID: %, Cliente ID: %, Enviar em: %', notification_record.id, notification_record.client_id, notification_record.send_at;

        -- Atualiza o status para 'processing' para evitar reprocessamento
        UPDATE public.scheduled_notifications
        SET status = 'processing'
        WHERE id = notification_record.id;

        -- Invoca a Edge Function assincronamente usando pg_net
        PERFORM extensions.http_post(
            url := edge_function_url,
            headers := ARRAY[
                extensions.http_header('Content-Type', 'application/json')
            ],
            body := jsonb_build_object('id', notification_record.id)
        );

        RAISE NOTICE 'process_notification_queue: NotificaÃ§Ã£o agendada % para o usuÃ¡rio % delegada para a Edge Function de envio.', notification_record.id, notification_record.user_id;
    END LOOP;

    RAISE NOTICE 'process_notification_queue: ConcluÃ­do o processamento da fila.';
END;
$function$
SET search_path = public;
--- ConteÃºdo de: supabase/migrations/20240804000000_final_cron_cleanup.sql ---
-- Desativar e remover todos os cron jobs conhecidos para evitar execuÃ§Ãµes indesejadas
SELECT cron.unschedule('process-notification-queue-job');
SELECT cron.unschedule('process-automated-notifications-job');

-- Remover as funÃ§Ãµes de agendamento antigas que foram substituÃ­das pelas Edge Functions.
-- Usamos CASCADE para garantir que quaisquer objetos dependentes (como triggers) tambÃ©m sejam removidos.
DROP FUNCTION IF EXISTS public.process_notification_queue CASCADE;
DROP FUNCTION IF EXISTS public.process_automated_notifications CASCADE;

-- Remover todas as funÃ§Ãµes relacionadas Ã  extensÃ£o 'http' (pg_net) que podem estar causando o erro.
-- A ordem Ã© importante para evitar erros de dependÃªncia.
DROP FUNCTION IF EXISTS public.http_post(character varying, jsonb) CASCADE;
DROP FUNCTION IF EXISTS public.http_post(character varying, character varying, character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http_set_curlopt(character varying, character varying) CASCADE;
DROP FUNCTION IF EXISTS public.bytea_to_text(bytea) CASCADE;
DROP FUNCTION IF EXISTS public.http_header(character varying, character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http_delete(character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http_delete(character varying, character varying, character varying) CASCADE;
DROP FUNCTION IF EXISTS public.urlencode(bytea) CASCADE;
DROP FUNCTION IF EXISTS public.urlencode(character varying) CASCADE;
DROP FUNCTION IF EXISTS public.urlencode(jsonb) CASCADE;
DROP FUNCTION IF EXISTS public.http_head(character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http_list_curlopt() CASCADE;
DROP FUNCTION IF EXISTS public.text_to_bytea(text) CASCADE;
DROP FUNCTION IF EXISTS public.http_reset_curlopt() CASCADE;
DROP FUNCTION IF EXISTS public.http_get(character varying, jsonb) CASCADE;
DROP FUNCTION IF EXISTS public.http_get(character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http(http_request) CASCADE; -- Esta pode falhar se o tipo http_request jÃ¡ nÃ£o existir, mas Ã© importante tentar.
DROP FUNCTION IF EXISTS public.http_put(character varying, character varying, character varying) CASCADE;
DROP FUNCTION IF EXISTS public.http_patch(character varying, character varying, character varying) CASCADE;

-- Finalmente, remover a prÃ³pria extensÃ£o 'http' e seus tipos, se ainda existirem.
DROP EXTENSION IF EXISTS http CASCADE;
DROP TYPE IF EXISTS public.http_request CASCADE;
DROP TYPE IF EXISTS public.http_response CASCADE;
DROP TYPE IF EXISTS public.http_header CASCADE;
--- ConteÃºdo de: supabase/migrations/20251007003528_102cc75e-094b-4867-af88-81f4a22932be.sql ---
-- Create enum for user roles
CREATE TYPE public.app_role AS ENUM ('admin', 'user');

-- Create enum for client status
CREATE TYPE public.client_status AS ENUM ('active', 'inactive', 'overdue');

-- Create enum for template category
CREATE TYPE public.template_category AS ENUM ('pre_due', 'due_today', 'overdue', 'celebratory');

-- Create profiles table
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Create user_roles table
CREATE TABLE public.user_roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  role app_role NOT NULL DEFAULT 'user',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(user_id, role)
);

-- Create plans table
CREATE TABLE public.plans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  value DECIMAL(10, 2) NOT NULL,
  period_days INTEGER NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Create clients table
CREATE TABLE public.clients (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  phone TEXT NOT NULL,
  email TEXT,
  notes TEXT,
  plan_id UUID REFERENCES public.plans(id) ON DELETE SET NULL,
  due_date DATE NOT NULL,
  next_billing_date DATE NOT NULL,
  status client_status NOT NULL DEFAULT 'active',
  value DECIMAL(10, 2) NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Create templates table
CREATE TABLE public.templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  category template_category NOT NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Create logs table
CREATE TABLE public.logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  action TEXT NOT NULL,
  details JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Enable Row Level Security
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.clients ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.logs ENABLE ROW LEVEL SECURITY;

-- Create security definer function to check roles
CREATE OR REPLACE FUNCTION public.has_role(_user_id UUID, _role app_role)
RETURNS BOOLEAN
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.user_roles
    WHERE user_id = _user_id
    AND role = _role
  )
$$;

-- RLS Policies for profiles
CREATE POLICY "Users can view their own profile"
  ON public.profiles FOR SELECT
  USING (auth.uid() = id);

CREATE POLICY "Users can update their own profile"
  ON public.profiles FOR UPDATE
  USING (auth.uid() = id);

CREATE POLICY "Admins can view all profiles"
  ON public.profiles FOR SELECT
  USING (public.has_role(auth.uid(), 'admin'));

-- RLS Policies for user_roles
CREATE POLICY "Users can view their own roles"
  ON public.user_roles FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Admins can manage all roles"
  ON public.user_roles FOR ALL
  USING (public.has_role(auth.uid(), 'admin'));

-- RLS Policies for plans
CREATE POLICY "Users can view their own plans"
  ON public.plans FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own plans"
  ON public.plans FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own plans"
  ON public.plans FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own plans"
  ON public.plans FOR DELETE
  USING (auth.uid() = user_id);

CREATE POLICY "Admins can view all plans"
  ON public.plans FOR SELECT
  USING (public.has_role(auth.uid(), 'admin'));

-- RLS Policies for clients
CREATE POLICY "Users can view their own clients"
  ON public.clients FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own clients"
  ON public.clients FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own clients"
  ON public.clients FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own clients"
  ON public.clients FOR DELETE
  USING (auth.uid() = user_id);

CREATE POLICY "Admins can view all clients"
  ON public.clients FOR SELECT
  USING (public.has_role(auth.uid(), 'admin'));

-- RLS Policies for templates
CREATE POLICY "Users can view their own templates"
  ON public.templates FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own templates"
  ON public.templates FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own templates"
  ON public.templates FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own templates"
  ON public.templates FOR DELETE
  USING (auth.uid() = user_id);

CREATE POLICY "Admins can view all templates"
  ON public.templates FOR SELECT
  USING (public.has_role(auth.uid(), 'admin'));

-- RLS Policies for logs
CREATE POLICY "Users can view their own logs"
  ON public.logs FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own logs"
  ON public.logs FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Admins can view all logs"
  ON public.logs FOR SELECT
  USING (public.has_role(auth.uid(), 'admin'));

-- Function to handle new user creation
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, name, email)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'name', split_part(NEW.email, '@', 1)),
    NEW.email
  );
  
  -- Assign default user role
  INSERT INTO public.user_roles (user_id, role)
  VALUES (NEW.id, 'user');
  
  RETURN NEW;
END;
$$;

-- Trigger to create profile on user signup
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

-- Triggers for updated_at
CREATE TRIGGER update_profiles_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_plans_updated_at
  BEFORE UPDATE ON public.plans
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_clients_updated_at
  BEFORE UPDATE ON public.clients
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_templates_updated_at
  BEFORE UPDATE ON public.templates
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
--- ConteÃºdo de: supabase/migrations/20251008221742_04f85bc8-acba-4ba7-b6d0-7d68f700c615.sql ---
-- Create templates table
CREATE TABLE public.templates (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  category TEXT NOT NULL CHECK (category IN ('pre_due', 'due_today', 'overdue', 'celebratory')),
  content TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);

-- Enable Row Level Security
ALTER TABLE public.templates ENABLE ROW LEVEL SECURITY;

-- Create policies for user access
CREATE POLICY "Users can view their own templates" 
ON public.templates 
FOR SELECT 
USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own templates" 
ON public.templates 
FOR INSERT 
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own templates" 
ON public.templates 
FOR UPDATE 
USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own templates" 
ON public.templates 
FOR DELETE 
USING (auth.uid() = user_id);

-- Create function to update timestamps
CREATE OR REPLACE FUNCTION public.update_templates_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SET search_path = public;

-- Create trigger for automatic timestamp updates
CREATE TRIGGER update_templates_updated_at
BEFORE UPDATE ON public.templates
FOR EACH ROW
EXECUTE FUNCTION public.update_templates_updated_at();
--- ConteÃºdo de: supabase/migrations/20251013211718_7199223e-79f3-455d-a284-7d422ac46b51.sql ---
-- Criar tabela de configuraÃ§Ãµes de webhooks
CREATE TABLE public.webhook_configs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  type TEXT NOT NULL,
  url TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(user_id, type)
);

-- Habilitar RLS
ALTER TABLE public.webhook_configs ENABLE ROW LEVEL SECURITY;

-- PolÃ­ticas RLS para webhook_configs
CREATE POLICY "Users can view their own webhook configs"
  ON public.webhook_configs FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own webhook configs"
  ON public.webhook_configs FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own webhook configs"
  ON public.webhook_configs FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own webhook configs"
  ON public.webhook_configs FOR DELETE
  USING (auth.uid() = user_id);

-- Criar tabela de histÃ³rico de webhooks
CREATE TABLE public.webhook_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  webhook_type TEXT NOT NULL,
  payload JSONB NOT NULL,
  status_code INTEGER,
  timestamp TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Habilitar RLS
ALTER TABLE public.webhook_history ENABLE ROW LEVEL SECURITY;

-- PolÃ­ticas RLS para webhook_history
CREATE POLICY "Users can view their own webhook history"
  ON public.webhook_history FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own webhook history"
  ON public.webhook_history FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Trigger para atualizar updated_at em webhook_configs
CREATE TRIGGER update_webhook_configs_updated_at
  BEFORE UPDATE ON public.webhook_configs
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

-- Criar tabela de status de conexÃ£o
CREATE TABLE public.connection_status (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  instance_name TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'disconnected',
  qr_code_base64 TEXT,
  last_updated TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(user_id, instance_name)
);

-- Habilitar RLS
ALTER TABLE public.connection_status ENABLE ROW LEVEL SECURITY;

-- PolÃ­ticas RLS para connection_status
CREATE POLICY "Users can view their own connection status"
  ON public.connection_status FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own connection status"
  ON public.connection_status FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own connection status"
  ON public.connection_status FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own connection status"
  ON public.connection_status FOR DELETE
  USING (auth.uid() = user_id);

-- Habilitar Realtime para connection_status
ALTER PUBLICATION supabase_realtime ADD TABLE public.connection_status;
--- ConteÃºdo de: supabase/migrations/20251013221600_fix_client_status_timezone.sql ---
-- Fix client status timezone issue in set_client_status_based_on_due_date function

CREATE OR REPLACE FUNCTION public.set_client_status_based_on_due_date()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    local_current_date DATE;
BEGIN
  -- Get the current date in the 'America/Sao_Paulo' timezone
  -- This ensures consistency with the application's expected "today"
  local_current_date := (NOW() AT TIME ZONE 'America/Sao_Paulo')::DATE;

  -- Verifica se o status atual nÃ£o Ã© 'inativo'. NÃ£o queremos reativar um cliente cancelado automaticamente.
  IF NEW.status != 'inactive' THEN
    -- Se a data de vencimento for anterior a hoje (na timezone local), define o status como 'overdue'.
    IF NEW.next_billing_date < local_current_date THEN
      NEW.status := 'overdue';
    -- Caso contrÃ¡rio, define o status como 'ativo'.
    ELSE
      NEW.status := 'active';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$function$;
--- ConteÃºdo de: supabase/migrations/20251016013741_aaf8b971-c037-421b-affa-f8e6241f5cd4.sql ---
-- Habilitar extensÃµes necessÃ¡rias para cron jobs
CREATE EXTENSION IF NOT EXISTS pg_cron;
CREATE EXTENSION IF NOT EXISTS pg_net;

-- Configurar cron job para processar fila de notificaÃ§Ãµes a cada minuto
SELECT cron.schedule(
  'process-notification-queue',
  '* * * * *', -- Executa a cada minuto
  $$
  SELECT net.http_post(
    url := 'https://cgqyfpsfymhntumrmbzj.supabase.co/functions/v1/process-queue-and-send',
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || current_setting('app.settings.cron_secret')
    ),
    body := jsonb_build_object('trigger', 'cron', 'time', now())
  ) as request_id;
  $$
);
--- ConteÃºdo de: supabase/migrations/20251016013854_c4128d56-0d29-430f-bf1b-44046107633e.sql ---
-- Habilitar extensÃµes necessÃ¡rias para cron jobs
CREATE EXTENSION IF NOT EXISTS pg_cron;
CREATE EXTENSION IF NOT EXISTS pg_net;

-- Configurar cron job para processar fila de notificaÃ§Ãµes a cada minuto
SELECT cron.schedule(
  'process-notification-queue',
  '* * * * *', -- Executa a cada minuto
  $$
  SELECT net.http_post(
    url := 'https://cgqyfpsfymhntumrmbzj.supabase.co/functions/v1/process-queue-and-send',
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || current_setting('app.settings.cron_secret')
    ),
    body := jsonb_build_object('trigger', 'cron', 'time', now())
  ) as request_id;
  $$
);
--- ConteÃºdo de: supabase/migrations/20251016020954_ea957f25-cd1a-4bb0-9173-0437ada06f90.sql ---
-- Remove o cron job PostgreSQL que estÃ¡ causando os erros
-- Este job estava tentando usar current_setting('app.settings.cron_secret') que nÃ£o existe
SELECT cron.unschedule(1);
--- ConteÃºdo de: supabase/migrations/20251016022304_57e7bf3f-2807-4368-ad7d-e46877539e06.sql ---
-- Ensure pg_cron schedules our Edge Function every minute using Vault secret
-- Safely remove any existing job with the same name
DO $$
BEGIN
  PERFORM cron.unschedule('process-queue-and-send-every-minute');
EXCEPTION WHEN OTHERS THEN
  -- ignore if it doesn't exist
  NULL;
END;
$$;

-- Schedule the process-queue-and-send function to run every minute
SELECT
  cron.schedule(
    'process-queue-and-send-every-minute',
    '* * * * *',
    $$
    SELECT
      net.http_post(
        url := 'https://cgqyfpsfymhntumrmbzj.supabase.co/functions/v1/process-queue-and-send',
        headers := jsonb_build_object(
          'Content-Type','application/json',
          'Authorization','Bearer ' || (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE name = 'CRON_SECRET')
        ),
        body := jsonb_build_object('trigger','supabase-cron')
      ) AS request_id;
    $$
  );
======================================
  EXTRA: CONTEÃDO DAS EDGE FUNCTIONS, PÃGINAS E HOOKS
======================================

--- ConteÃºdo de: supabase/functions/admin-financial-analysis/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Interfaces para tipagem dos dados do Supabase
interface AdminFinancialEntry {
  value: number;
  created_at: string;
}

interface SubscriptionData {
  user_id: string;
  price: number;
  next_billing_date: string;
  created_at: string;
  status: string;
  plan_name: string; // Adicionado plan_name
}

interface ProfileData {
  id: string;
  created_at: string;
}

interface SubscriberPlanData {
  id: string;
  name: string;
  value: number;
  is_free: boolean;
}

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const now = new Date();
    const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
    const monthEnd = new Date(now.getFullYear(), now.getMonth() + 1, 1);

    // --- Fetch all subscriber plans and create a map (NEW) ---
    const { data: subscriberPlansData, error: subscriberPlansError } = await supabaseAdmin
      .from('subscriber_plans')
      .select('id, name, value, is_free');

    if (subscriberPlansError) throw subscriberPlansError;
    const subscriberPlansMap = new Map<string, SubscriberPlanData>(
      (subscriberPlansData || []).map((plan: SubscriberPlanData) => [plan.name, plan])
    );
    console.log('Edge Function: Subscriber plans fetched and mapped.');

    // --- Valores Recebidos (admin_financial_entries) ---
    const { data: adminFinancialEntries, error: financialError } = await supabaseAdmin
      .from('admin_financial_entries')
      .select('value, created_at')
      .eq('type', 'credit');

    if (financialError) throw financialError;
    console.log('Edge Function: adminFinancialEntries fetched, count:', adminFinancialEntries?.length || 0);

    let receivedThisMonth = 0; // Para currentMonthRevenue
    let receivedPreviousMonth = 0; // Para previousMonthRevenue

    const previousMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
    const previousMonthEnd = new Date(now.getFullYear(), now.getMonth(), 1);

    (adminFinancialEntries as AdminFinancialEntry[] || []).forEach((entry: AdminFinancialEntry) => {
      const entryDate = new Date(entry.created_at);
      if (entryDate >= monthStart && entryDate < monthEnd) {
        receivedThisMonth += entry.value;
      } else if (entryDate >= previousMonthStart && entryDate < previousMonthEnd) {
        receivedPreviousMonth += entry.value;
      }
    });

    // --- Dados de Assinaturas (subscriptions) e Perfis (profiles) ---
    const { data: subscriptions, error: subscriptionsError } = await supabaseAdmin
      .from('subscriptions')
      .select('user_id, price, next_billing_date, created_at, status, plan_name'); // Adicionado plan_name

    if (subscriptionsError) throw subscriptionsError;
    console.log('Edge Function: subscriptions fetched, count:', subscriptions?.length || 0);

    const { data: profiles, error: profilesError } = await supabaseAdmin
      .from('profiles')
      .select('id, created_at');

    if (profilesError) throw profilesError;
    console.log('Edge Function: profiles fetched, count:', profiles?.length || 0);

    let newSubscribersThisMonth = 0;
    let activeSubscribers = 0;
    let revenueForecast = 0; // Baseado em assinaturas ativas para o mÃªs atual

    const subscriberCreationMonthStart = new Date(now.getFullYear(), now.getMonth(), 1);
    const subscriberCreationMonthEnd = new Date(now.getFullYear(), now.getMonth() + 1, 1);

    const activeSubscriberIds = new Set<string>();

    (subscriptions as SubscriptionData[] || []).forEach((sub: SubscriptionData) => {
      const subCreationDate = new Date(sub.created_at);
      if (subCreationDate >= subscriberCreationMonthStart && subCreationDate < subscriberCreationMonthEnd) {
        // Check if the user associated with this subscription is actually new this month
        const profileCreatedThisMonth = (profiles as ProfileData[] || []).some(p => 
          p.id === sub.user_id && new Date(p.created_at) >= subscriberCreationMonthStart && new Date(p.created_at) < subscriberCreationMonthEnd
        );
        if (profileCreatedThisMonth) {
          newSubscribersThisMonth++;
        }
      }
      if (sub.status === 'active') {
        activeSubscriberIds.add(sub.user_id); // Count unique active subscribers
        if (sub.next_billing_date) {
          const dueDate = new Date(sub.next_billing_date + 'T00:00:00'); // Tratar como data local
          if (dueDate >= monthStart && dueDate < monthEnd) {
            revenueForecast += sub.price;
          }
        }
      }
    });
    activeSubscribers = activeSubscriberIds.size;

    // --- KPIs Calculation ---
    const currentMonthRevenue = receivedThisMonth;
    const previousMonthRevenue = receivedPreviousMonth;

    const monthlyGrowthPercentage = previousMonthRevenue > 0
      ? ((currentMonthRevenue / previousMonthRevenue) - 1) * 100
      : (currentMonthRevenue > 0 ? 100 : 0);

    const kpis = {
      currentMonthRevenue,
      previousMonthRevenue,
      monthlyGrowthPercentage,
      newSubscribersThisMonth: newSubscribersThisMonth, // Renomeado
      activeSubscribers: activeSubscribers, // Renomeado
      revenueForecast: currentMonthRevenue + revenueForecast, // Total de receita do mÃªs + previsÃ£o de recebÃ­veis
    };

    // --- Churn Analysis Calculation ---
    const { data: churnedSubscriptionsData, error: churnedSubscriptionsError } = await supabaseAdmin
      .from('subscriptions')
      .select(`
        user_id,
        price,
        plan_name
      `) // Selecionar plan_name diretamente
      .in('status', ['inactive', 'overdue'])
      .gte('next_billing_date', monthStart.toISOString().split('T')[0])
      .lte('next_billing_date', new Date(monthEnd.getTime() - 1).toISOString().split('T')[0]);

    if (churnedSubscriptionsError) throw churnedSubscriptionsError;

    let lostSubscribersThisMonth = 0;
    let lostRevenueThisMonth = 0;
    const churnByPlanMap = new Map<string, { planName: string; lostCount: number }>();

    (churnedSubscriptionsData || []).forEach((sub: any) => { // sub agora tem plan_name
      const planDetails = subscriberPlansMap.get(sub.plan_name); // Usar o mapa
      const planName = planDetails?.name || sub.plan_name || 'Plano Desconhecido';
      const subPrice = sub.price || 0;

      if (!churnByPlanMap.has(planName)) {
        churnByPlanMap.set(planName, { planName, lostCount: 0 });
      }
      churnByPlanMap.get(planName)!.lostCount++;

      lostSubscribersThisMonth++;
      lostRevenueThisMonth += subPrice;
    });

    const churnByPlan = Array.from(churnByPlanMap.values()).sort((a, b) => b.lostCount - a.lostCount);

    const totalSubscribersForChurn = activeSubscribers + lostSubscribersThisMonth;
    const churnRate = totalSubscribersForChurn > 0
      ? (lostSubscribersThisMonth / totalSubscribersForChurn) * 100
      : 0;

    const churnAnalysis = {
      lostSubscribersThisMonth,
      lostRevenueThisMonth,
      churnRate,
      churnByPlan,
    };

    // --- Revenue Last 30 Days (from admin_financial_entries) ---
    const revenueLast30DaysMap = new Map<string, number>();
    const thirtyDaysAgo = new Date(now);
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 29);
    
    for (let d = new Date(thirtyDaysAgo); d <= now; d.setDate(d.getDate() + 1)) {
      const dateStr = d.toISOString().split('T')[0];
      revenueLast30DaysMap.set(dateStr, 0);
    }

    (adminFinancialEntries as AdminFinancialEntry[] || []).forEach((entry: AdminFinancialEntry) => {
      const entryDate = new Date(entry.created_at);
      const entryDateStr = entryDate.toISOString().split('T')[0];
      if (revenueLast30DaysMap.has(entryDateStr)) {
        revenueLast30DaysMap.set(entryDateStr, revenueLast30DaysMap.get(entryDateStr)! + entry.value);
      }
    });

    // --- Weekly Revenue Comparison (from admin_financial_entries) ---
    const weeklyRevenueComparison: { [key: string]: { currentMonth: number; previousMonth: number } } = {};

    const getWeekNumber = (date: Date) => {
      const startOfYear = new Date(date.getFullYear(), 0, 1);
      const diff = date.getTime() - startOfYear.getTime();
      return Math.ceil(diff / (1000 * 60 * 60 * 24 * 7));
    };

    const processWeeklyRevenue = (entries: AdminFinancialEntry[] | null, monthStart: Date, monthEnd: Date, targetObject: any, monthKey: 'currentMonth' | 'previousMonth') => {
      const monthEntries = (entries || []).filter((entry: AdminFinancialEntry) => {
        const entryDate = new Date(entry.created_at);
        return entryDate >= monthStart && entryDate < monthEnd;
      });

      monthEntries.forEach((entry: AdminFinancialEntry) => {
        const entryDate = new Date(entry.created_at);
        const weekNum = getWeekNumber(entryDate);
        const weekKey = `week${weekNum}`;

        if (!targetObject[weekKey]) {
          targetObject[weekKey] = { currentMonth: 0, previousMonth: 0 };
        }
        targetObject[weekKey][monthKey] += entry.value;
      });
    };

    processWeeklyRevenue(adminFinancialEntries, monthStart, monthEnd, weeklyRevenueComparison, 'currentMonth');
    processWeeklyRevenue(adminFinancialEntries, previousMonthStart, previousMonthEnd, weeklyRevenueComparison, 'previousMonth');

    const allWeekKeys = new Set<string>();
    Object.keys(weeklyRevenueComparison).forEach(key => allWeekKeys.add(key));
    for (const key of allWeekKeys) {
      if (!weeklyRevenueComparison[key].currentMonth) weeklyRevenueComparison[key].currentMonth = 0;
      if (!weeklyRevenueComparison[key].previousMonth) weeklyRevenueComparison[key].previousMonth = 0;
    }

    // --- Revenue by Subscriber Plan (Current Month) ---
    const revenueByPlanData: { planName: string; totalRevenue: number }[] = [];
    const tempRevenueByPlan = new Map<string, number>();

    (subscriptions as SubscriptionData[] || []).forEach((sub: SubscriptionData) => {
      if (sub.status === 'active' && sub.next_billing_date) {
        const dueDate = new Date(sub.next_billing_date + 'T00:00:00'); // Tratar como data local
        if (dueDate >= monthStart && dueDate < monthEnd) {
          // Find the plan name from subscriber_plans based on subscription's plan_name (string)
          // This assumes subscription.plan_name directly matches subscriber_plans.name
          const planDetails = subscriberPlansMap.get(sub.plan_name); // Usar o mapa
          const planName = planDetails?.name || sub.plan_name || 'Plano Desconhecido';
          tempRevenueByPlan.set(planName, (tempRevenueByPlan.get(planName) || 0) + sub.price);
        }
      }
    });

    tempRevenueByPlan.forEach((totalRevenue, planName) => {
      revenueByPlanData.push({ planName, totalRevenue });
    });

    // --- Monthly Revenue History (Last 12 Months from admin_financial_entries) ---
    const twelveMonthsAgo = new Date(now);
    twelveMonthsAgo.setMonth(twelveMonthsAgo.getMonth() - 11);
    const twelveMonthsAgoStart = new Date(twelveMonthsAgo.getFullYear(), twelveMonthsAgo.getMonth(), 1);
    const currentMonthEnd = new Date(now.getFullYear(), now.getMonth() + 1, 1);

    const { data: monthlyEntriesHistory, error: monthlyEntriesHistoryError } = await supabaseAdmin
      .from('admin_financial_entries')
      .select('value, created_at')
      .eq('type', 'credit')
      .gte('created_at', twelveMonthsAgoStart.toISOString())
      .lte('created_at', currentMonthEnd.toISOString());

    if (monthlyEntriesHistoryError) throw monthlyEntriesHistoryError;
    console.log('Edge Function: monthlyEntriesHistory fetched, count:', monthlyEntriesHistory?.length || 0);

    const monthlyRevenueHistoryMap = new Map<string, number>();
    (monthlyEntriesHistory as AdminFinancialEntry[] || []).forEach((entry: AdminFinancialEntry) => {
      const entryDate = new Date(entry.created_at);
      const monthKey = `${entryDate.getFullYear()}-${String(entryDate.getMonth() + 1).padStart(2, '0')}`;
      monthlyRevenueHistoryMap.set(monthKey, (monthlyRevenueHistoryMap.get(monthKey) || 0) + entry.value);
    });

    const monthlyRevenueHistory: { month: string; revenue: number }[] = [];
    const months = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
    let currentMonthIterator = new Date(twelveMonthsAgoStart);
    while (currentMonthIterator < currentMonthEnd) {
      const monthKey = `${currentMonthIterator.getFullYear()}-${String(currentMonthIterator.getMonth() + 1).padStart(2, '0')}`;
      const monthLabel = `${months[currentMonthIterator.getMonth()]}/${String(currentMonthIterator.getFullYear()).slice(2)}`;
      monthlyRevenueHistory.push({
        month: monthLabel,
        revenue: monthlyRevenueHistoryMap.get(monthKey) || 0,
      });
      currentMonthIterator.setMonth(currentMonthIterator.getMonth() + 1);
    }

    console.log('Edge Function: Admin financial analysis data prepared successfully.');

    return new Response(
      JSON.stringify({
        kpis,
        revenueLast30Days: Array.from(revenueLast30DaysMap.entries()).map(([date, revenue]) => ({ date, revenue })),
        weeklyRevenueComparison,
        revenueByPlan: revenueByPlanData,
        churnAnalysis,
        monthlyRevenueHistory,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error: any) {
    console.error('Edge Function: Error fetching admin financial analysis:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred in the admin financial analysis function.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/admin-financial-entries/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const { method } = req;
    const url = new URL(req.url);
    const id = url.searchParams.get('id'); // For GET (single), PUT, DELETE

    switch (method) {
      case 'GET': {
        if (id) {
          const { data, error } = await supabaseAdmin
            .from('admin_financial_entries')
            .select('*')
            .eq('id', id)
            .single();
          if (error) throw error;
          return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        } else {
          const { data, error } = await supabaseAdmin
            .from('admin_financial_entries')
            .select('*')
            .order('created_at', { ascending: false });
          if (error) throw error;
          return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
      }
      case 'POST': {
        const body = await req.json();
        const { description, value, type, subscriber_id } = body;
        if (!description || !value || !type || !subscriber_id) {
          return new Response(JSON.stringify({ error: 'Missing required fields: description, value, type, subscriber_id' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        const { data, error } = await supabaseAdmin
          .from('admin_financial_entries')
          .insert({ admin_user_id: user.id, description, value, type, subscriber_id })
          .select()
          .single();
        if (error) throw error;
        return new Response(JSON.stringify(data), { status: 201, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      case 'PUT': {
        if (!id) {
          return new Response(JSON.stringify({ error: 'Missing ID for update' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        const body = await req.json();
        const { description, value, type, subscriber_id } = body;
        const updateData: any = {};
        if (description !== undefined) updateData.description = description;
        if (value !== undefined) updateData.value = value;
        if (type !== undefined) updateData.type = type;
        if (subscriber_id !== undefined) updateData.subscriber_id = subscriber_id;

        const { data, error } = await supabaseAdmin
          .from('admin_financial_entries')
          .update(updateData)
          .eq('id', id)
          .select()
          .single();
        if (error) throw error;
        return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      case 'DELETE': {
        if (!id) {
          return new Response(JSON.stringify({ error: 'Missing ID for delete' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        const { error } = await supabaseAdmin
          .from('admin_financial_entries')
          .delete()
          .eq('id', id);
        if (error) throw error;
        return new Response(JSON.stringify({ message: 'Entry deleted successfully.' }), { status: 204, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      default:
        return new Response('Method Not Allowed', { status: 405, headers: corsHeaders });
    }
  } catch (error: any) {
    console.error('Edge Function: Error in admin-financial-entries:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/admin-financial-summary/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

// @ts-ignore
import { DateTime } from 'https://esm.sh/luxon@3.4.4'; // Use Luxon

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Interfaces para tipagem dos dados do Supabase
interface AdminFinancialEntry {
  value: number;
  created_at: string;
}

interface SubscriptionSummary {
  price: number;
  next_billing_date: string;
  status: string;
}

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const now = DateTime.local(); // Current local time
    const todayStart = now.startOf('day');
    const todayEnd = now.plus({ days: 1 }).startOf('day'); // Exclusive end: start of tomorrow

    // Luxon's startOf('week') defaults to Monday. To match date-fns weekStartsOn: 0 (Sunday),
    // we need to set locale or explicitly adjust. 'en-US' starts on Sunday.
    const weekStart = now.setLocale('en-US').startOf('week');
    const weekEnd = weekStart.plus({ weeks: 1 }).startOf('day'); // Exclusive end: start of next week

    const monthStart = now.startOf('month');
    const monthEnd = monthStart.plus({ months: 1 }).startOf('day'); // Exclusive end: start of next month

    // --- Valores Recebidos (admin_financial_entries) ---
    const { data: adminFinancialEntries, error: financialError } = await supabaseAdmin
      .from('admin_financial_entries')
      .select('value, created_at')
      .eq('type', 'credit');

    if (financialError) throw financialError;
    console.log('Edge Function: adminFinancialEntries fetched, count:', adminFinancialEntries?.length || 0);

    let receivedToday = 0;
    let receivedThisWeek = 0;
    let receivedThisMonth = 0;

    (adminFinancialEntries as AdminFinancialEntry[] || []).forEach((entry: AdminFinancialEntry) => {
      const entryDateTime = DateTime.fromISO(entry.created_at, { zone: 'utc' }).toLocal(); // Convert to local for comparison
      if (entryDateTime >= todayStart && entryDateTime < todayEnd) {
        receivedToday += entry.value;
      }
      if (entryDateTime >= weekStart && entryDateTime < weekEnd) {
        receivedThisWeek += entry.value;
      }
      if (entryDateTime >= monthStart && entryDateTime < monthEnd) {
        receivedThisMonth += entry.value;
      }
    });

    // --- PrevisÃ£o de RecebÃ­veis (subscriptions) ---
    const { data: subscriptions, error: subscriptionsError } = await supabaseAdmin
      .from('subscriptions')
      .select('price, next_billing_date, status')
      .eq('status', 'active'); // Apenas assinaturas ativas geram recebÃ­veis

    if (subscriptionsError) throw subscriptionsError;
    console.log('Edge Function: subscriptions fetched, count:', subscriptions?.length || 0);

    let receivableToday = 0;
    let receivableTomorrow = 0;
    let receivableThisWeek = 0;
    let receivableThisMonth = 0;

    const tomorrowStart = now.plus({ days: 1 }).startOf('day');
    const tomorrowEnd = now.plus({ days: 2 }).startOf('day'); // Exclusive end: start of day after tomorrow

    (subscriptions as SubscriptionSummary[] || []).forEach((sub: SubscriptionSummary) => {
      if (!sub.next_billing_date) return;
      const dueDate = DateTime.fromISO(sub.next_billing_date, { zone: 'local' }).startOf('day'); // Treat as local date, start of day

      if (dueDate >= todayStart && dueDate < todayEnd) {
        receivableToday += sub.price;
      }
      if (dueDate >= tomorrowStart && dueDate < tomorrowEnd) {
        receivableTomorrow += sub.price;
      }
      if (dueDate >= weekStart && dueDate < weekEnd) {
        receivableThisWeek += sub.price;
      }
      if (dueDate >= monthStart && dueDate < monthEnd) {
        receivableThisMonth += sub.price;
      }
    });

    // --- Valores Perdidos (Churn de Assinantes) ---
    // For direct Supabase queries, we need YYYY-MM-DD strings.
    // Use Luxon's toISODate() for this.
    const { data: churnedSubscriptionsToday, error: churnedTodayError } = await supabaseAdmin
      .from('subscriptions')
      .select('price')
      .in('status', ['inactive', 'overdue'])
      .gte('next_billing_date', todayStart.toISODate())
      .lt('next_billing_date', todayEnd.toISODate()); // Use lt for exclusive end
    if (churnedTodayError) throw churnedTodayError;
    const lostValueToday = (churnedSubscriptionsToday as { price: number }[] || []).reduce((sum: number, sub: { price: number }) => sum + sub.price, 0);
    console.log('Edge Function: lostValueToday calculated:', lostValueToday);

    const { data: churnedSubscriptionsThisWeek, error: churnedThisWeekError } = await supabaseAdmin
      .from('subscriptions')
      .select('price')
      .in('status', ['inactive', 'overdue'])
      .gte('next_billing_date', weekStart.toISODate())
      .lt('next_billing_date', weekEnd.toISODate()); // Use lt for exclusive end
    if (churnedThisWeekError) throw churnedThisWeekError;
    const lostValueThisWeek = (churnedSubscriptionsThisWeek as { price: number }[] || []).reduce((sum: number, sub: { price: number }) => sum + sub.price, 0);
    console.log('Edge Function: lostValueThisWeek calculated:', lostValueThisWeek);

    const { data: churnedSubscriptionsThisMonth, error: churnedThisMonthError } = await supabaseAdmin
      .from('subscriptions')
      .select('price')
      .in('status', ['inactive', 'overdue'])
      .gte('next_billing_date', monthStart.toISODate())
      .lt('next_billing_date', monthEnd.toISODate()); // Use lt for exclusive end
    if (churnedThisMonthError) throw churnedThisMonthError;
    const lostValueThisMonth = (churnedSubscriptionsThisMonth as { price: number }[] || []).reduce((sum: number, sub: { price: number }) => sum + sub.price, 0);
    console.log('Edge Function: lostValueThisMonth calculated:', lostValueThisMonth);


    console.log('Edge Function: Admin financial summary data prepared successfully.');

    return new Response(
      JSON.stringify({
        receivedToday,
        receivedThisWeek,
        receivedThisMonth,
        receivableToday,
        receivableTomorrow,
        receivableThisWeek,
        receivableThisMonth,
        lostValueToday,
        lostValueThisWeek,
        lostValueThisMonth,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error: any) {
    console.error('Edge Function: Error fetching admin financial summary:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred in the financial summary function.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/apply-schema-migration/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';
// @ts-ignore
import { Client } from "https://deno.land/x/postgres@v0.17.0/mod.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    console.log('apply-schema-migration: Starting schema migration...');

    // Connect directly to PostgreSQL to execute DDL
    const client = new Client({
      // @ts-ignore
      hostname: Deno.env.get('SUPABASE_DB_HOST') ?? '',
      // @ts-ignore
      port: parseInt(Deno.env.get('SUPABASE_DB_PORT') ?? '5432'),
      // @ts-ignore
      user: 'postgres',
      // @ts-ignore
      password: Deno.env.get('SUPABASE_DB_PASSWORD') ?? '',
      database: 'postgres',
    });

    await client.connect();

    // Add column if it doesn't exist
    await client.queryArray(`
      DO $$ 
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM information_schema.columns 
          WHERE table_name = 'webhook_history' 
          AND column_name = 'client_name_snapshot'
        ) THEN
          ALTER TABLE webhook_history ADD COLUMN client_name_snapshot TEXT;
          CREATE INDEX idx_webhook_history_client_name_snapshot ON webhook_history(client_name_snapshot);
          COMMENT ON COLUMN webhook_history.client_name_snapshot IS 'Snapshot of the client name at the time of the webhook call. Used to preserve history even if client is deleted.';
        END IF;
      END $$;
    `);

    await client.end();

    console.log('apply-schema-migration: Schema migration completed');

    // Now populate existing records using Supabase client
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    // This function is called by useDashboardStats, which is user-authenticated.
    // We need to get the user from the request to filter the population.
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      // If no auth header, this is likely a direct invocation without user context.
      // For migration, we might want to process all, but for data population, it should be user-specific.
      // For now, we'll skip population if no user context.
      console.warn('apply-schema-migration: No Authorization header found. Skipping data population for specific user.');
      return new Response(
        JSON.stringify({
          success: true,
          message: 'Schema migration completed. Data population skipped due to missing user context.',
          recordsUpdated: 0
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 200,
        }
      );
    }

    const token = authHeader.replace('Bearer ', '');
    const supabaseUserClient = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabaseUserClient.auth.getUser();
    if (userError || !user) {
      console.error('apply-schema-migration: User authentication failed for data population:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated for data population' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    const userId = user.id;

    // Fetch user role
    const { data: userRoleData, error: userRoleError } = await supabaseUserClient
      .from('user_roles')
      .select('role')
      .eq('user_id', userId)
      .single();

    if (userRoleError && userRoleError.code !== 'PGRST116') {
      console.error('apply-schema-migration: Error fetching user role for data population:', userRoleError.message);
      throw userRoleError;
    }
    const userRole = userRoleData?.role || 'user';

    let historyRecordsQuery = supabaseAdmin
      .from('webhook_history')
      .select('id, client_id, clients(name)')
      .is('client_name_snapshot', null)
      .not('client_id', 'is', null);

    // Apply user_id filter for non-admin users during data population
    if (userRole !== 'admin') {
      historyRecordsQuery = historyRecordsQuery.eq('user_id', userId);
    }

    const { data: historyRecords } = await historyRecordsQuery;

    let updatedCount = 0;
    if (historyRecords && historyRecords.length > 0) {
      for (const record of historyRecords) {
        const client = Array.isArray(record.clients) ? record.clients[0] : record.clients;
        if (client?.name) {
          await supabaseAdmin
            .from('webhook_history')
            .update({ client_name_snapshot: client.name })
            .eq('id', record.id);
          updatedCount++;
        }
      }
    }

    return new Response(
      JSON.stringify({
        success: true,
        message: 'Schema migration and data population completed',
        recordsUpdated: updatedCount
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );

  } catch (error: any) {
    console.error('apply-schema-migration: Error:', error.message);
    return new Response(
      JSON.stringify({ error: error.message }),
      {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      }
    );
  }
});
--- ConteÃºdo de: supabase/functions/connection-metrics/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

// @ts-ignore
import * as dateFns from 'npm:date-fns@3.6.0'; // Use npm: for date-fns
// @ts-ignore
import { toZonedTime } from 'npm:date-fns-tz@3.2.0'; // Updated to v3 - renamed from utcToZonedTime

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Define interfaces for detailed history items
interface DetailedHistoryItem {
  id: string;
  clientName: string;
  templateName: string;
  eventDate: string; // This will be send_at or sent_at
  status: 'pending' | 'success' | 'failed';
  errorMessage?: string | null;
  requestPayload?: any | null; // Adicionado
  responsePayload?: any | null; // Adicionado
}

// Interfaces for raw data from Supabase queries
interface ScheduledNotificationRow {
  id: string;
  send_at: string;
  status: 'pending';
  clients: { name: string } | null;
  templates: { name: string } | null;
}

interface N8nMessageSenderHistoryRow { // Renomeado para refletir a nova tabela
  id: string;
  timestamp: string; 
  status_code: number | null; 
  webhook_type: string; 
  clients: { name: string } | null;
  templates: { name: string } | null;
  error_message?: string | null; 
  request_payload?: any | null; 
  response_payload?: any | null; 
  client_name_snapshot?: string | null; // Added for deleted clients
}

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    const userId = user.id;
    const url = new URL(req.url);
    const statusFilter = url.searchParams.get('status'); // Get the status query parameter

    // Fetch user role
    const { data: userRoleData, error: userRoleError } = await supabase
      .from('user_roles')
      .select('role')
      .eq('user_id', userId)
      .single();

    if (userRoleError && userRoleError.code !== 'PGRST116') { // PGRST116 = No rows found
      console.error('Edge Function: Error fetching user role:', userRoleError.message);
      throw userRoleError;
    }
    const userRole = userRoleData?.role || 'user'; // Default to 'user' if no role found

    // Conditionally apply user_id filter
    const applyUserIdFilter = (query: any) => {
      return userRole === 'admin' ? query : query.eq('user_id', userId);
    };

    // --- Detailed List Logic ---
    if (statusFilter === 'pending' || statusFilter === 'success' || statusFilter === 'failed') {
      let detailedData: DetailedHistoryItem[] = [];
      let query;

      if (statusFilter === 'pending') {
        query = applyUserIdFilter(
          supabase
            .from('scheduled_notifications')
            .select(`
              id,
              send_at,
              status,
              clients(name),
              templates(name)
            `)
        )
          .eq('status', 'pending')
          .order('send_at', { ascending: false });
      } else { // 'success' or 'failed'
        query = applyUserIdFilter(
          supabase
            .from('n8n_message_sender_history') // Alterado para n8n_message_sender_history
            .select(`
              id,
              timestamp,
              status_code,
              webhook_type,
              request_payload,
              response_payload,
              client_name_snapshot,
              clients:clients(name),
              templates:templates(name)
            `)
        )
          .in('webhook_type', ['n8n_message_outbound', 'n8n_message_outbound_automated']) // Filtrar por tipos de webhook de mensagem
          .order('timestamp', { ascending: false });
          
          if (statusFilter === 'success') {
            query = query.eq('status_code', 200);
          } else if (statusFilter === 'failed') {
            query = query.or('status_code.neq.200,status_code.is.null'); // MODIFICADO: Incluir status_code nulo como falha
          }
      }

      const { data, error: detailedError } = await query;

      if (detailedError) throw detailedError;

      detailedData = (data || []).map((item: any) => { // Usar 'any' temporariamente para flexibilidade
        if (statusFilter === 'pending') {
          const scheduledItem = item as ScheduledNotificationRow;
          return {
            id: scheduledItem.id,
            clientName: scheduledItem.clients?.name || 'Cliente Desconhecido',
            templateName: scheduledItem.templates?.name || 'Template Desconhecido',
            eventDate: scheduledItem.send_at,
            status: scheduledItem.status,
          };
        } else {
          const historyItem = item as N8nMessageSenderHistoryRow; // Usar o novo tipo
          // Use snapshot if client is deleted, otherwise use current client name
          const clientName = historyItem.clients?.name 
            ? historyItem.clients.name 
            : historyItem.client_name_snapshot 
              ? `${historyItem.client_name_snapshot} (Deletado)` 
              : 'Cliente Desconhecido';
          
          return {
            id: historyItem.id,
            clientName,
            templateName: historyItem.templates?.name || 'Template Desconhecido',
            eventDate: historyItem.timestamp, // Usar timestamp do webhook_history
            status: historyItem.status_code && historyItem.status_code >= 200 && historyItem.status_code < 300 ? 'success' : 'failed', // Mapear status_code para 'success'/'failed'
            requestPayload: historyItem.request_payload,
            responsePayload: historyItem.response_payload,
          };
        }
      });

      return new Response(JSON.stringify({ detailedData }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      });
    }

    // --- Existing Metrics and Recent History Logic (if no statusFilter) ---
    // Agendados: Contagem de scheduled_notifications com status 'pending'
    const { count: scheduledCount, error: scheduledError } = await applyUserIdFilter(
      supabase
        .from('scheduled_notifications')
        .select('*', { count: 'exact', head: true })
    )
      .eq('status', 'pending');

    if (scheduledError) throw scheduledError;

    // Enviados: Contagem de n8n_message_sender_history com status_code 200
    const { count: sentCount, error: sentError } = await applyUserIdFilter(
      supabase
        .from('n8n_message_sender_history') // Alterado para n8n_message_sender_history
        .select('*', { count: 'exact', head: true })
    )
      .in('webhook_type', ['n8n_message_outbound', 'n8n_message_outbound_automated']) // Incluir ambos os tipos
      .eq('status_code', 200);

    if (sentError) throw sentError;

    // Falhas: Contagem de n8n_message_sender_history com status_code diferente de 200 OU status_code Ã© NULL
    const { count: failedCount, error: failedError } = await applyUserIdFilter(
      supabase
        .from('n8n_message_sender_history') // Alterado para n8n_message_sender_history
        .select('*', { count: 'exact', head: true })
    )
      .in('webhook_type', ['n8n_message_outbound', 'n8n_message_outbound_automated']) // Incluir ambos os tipos
      .or('status_code.neq.200,status_code.is.null'); // MODIFICADO: Incluir status_code nulo como falha

    if (failedError) throw failedError;

    // HistÃ³rico de Envios (recentes, para o dashboard principal)
    const { data: historyData, error: historyError } = await applyUserIdFilter(
      supabase
        .from('n8n_message_sender_history') // Alterado para n8n_message_sender_history
        .select(`
          id,
          timestamp,
          status_code,
          client_name_snapshot,
          clients:clients(name),
          templates:templates(name)
        `)
    )
      .in('webhook_type', ['n8n_message_outbound', 'n8n_message_outbound_automated']) // Incluir ambos os tipos
      .order('timestamp', { ascending: false })
      .limit(10);

    if (historyError) throw historyError;

    const formattedHistory = (historyData || []).map((item: any) => {
      // Use snapshot if client is deleted, otherwise use current client name
      const clientName = item.clients?.name 
        ? item.clients.name 
        : item.client_name_snapshot 
          ? `${item.client_name_snapshot} (Deletado)` 
          : 'Cliente Desconhecido';
      
      return {
        id: item.id,
        clientName,
        templateName: item.templates?.name || 'Template Desconhecido',
        sentDate: new Date(item.timestamp).toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit' }),
        status: item.status_code && item.status_code >= 200 && item.status_code < 300 ? 'success' : 'failed',
      };
    });

    const responsePayload = {
      metrics: {
        sent: sentCount || 0,
        scheduled: scheduledCount || 0,
        failed: failedCount || 0,
      },
      history: formattedHistory,
    };

    return new Response(JSON.stringify(responsePayload), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (error: any) {
    console.error('Edge Function: An unexpected error occurred:', error.message);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/crud-active-gateway/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { method } = req;

    // Para operaÃ§Ãµes GET, qualquer usuÃ¡rio autenticado pode ler o gateway ativo.
    // A verificaÃ§Ã£o de funÃ§Ã£o de admin Ã© necessÃ¡ria apenas para POST/PUT.
    if (method !== 'GET') {
      const { data: userRoleData, error: userRoleError } = await supabaseAdmin
        .from('user_roles')
        .select('role')
        .eq('user_id', user.id)
        .single();

      if (userRoleError || userRoleData?.role !== 'admin') {
        console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
        return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
          status: 403,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        });
      }
      console.log('Edge Function: Admin user confirmed for write operation.');
    }


    switch (method) {
      case 'GET': {
        const { data, error } = await supabaseAdmin
          .from('active_payment_gateway')
          .select('*')
          .eq('id', 1)
          .maybeSingle(); // Use maybeSingle to handle no rows found

        if (error) throw error;
        return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      case 'POST':
      case 'PUT': { // Both POST and PUT will perform an upsert
        const body = await req.json();
        const { gateway_name } = body;

        if (!gateway_name) {
          return new Response(JSON.stringify({ error: 'Missing required field: gateway_name' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }

        const { data, error } = await supabaseAdmin
          .from('active_payment_gateway')
          .upsert({ id: 1, gateway_name }, { onConflict: 'id' })
          .select()
          .single();

        if (error) throw error;
        return new Response(JSON.stringify(data), { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      default:
        return new Response('Method Not Allowed', { status: 405, headers: corsHeaders });
    }
  } catch (error: any) {
    console.error('Edge Function: Error in crud-active-gateway:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/crud-mercado-pago-configs/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    const { method } = req;

    switch (method) {
      case 'GET': {
        const { data, error } = await supabaseAdmin
          .from('mercado_pago_configs')
          .select('*')
          .eq('id', 1)
          .maybeSingle(); // Use maybeSingle to handle no rows found

        if (error) throw error;
        return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      case 'POST':
      case 'PUT': {
        const body = await req.json();
        const { mercado_pago_public_key, mercado_pago_access_token, mercado_pago_client_id, mercado_pago_client_secret } = body;

        if (!mercado_pago_public_key || !mercado_pago_access_token || !mercado_pago_client_id || !mercado_pago_client_secret) {
          return new Response(JSON.stringify({ error: 'Missing required fields: public_key, access_token, client_id, client_secret' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }

        const { data, error } = await supabaseAdmin
          .from('mercado_pago_configs')
          .upsert({ id: 1, mercado_pago_public_key, mercado_pago_access_token, mercado_pago_client_id, mercado_pago_client_secret }, { onConflict: 'id' })
          .select()
          .single();

        if (error) throw error;
        return new Response(JSON.stringify(data), { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      default:
        return new Response('Method Not Allowed', { status: 405, headers: corsHeaders });
    }
  } catch (error: any) {
    console.error('Edge Function: Error in crud-mercado-pago-configs:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/crud-pagbank-configs/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    const { method } = req;

    switch (method) {
      case 'GET': {
        const { data, error } = await supabaseAdmin
          .from('pagbank_configs')
          .select('*, environment') // NOVO: Incluir 'environment' na seleÃ§Ã£o
          .eq('id', 1)
          .maybeSingle(); // Use maybeSingle to handle no rows found

        if (error) throw error;
        return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      case 'POST':
      case 'PUT': {
        const body = await req.json();
        const { pagbank_email, pagbank_token, pagbank_pix_key, environment } = body; // NOVO: Obter 'environment'

        if (!pagbank_email || !pagbank_token || !pagbank_pix_key || !environment) { // NOVO: Validar 'environment'
          return new Response(JSON.stringify({ error: 'Missing required fields: pagbank_email, pagbank_token, pagbank_pix_key, environment' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }

        // NOVO: ValidaÃ§Ã£o estrita para o campo 'environment'
        if (environment !== 'sandbox' && environment !== 'production') {
          return new Response(JSON.stringify({ error: 'Invalid environment value. Must be "sandbox" or "production".' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }

        const { data, error } = await supabaseAdmin
          .from('pagbank_configs')
          .upsert({ id: 1, pagbank_email, pagbank_token, pagbank_pix_key, environment }, { onConflict: 'id' }) // NOVO: Incluir 'environment' no upsert
          .select()
          .single();

        if (error) throw error;
        return new Response(JSON.stringify(data), { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      default:
        return new Response('Method Not Allowed', { status: 405, headers: corsHeaders });
    }
  } catch (error: any) {
    console.error('Edge Function: Error in crud-pagbank-configs:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/crud-subscriber-automations/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const { method } = req;
    const url = new URL(req.url);
    const id = url.searchParams.get('id'); // For GET (single), PUT, DELETE

    switch (method) {
      case 'GET': {
        if (id) {
          const { data, error } = await supabaseAdmin
            .from('subscriber_automations')
            .select('*, subscriber_templates(name)')
            .eq('id', id)
            .single();
          if (error) throw error;
          return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        } else {
          const { data, error } = await supabaseAdmin
            .from('subscriber_automations')
            .select('*, subscriber_templates(name)')
            .order('created_at', { ascending: true });
          if (error) throw error;
          return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
      }
      case 'POST': {
        const body = await req.json();
        const { days_offset, subscriber_template_id, subscriber_ids, scheduled_time } = body;
        if (days_offset === undefined || !subscriber_template_id || !subscriber_ids || !scheduled_time) {
          return new Response(JSON.stringify({ error: 'Missing required fields: days_offset, subscriber_template_id, subscriber_ids, scheduled_time' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        const { data, error } = await supabaseAdmin
          .from('subscriber_automations')
          .insert({ admin_user_id: user.id, days_offset, subscriber_template_id, subscriber_ids, scheduled_time })
          .select()
          .single();
        if (error) throw error;
        return new Response(JSON.stringify(data), { status: 201, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      case 'PUT': {
        if (!id) {
          return new Response(JSON.stringify({ error: 'Missing ID for update' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        const body = await req.json();
        const { days_offset, subscriber_template_id, subscriber_ids, scheduled_time } = body;
        const updateData: any = {};
        if (days_offset !== undefined) updateData.days_offset = days_offset;
        if (subscriber_template_id !== undefined) updateData.subscriber_template_id = subscriber_template_id;
        if (subscriber_ids !== undefined) updateData.subscriber_ids = subscriber_ids;
        if (scheduled_time !== undefined) updateData.scheduled_time = scheduled_time;

        const { data, error } = await supabaseAdmin
          .from('subscriber_automations')
          .update(updateData)
          .eq('id', id)
          .select()
          .single();
        if (error) throw error;
        return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      case 'DELETE': {
        if (!id) {
          return new Response(JSON.stringify({ error: 'Missing ID for delete' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        const { error } = await supabaseAdmin
          .from('subscriber_automations')
          .delete()
          .eq('id', id);
        if (error) throw error;
        return new Response(JSON.stringify({ message: 'Subscriber automation deleted successfully.' }), { status: 204, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      default:
        return new Response('Method Not Allowed', { status: 405, headers: corsHeaders });
    }
  } catch (error: any) {
    console.error('Edge Function: Error in crud-subscriber-automations:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/crud-subscriber-plans/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS', // GARANTIR QUE PUT E DELETE ESTEJAM AQUI
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders, status: 200 }); // Retorna 200 OK para preflight
  }

  try {
    console.log('crud-subscriber-plans: Function started.');
    console.log(`crud-subscriber-plans: Request Method: ${req.method}`);
    console.log(`crud-subscriber-plans: Request URL: ${req.url}`);

    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      console.error('crud-subscriber-plans: Unauthorized - Missing Authorization header.');
      return new Response('Unauthorized', { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const { method } = req;
    const url = new URL(req.url);
    const id = url.searchParams.get('id');

    switch (method) {
      case 'GET': {
        if (id) {
          console.log(`crud-subscriber-plans: GET (single) request for ID: ${id}`);
          const { data, error } = await supabaseAdmin
            .from('subscriber_plans')
            .select('*')
            .eq('id', id)
            .single();
          if (error) {
            console.error(`crud-subscriber-plans: GET (single) error for ID ${id}:`, error.message);
            throw error;
          }
          console.log(`crud-subscriber-plans: GET (single) successful for ID ${id}.`);
          return new Response(JSON.stringify(data), { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        } else {
          console.log('crud-subscriber-plans: GET (all) request.');
          const { data, error } = await supabaseAdmin
            .from('subscriber_plans')
            .select('*')
            .order('name', { ascending: true });
          if (error) {
            console.error('crud-subscriber-plans: GET (all) error:', error.message);
            throw error;
          }
          console.log(`crud-subscriber-plans: GET (all) successful, found ${data?.length || 0} plans.`);
          return new Response(JSON.stringify(data), { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
      }
      case 'POST': {
        const body = await req.json();
        console.log('crud-subscriber-plans: POST request body:', JSON.stringify(body));
        const { name, value, period_days, is_free } = body; // Extrair is_free

        // ValidaÃ§Ã£o ajustada para permitir 0 para value e period_days se is_free for true
        if (!name || // 'name' Ã© sempre obrigatÃ³rio
            (value === undefined || value === null) || // 'value' Ã© obrigatÃ³rio (pode ser 0 se is_free)
            (period_days === undefined || period_days === null) || // 'period_days' Ã© obrigatÃ³rio (pode ser 0 se is_free)
            (!is_free && (value <= 0 || period_days <= 0)) // Se NÃO Ã© gratuito, value e period_days devem ser > 0
           ) {
          console.error('crud-subscriber-plans: POST error - Missing or invalid required fields.');
          return new Response(JSON.stringify({ error: 'Missing or invalid required fields: name, value, period_days (value/period must be > 0 if not free)' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        
        const { data, error } = await supabaseAdmin
          .from('subscriber_plans')
          .insert({ name, value, period_days, is_free }) // Incluir is_free na inserÃ§Ã£o
          .select()
          .single();
        if (error) {
          console.error('crud-subscriber-plans: POST error:', error.message);
          throw error;
        }
        console.log('crud-subscriber-plans: POST successful, data:', JSON.stringify(data));
        return new Response(JSON.stringify(data), { status: 201, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      case 'PUT': {
        if (!id) {
          console.error('crud-subscriber-plans: PUT error - Missing ID for update.');
          return new Response(JSON.stringify({ error: 'Missing ID for update' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        const body = await req.json();
        console.log(`crud-subscriber-plans: PUT request for ID ${id}, body:`, JSON.stringify(body));
        const { name, value, period_days, is_free } = body; // Extrair is_free tambÃ©m para PUT

        const updateData: any = {};
        if (name !== undefined) updateData.name = name;
        if (value !== undefined) updateData.value = value;
        if (period_days !== undefined) updateData.period_days = period_days;
        if (is_free !== undefined) updateData.is_free = is_free; // Incluir is_free na atualizaÃ§Ã£o

        console.log(`crud-subscriber-plans: Attempting to update subscriber_plans for ID ${id} with data:`, JSON.stringify(updateData));
        const { data, error } = await supabaseAdmin
          .from('subscriber_plans')
          .update(updateData)
          .eq('id', id)
          .select()
          .single();
        if (error) {
          console.error(`crud-subscriber-plans: PUT error for ID ${id}:`, error.message);
          throw error;
        }
        console.log(`crud-subscriber-plans: PUT successful for ID ${id}, data:`, JSON.stringify(data));
        return new Response(JSON.stringify(data), { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      case 'DELETE': {
        if (!id) {
          console.error('crud-subscriber-plans: DELETE error - Missing ID for delete.');
          return new Response(JSON.stringify({ error: 'Missing ID for delete' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        console.log(`crud-subscriber-plans: DELETE request for ID ${id}`);
        const { error } = await supabaseAdmin
          .from('subscriber_plans')
          .delete()
          .eq('id', id);
        if (error) {
          console.error(`crud-subscriber-plans: DELETE error for ID ${id}:`, error.message);
          throw error;
        }
        console.log(`crud-subscriber-plans: DELETE successful for ID ${id}`);
        // Retorna 204 No Content com os cabeÃ§alhos CORS
        return new Response(null, { status: 204, headers: corsHeaders });
      }
      default:
        console.warn(`crud-subscriber-plans: Method Not Allowed: ${method}`);
        return new Response('Method Not Allowed', { status: 405, headers: corsHeaders });
    }
  } catch (error: any) {
    console.error('crud-subscriber-plans: Unhandled error in Edge Function:', error.message, error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/crud-subscriber-templates/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    console.log('crud-subscriber-templates: Function started.');
    console.log(`crud-subscriber-templates: Request Method: ${req.method}`);
    console.log(`crud-subscriber-templates: Request URL: ${req.url}`);

    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      console.error('crud-subscriber-templates: Unauthorized - Missing Authorization header.');
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const { method } = req;
    const url = new URL(req.url);
    const id = url.searchParams.get('id');

    switch (method) {
      case 'GET': {
        if (id) {
          const { data, error } = await supabaseAdmin
            .from('subscriber_templates')
            .select('*')
            .eq('id', id)
            .single();
          if (error) {
            console.error(`crud-subscriber-templates: GET (single) error for ID ${id}:`, error.message);
            throw error;
          }
          return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        } else {
          const { data, error } = await supabaseAdmin
            .from('subscriber_templates')
            .select('*')
            .order('name', { ascending: true });
          if (error) {
            console.error('crud-subscriber-templates: GET (all) error:', error.message);
            throw error;
          }
          return new Response(JSON.stringify(data), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
      }
      case 'POST': {
        const body = await req.json();
        console.log('crud-subscriber-templates: POST request body:', JSON.stringify(body));
        const { name, content, type } = body;
        if (!name || !content) {
          return new Response(JSON.stringify({ error: 'Missing required fields: name, content' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        const { data, error } = await supabaseAdmin
          .from('subscriber_templates')
          .insert({ admin_user_id: user.id, name, content, type: type || 'normal' })
          .select()
          .single();
        if (error) {
          console.error('crud-subscriber-templates: POST error:', error.message);
          throw error;
        }
        console.log('crud-subscriber-templates: POST successful, data:', JSON.stringify(data));
        return new Response(JSON.stringify(data), { status: 201, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      case 'PUT': {
        if (!id) {
          return new Response(JSON.stringify({ error: 'Missing ID for update' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        const body = await req.json();
        console.log(`crud-subscriber-templates: PUT request for ID ${id}, body:`, JSON.stringify(body));
        const { name, content, type, admin_user_id } = body; // Capturar admin_user_id do body
        const updateData: any = {};
        if (name !== undefined) updateData.name = name;
        if (content !== undefined) updateData.content = content;
        if (type !== undefined) updateData.type = type;
        if (admin_user_id !== undefined) updateData.admin_user_id = admin_user_id; // Incluir admin_user_id na atualizaÃ§Ã£o

        const { data, error } = await supabaseAdmin
          .from('subscriber_templates')
          .update(updateData)
          .eq('id', id)
          .select()
          .single();
        if (error) {
          console.error(`crud-subscriber-templates: PUT error for ID ${id}:`, error.message);
          throw error;
        }
        console.log(`crud-subscriber-templates: PUT successful for ID ${id}, data:`, JSON.stringify(data));
        return new Response(JSON.stringify(data), { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }); // Alterado para 200 OK
      }
      case 'DELETE': {
        if (!id) {
          return new Response(JSON.stringify({ error: 'Missing ID for delete' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
        }
        console.log(`crud-subscriber-templates: DELETE request for ID ${id}`);
        const { error } = await supabaseAdmin
          .from('subscriber_templates')
          .delete()
          .eq('id', id);
        if (error) {
          console.error(`crud-subscriber-templates: DELETE error for ID ${id}:`, error.message);
          throw error;
        }
        console.log(`crud-subscriber-templates: DELETE successful for ID ${id}`);
        return new Response(JSON.stringify({ message: 'Subscriber template deleted successfully.' }), { status: 204, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
      }
      default:
        return new Response('Method Not Allowed', { status: 405, headers: corsHeaders });
    }
  } catch (error: any) {
    console.error('crud-subscriber-templates: Unhandled error in Edge Function:', error.message, error); // Log do erro completo
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/delete-user/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: adminRoleData, error: adminRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (adminRoleError || adminRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const { targetUserId } = await req.json();

    if (!targetUserId) {
      return new Response(JSON.stringify({ error: 'Missing targetUserId.' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    // Prevent admin from deleting themselves
    if (targetUserId === user.id) {
      return new Response(JSON.stringify({ error: 'Admins cannot delete their own account.' }), { status: 403, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    // Delete the user from auth.users. Due to CASCADE DELETE, this will also delete
    // associated profiles, user_roles, subscriptions, and user_instances.
    const { error: deleteUserError } = await supabaseAdmin.auth.admin.deleteUser(targetUserId);

    if (deleteUserError) {
      console.error('Edge Function: Error deleting user:', deleteUserError.message);
      throw deleteUserError;
    }

    return new Response(JSON.stringify({ success: true, message: 'User and associated data deleted successfully.' }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (error: any) {
    console.error('Edge Function: Error in delete-user:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/evolution-webhook-receiver/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseAdmin = createClient(
    // @ts-ignore
    Deno.env.get('SUPABASE_URL') ?? '',
    // @ts-ignore
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  let payload: any;
  let instanceName: string | null = null;
  let userId: string | null = null;
  let eventType: string | null = null;
  let historyEntryId: string | null = null; // Para armazenar o ID da entrada inicial do histÃ³rico

  try {
    payload = await req.json();
    console.log('Evolution Webhook received:', JSON.stringify(payload, null, 2));

    instanceName = payload.instance;
    eventType = payload.event;

    // Se o nome da instÃ¢ncia nÃ£o for encontrado, loga e retorna erro 400
    if (!instanceName) {
      console.error('Evolution Webhook: Instance name not found in payload.');
      // Tenta logar o erro mesmo sem userId, se possÃ­vel
      await supabaseAdmin.from('evolution_api_history').insert({
        user_id: null, // userId ainda nÃ£o disponÃ­vel
        webhook_type: eventType || 'evolution_inbound_unknown',
        payload: payload,
        request_payload: payload,
        response_payload: { error: 'Instance name not found in payload.' },
        status_code: 400,
      });
      return new Response(
        JSON.stringify({ error: 'Instance name not found in payload.' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Buscar o user_id associado a esta instÃ¢ncia
    // Service role bypasses RLS, so no explicit user_id filter needed here.
    const { data: instanceData, error: instanceError } = await supabaseAdmin
      .from('user_instances')
      .select('user_id')
      .eq('instance_name', instanceName)
      .single();

    if (instanceError || !instanceData) {
      console.error('Evolution Webhook: Instance not found or error fetching user_id:', instanceError?.message);
      // Tenta logar o erro mesmo sem userId, se possÃ­vel
      await supabaseAdmin.from('evolution_api_history').insert({
        user_id: null, // userId ainda nÃ£o disponÃ­vel
        webhook_type: eventType || 'evolution_inbound_unknown',
        payload: payload,
        request_payload: payload,
        response_payload: { error: 'Instance not found or associated user_id could not be retrieved.' },
        status_code: 404,
      });
      return new Response(
        JSON.stringify({ error: 'Instance not found or associated user_id could not be retrieved.' }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    userId = instanceData.user_id;

    // Log inicial da requisiÃ§Ã£o recebida
    const { data: initialHistoryEntry, error: initialLogError } = await supabaseAdmin
      .from('evolution_api_history')
      .insert({
        user_id: userId,
        webhook_type: eventType || 'evolution_inbound_unknown',
        payload: payload, // Armazena o payload completo
        request_payload: payload,
        status_code: 200, // Assume sucesso no recebimento da requisiÃ§Ã£o
        response_payload: { message: 'Processing...' }, // Placeholder
      })
      .select('id')
      .single();

    if (initialLogError) {
      console.error('Evolution Webhook: Error logging initial history entry:', initialLogError.message);
    } else {
      historyEntryId = initialHistoryEntry?.id;
    }

    let finalStatus = 200;
    let finalMessage = `Evolution webhook processed. Event: ${eventType}, Instance: ${instanceName}.`;

    // LÃ³gica Condicional para AtualizaÃ§Ã£o de Status
    if (eventType === 'connection.update' && payload.data?.state === 'open') {
      console.log(`Evolution Webhook: Connection update event with state 'open' detected for instance ${instanceName}.`);

      // Service role bypasses RLS, but we still filter by user_id to ensure data integrity.
      const { error: updateError } = await supabaseAdmin
        .from('user_instances')
        .update({ status: 'connected', qr_code_base64: null })
        .eq('instance_name', instanceName)
        .eq('user_id', userId); // Filter by user_id

      if (updateError) {
        console.error('Evolution Webhook: Error updating user_instances to connected:', updateError);
        finalStatus = 500; // Erro interno do servidor para falha na atualizaÃ§Ã£o do DB
        finalMessage += ` (Internal update error: ${updateError.message})`;
      } else {
        console.log(`Evolution Webhook: user_instances for ${instanceName} updated to 'connected'.`);
      }

      // Service role bypasses RLS, but we still filter by user_id to ensure data integrity.
      const { error: statusError } = await supabaseAdmin
        .from('connection_status')
        .upsert({
          user_id: userId,
          instance_name: instanceName,
          status: 'connected',
          qr_code_base64: null,
          last_updated: new Date().toISOString(),
        }, {
          onConflict: 'user_id,instance_name'
        });

      if (statusError) {
        console.error('Evolution Webhook: Error updating connection_status to connected:', statusError);
        finalStatus = 500; // Erro interno do servidor para falha na atualizaÃ§Ã£o do DB
        finalMessage += ` (Internal connection_status update error: ${statusError.message})`;
      } else {
        console.log(`Evolution Webhook: connection_status for ${instanceName} updated to 'connected'.`);
      }
    } else if (eventType === 'connection.update' && payload.data?.state === 'close') { // NOVO: LÃ³gica para 'close'
      console.log(`Evolution Webhook: Connection update event with state 'close' detected for instance ${instanceName}.`);

      // Service role bypasses RLS, but we still filter by user_id to ensure data integrity.
      const { error: updateError } = await supabaseAdmin
        .from('user_instances')
        .update({ status: 'disconnected', qr_code_base64: null })
        .eq('instance_name', instanceName)
        .eq('user_id', userId); // Filter by user_id

      if (updateError) {
        console.error('Evolution Webhook: Error updating user_instances to disconnected:', updateError);
        finalStatus = 500;
        finalMessage += ` (Internal update error: ${updateError.message})`;
      } else {
        console.log(`Evolution Webhook: user_instances for ${instanceName} updated to 'disconnected'.`);
      }

      // Service role bypasses RLS, but we still filter by user_id to ensure data integrity.
      const { error: statusError } = await supabaseAdmin
        .from('connection_status')
        .upsert({
          user_id: userId,
          instance_name: instanceName,
          status: 'disconnected',
          qr_code_base64: null,
          last_updated: new Date().toISOString(),
        }, {
          onConflict: 'user_id,instance_name'
        });

      if (statusError) {
        console.error('Evolution Webhook: Error updating connection_status to disconnected:', statusError);
        finalStatus = 500;
        finalMessage += ` (Internal connection_status update error: ${statusError.message})`;
      } else {
        console.log(`Evolution Webhook: connection_status for ${instanceName} updated to 'disconnected'.`);
      }
    } else {
      finalMessage += ` No status change applied.`;
    }

    // Atualiza a entrada do histÃ³rico com o status e mensagem finais
    if (historyEntryId) {
      await supabaseAdmin
        .from('evolution_api_history')
        .update({ status_code: finalStatus, response_payload: { message: finalMessage } })
        .eq('id', historyEntryId);
    }

    return new Response(
      JSON.stringify({ success: finalStatus === 200, message: finalMessage }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: finalStatus }
    );

  } catch (error: any) {
    console.error('Evolution Webhook: Unhandled error:', error.message);
    const errorStatus = 500;
    const errorMessage = error.message || 'Unknown error in Evolution Webhook.';

    // Se uma entrada inicial do histÃ³rico foi criada, atualiza. Caso contrÃ¡rio, cria uma nova.
    if (historyEntryId && userId) {
      await supabaseAdmin
        .from('evolution_api_history')
        .update({ status_code: errorStatus, response_payload: { error: errorMessage } })
        .eq('id', historyEntryId);
    } else if (userId && payload && eventType) {
      await supabaseAdmin
        .from('evolution_api_history')
        .insert({
          user_id: userId,
          webhook_type: eventType || 'evolution_inbound_unknown',
          payload: payload,
          request_payload: payload,
          response_payload: { error: errorMessage },
          status_code: errorStatus,
        });
    } else {
      console.error('Evolution Webhook: Could not log error to evolution_api_history, missing userId, payload or eventType.');
    }

    return new Response(
      JSON.stringify({ error: errorMessage }),
      { status: errorStatus, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
--- ConteÃºdo de: supabase/functions/financial-analysis/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

// @ts-ignore
import { DateTime } from 'https://esm.sh/luxon@3.4.4'; // Use Luxon

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Interfaces para tipagem dos dados do Supabase
interface FinancialEntry {
  value: number;
  created_at: string;
}

// Removed: interface ClientWithPlan {
// Removed:   value: number;
// Removed:   next_billing_date: string;
// Removed:   created_at: string;
// Removed:   status: string;
// Removed:   plans: { name: string; id: string; value: number }[] | { name: string; id: string; value: number } | null;
// Removed: }

// Removed: interface LostClient {
// Removed:   id: string;
// Removed:   value: number | null;
// Removed:   plans: { name: string }[] | { name: string } | null;
// Removed: }

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    const userId = user.id;

    // Fetch user role
    const { data: userRoleData, error: userRoleError } = await supabase
      .from('user_roles')
      .select('role')
      .eq('user_id', userId)
      .single();

    if (userRoleError && userRoleError.code !== 'PGRST116') { // PGRST116 = No rows found
      console.error('Edge Function: Error fetching user role:', userRoleError.message);
      throw userRoleError;
    }
    const userRole = userRoleData?.role || 'user'; // Default to 'user' if no role found

    // Conditionally apply user_id filter
    const applyUserIdFilter = (query: any) => {
      return userRole === 'admin' ? query : query.eq('user_id', userId);
    };
    
    const now = DateTime.local(); // Current local time

    const monthStart = now.startOf('month');
    const monthEnd = monthStart.plus({ months: 1 }).startOf('day'); // Exclusive end: start of next month

    const previousMonthStart = now.minus({ months: 1 }).startOf('month');
    const previousMonthEnd = previousMonthStart.plus({ months: 1 }).startOf('day'); // Exclusive end: start of current month

    // --- Valores Recebidos (financial_entries) ---
    const { data: financialEntries, error: financialError } = await applyUserIdFilter(
      supabase
        .from('financial_entries')
        .select('value, created_at')
    )
      .eq('type', 'credit');

    if (financialError) throw financialError;
    console.log('Edge Function: financialEntries fetched, count:', financialEntries?.length || 0);

    let receivedThisMonth = 0; // Para currentMonthRevenue
    let receivedPreviousMonth = 0; // Para previousMonthRevenue

    (financialEntries as FinancialEntry[] || []).forEach((entry: FinancialEntry) => {
      const entryDateTime = DateTime.fromISO(entry.created_at, { zone: 'utc' }).toLocal(); // Convert to local for comparison
      if (entryDateTime >= monthStart && entryDateTime < monthEnd) {
        receivedThisMonth += entry.value;
      } else if (entryDateTime >= previousMonthStart && entryDateTime < previousMonthEnd) {
        receivedPreviousMonth += entry.value;
      }
    });

    // --- PrevisÃ£o de RecebÃ­veis (clients) ---
    const { data: clients, error: clientsError } = await applyUserIdFilter(
      supabase
        .from('clients')
        .select('value, next_billing_date, created_at, status, plans(name, id, value)')
    );

    if (clientsError) throw clientsError;
    console.log('Edge Function: clients fetched, count:', clients?.length || 0);

    let newClientsThisMonth = 0;
    let activeClients = 0;
    let receivableThisMonth = 0; // Para revenueForecast

    const clientCreationMonthStart = now.startOf('month');
    const clientCreationMonthEnd = clientCreationMonthStart.plus({ months: 1 }).startOf('day'); // Exclusive end

    (clients || []).forEach((client: any) => {
      // Removed: const planData = Array.isArray(client.plans) ? client.plans[0] : client.plans;
      const clientCreationDateTime = DateTime.fromISO(client.created_at, { zone: 'utc' }).toLocal(); // Convert to local for comparison
      if (clientCreationDateTime >= clientCreationMonthStart && clientCreationDateTime < clientCreationMonthEnd) {
        newClientsThisMonth++;
      }
      if (client.status === 'active') {
        activeClients++;
        if (client.next_billing_date) {
          const dueDate = DateTime.fromISO(client.next_billing_date, { zone: 'local' }).startOf('day'); // Treat as local date, start of day
          if (dueDate >= monthStart && dueDate < monthEnd) {
            receivableThisMonth += client.value;
          }
        }
      }
    });

    // --- KPIs Calculation ---
    const currentMonthRevenue = receivedThisMonth;
    const previousMonthRevenue = receivedPreviousMonth;

    const monthlyGrowthPercentage = previousMonthRevenue > 0
      ? ((currentMonthRevenue / previousMonthRevenue) - 1) * 100
      : (currentMonthRevenue > 0 ? 100 : 0);

    const revenueForecast = currentMonthRevenue + receivableThisMonth;

    const kpis = {
      currentMonthRevenue,
      previousMonthRevenue,
      monthlyGrowthPercentage,
      newClientsThisMonth,
      activeClients,
      revenueForecast,
    };

    // --- Churn Analysis Calculation (for Analise page) ---
    const { data: lostClientsData, error: lostClientsError } = await applyUserIdFilter(
      supabase
        .from('clients')
        .select(`
          id,
          value,
          plans ( name )
        `)
    )
      .in('status', ['inactive', 'overdue'])
      .gte('next_billing_date', monthStart.toISODate())
      .lt('next_billing_date', monthEnd.toISODate()); // Use lt for exclusive end

    if (lostClientsError) throw lostClientsError;

    let lostClientsThisMonth = 0;
    let lostRevenueThisMonth = 0;
    const churnByPlanMap = new Map<string, { planName: string; lostCount: number }>();

    (lostClientsData || []).forEach((client: any) => {
      const planData = Array.isArray(client.plans) ? client.plans[0] : client.plans;
      const planName = planData?.name || 'Plano Desconhecido';
      const clientValue = client.value || 0;

      if (!churnByPlanMap.has(planName)) {
        churnByPlanMap.set(planName, { planName, lostCount: 0 });
      }
      churnByPlanMap.get(planName)!.lostCount++;

      lostClientsThisMonth++;
      lostRevenueThisMonth += clientValue;
    });

    const churnByPlan = Array.from(churnByPlanMap.values()).sort((a, b) => b.lostCount - a.lostCount);

    const totalClientsForChurn = activeClients + lostClientsThisMonth; // Corrected calculation for churn rate denominator
    const churnRate = totalClientsForChurn > 0
      ? (lostClientsThisMonth / totalClientsForChurn) * 100
      : 0;

    const churnAnalysis = {
      lostClientsThisMonth,
      lostRevenueThisMonth,
      churnRate,
      churnByPlan,
    };

    // --- Revenue Last 30 Days ---
    const revenueLast30DaysMap = new Map<string, number>();
    const thirtyDaysAgo = now.minus({ days: 29 }).startOf('day'); // Start of day 29 days ago
    
    for (let d = thirtyDaysAgo; d <= now.endOf('day'); d = d.plus({ days: 1 })) { // Iterate up to end of today
      revenueLast30DaysMap.set(d.toISODate(), 0);
    }

    (financialEntries as FinancialEntry[] || []).forEach((entry: FinancialEntry) => {
      const entryDateTime = DateTime.fromISO(entry.created_at, { zone: 'utc' }).toLocal();
      const entryDateStr = entryDateTime.toISODate();
      if (revenueLast30DaysMap.has(entryDateStr)) {
        revenueLast30DaysMap.set(entryDateStr, revenueLast30DaysMap.get(entryDateStr)! + entry.value);
      }
    });

    // --- Weekly Revenue Comparison ---
    const weeklyRevenueComparison: { [key: string]: { currentMonth: number; previousMonth: number } } = {};

    const getWeekNumber = (date: DateTime) => {
      // Luxon's week number is 1-indexed, relative to the start of the year.
      // We need to ensure consistency with how weeks are defined.
      // For simplicity, let's use Luxon's default week number for the year.
      return date.weekNumber;
    };

    const processWeeklyRevenue = (entries: FinancialEntry[] | null, start: DateTime, end: DateTime, targetObject: any, monthKey: 'currentMonth' | 'previousMonth') => {
      const monthEntries = (entries || []).filter((entry: FinancialEntry) => {
        const entryDateTime = DateTime.fromISO(entry.created_at, { zone: 'utc' }).toLocal();
        return entryDateTime >= start && entryDateTime < end;
      });

      monthEntries.forEach((entry: FinancialEntry) => {
        const entryDateTime = DateTime.fromISO(entry.created_at, { zone: 'utc' }).toLocal();
        const weekNum = getWeekNumber(entryDateTime);
        const weekKey = `week${weekNum}`;

        if (!targetObject[weekKey]) {
          targetObject[weekKey] = { currentMonth: 0, previousMonth: 0 };
        }
        targetObject[weekKey][monthKey] += entry.value;
      });
    };

    processWeeklyRevenue(financialEntries, monthStart, monthEnd, weeklyRevenueComparison, 'currentMonth');
    processWeeklyRevenue(financialEntries, previousMonthStart, previousMonthEnd, weeklyRevenueComparison, 'previousMonth');

    const allWeekKeys = new Set<string>();
    Object.keys(weeklyRevenueComparison).forEach(key => allWeekKeys.add(key));
    for (const key of allWeekKeys) {
      if (!weeklyRevenueComparison[key].currentMonth) weeklyRevenueComparison[key].currentMonth = 0;
      if (!weeklyRevenueComparison[key].previousMonth) weeklyRevenueComparison[key].previousMonth = 0; // Fix: ensure previousMonth is also initialized
    }

    // --- Revenue by Plan (Current Month) ---
    const revenueByPlanData: { planName: string; totalRevenue: number }[] = [];
    const tempRevenueByPlan = new Map<string, number>();

    (clients || []).forEach((client: any) => {
      const planData = Array.isArray(client.plans) ? client.plans[0] : client.plans;
      if (client.status === 'active' && planData?.name && planData?.id) {
        const planName = planData.name;
        const planValue = client.value || 0; // Use client.value for revenue by plan
        tempRevenueByPlan.set(planName, (tempRevenueByPlan.get(planName) || 0) + planValue);
      }
    });

    tempRevenueByPlan.forEach((totalRevenue, planName) => {
      revenueByPlanData.push({ planName, totalRevenue });
    });

    // --- Monthly Revenue History (Last 12 Months) ---
    const twelveMonthsAgoStart = now.minus({ months: 11 }).startOf('month'); // Start of month 11 months ago
    const currentMonthEndForHistory = now.endOf('month'); // End of current month for history range

    const { data: monthlyEntriesHistory, error: monthlyEntriesHistoryError } = await applyUserIdFilter(
      supabase
        .from('financial_entries')
        .select('value, created_at')
    )
      .eq('type', 'credit')
      .gte('created_at', twelveMonthsAgoStart.toUTC().toISO()) // Use UTC for DB query
      .lt('created_at', currentMonthEndForHistory.plus({ days: 1 }).toUTC().toISO()); // Use UTC for DB query, exclusive end

    if (monthlyEntriesHistoryError) throw monthlyEntriesHistoryError;
    console.log('Edge Function: monthlyEntriesHistory fetched, count:', monthlyEntriesHistory?.length || 0);

    const monthlyRevenueHistoryMap = new Map<string, number>();
    (monthlyEntriesHistory as FinancialEntry[] || []).forEach((entry: FinancialEntry) => {
      const entryDateTime = DateTime.fromISO(entry.created_at, { zone: 'utc' }).toLocal(); // Convert to local for grouping
      const monthKey = entryDateTime.toFormat('yyyy-MM');
      monthlyRevenueHistoryMap.set(monthKey, (monthlyRevenueHistoryMap.get(monthKey) || 0) + entry.value);
    });

    const monthlyRevenueHistory: { month: string; revenue: number }[] = [];
    let currentMonthIterator = twelveMonthsAgoStart.startOf('month');
    while (currentMonthIterator <= now.startOf('month')) { // Iterate up to start of current month
      const monthKey = currentMonthIterator.toFormat('yyyy-MM');
      const monthLabel = currentMonthIterator.toFormat('MMM/yy');
      monthlyRevenueHistory.push({
        month: monthLabel,
        revenue: monthlyRevenueHistoryMap.get(monthKey) || 0,
      });
      currentMonthIterator = currentMonthIterator.plus({ months: 1 });
    }

    console.log('Edge Function: Financial analysis data prepared successfully.');

    return new Response(
      JSON.stringify({
        kpis,
        revenueLast30Days: Array.from(revenueLast30DaysMap.entries()).map(([date, revenue]) => ({ date, revenue })),
        weeklyRevenueComparison,
        revenueByPlan: revenueByPlanData,
        churnAnalysis,
        monthlyRevenueHistory,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error: any) {
    console.error('Edge Function: Error fetching financial analysis:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred in the financial analysis function.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/financial-summary/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

// @ts-ignore
import { DateTime } from 'https://esm.sh/luxon@3.4.4'; // Use Luxon

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Interfaces para tipagem dos dados do Supabase
interface FinancialEntry {
  value: number;
  created_at: string;
}

interface ClientSummary {
  value: number;
  next_billing_date: string;
}

interface ChurnClient {
  value: number | null;
}

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    const userId = user.id;

    // Fetch user role
    const { data: userRoleData, error: userRoleError } = await supabase
      .from('user_roles')
      .select('role')
      .eq('user_id', userId)
      .single();

    if (userRoleError && userRoleError.code !== 'PGRST116') { // PGRST116 = No rows found
      console.error('Edge Function: Error fetching user role:', userRoleError.message);
      throw userRoleError;
    }
    const userRole = userRoleData?.role || 'user'; // Default to 'user' if no role found

    // Conditionally apply user_id filter
    const applyUserIdFilter = (query: any) => {
      return userRole === 'admin' ? query : query.eq('user_id', userId);
    };
    
    const now = DateTime.local(); // Current local time
    const todayStart = now.startOf('day');
    const todayEnd = now.plus({ days: 1 }).startOf('day'); // Exclusive end: start of tomorrow

    // Luxon's startOf('week') defaults to Monday. To match date-fns weekStartsOn: 0 (Sunday),
    // we need to set locale or explicitly adjust. 'en-US' starts on Sunday.
    const weekStart = now.setLocale('en-US').startOf('week');
    const weekEnd = weekStart.plus({ weeks: 1 }).startOf('day'); // Exclusive end: start of next week

    const monthStart = now.startOf('month');
    const monthEnd = monthStart.plus({ months: 1 }).startOf('day'); // Exclusive end: start of next month

    // --- Valores Recebidos (financial_entries) ---
    const { data: financialEntries, error: financialError } = await applyUserIdFilter(
      supabase
        .from('financial_entries')
        .select('value, created_at')
    )
      .eq('type', 'credit');

    if (financialError) throw financialError;
    console.log('Edge Function: financialEntries fetched, count:', financialEntries?.length || 0);

    let receivedToday = 0;
    let receivedThisWeek = 0;
    let receivedThisMonth = 0;

    (financialEntries as FinancialEntry[] || []).forEach((entry: FinancialEntry) => {
      const entryDateTime = DateTime.fromISO(entry.created_at, { zone: 'utc' }).toLocal(); // Convert to local for comparison
      if (entryDateTime >= todayStart && entryDateTime < todayEnd) {
        receivedToday += entry.value;
      }
      if (entryDateTime >= weekStart && entryDateTime < weekEnd) {
        receivedThisWeek += entry.value;
      }
      if (entryDateTime >= monthStart && entryDateTime < monthEnd) {
        receivedThisMonth += entry.value;
      }
    });

    // --- PrevisÃ£o de RecebÃ­veis (clients) ---
    const { data: clients, error: clientsError } = await applyUserIdFilter(
      supabase
        .from('clients')
        .select('value, next_billing_date')
    )
      .eq('status', 'active');

    if (clientsError) throw clientsError;
    console.log('Edge Function: clients fetched, count:', clients?.length || 0);

    let receivableToday = 0;
    let receivableTomorrow = 0;
    let receivableThisWeek = 0;
    let receivableThisMonth = 0;

    const tomorrowStart = now.plus({ days: 1 }).startOf('day');
    const tomorrowEnd = now.plus({ days: 2 }).startOf('day'); // Exclusive end: start of day after tomorrow

    (clients as ClientSummary[] || []).forEach((client: ClientSummary) => {
      if (!client.next_billing_date) return;
      const dueDate = DateTime.fromISO(client.next_billing_date, { zone: 'local' }).startOf('day'); // Treat as local date, start of day

      if (dueDate >= todayStart && dueDate < todayEnd) {
        receivableToday += client.value;
      }
      if (dueDate >= tomorrowStart && dueDate < tomorrowEnd) {
        receivableTomorrow += client.value;
      }
      if (dueDate >= weekStart && dueDate < weekEnd) {
        receivableThisWeek += client.value;
      }
      if (dueDate >= monthStart && dueDate < monthEnd) {
        receivableThisMonth += client.value;
      }
    });

    // --- Valores Perdidos (Churn) ---
    const { data: churnClientsToday, error: churnClientsTodayError } = await applyUserIdFilter(
      supabase
        .from('clients')
        .select('value')
    )
      .in('status', ['inactive', 'overdue'])
      .gte('next_billing_date', todayStart.toISODate())
      .lt('next_billing_date', todayEnd.toISODate()); // Use lt for exclusive end
    if (churnClientsTodayError) throw churnClientsTodayError;
    const lostValueToday = (churnClientsToday as ChurnClient[] || []).reduce((sum: number, client: ChurnClient) => sum + (client.value || 0), 0);
    console.log('Edge Function: lostValueToday calculated:', lostValueToday);

    const { data: churnClientsThisWeek, error: churnClientsThisWeekError } = await applyUserIdFilter(
      supabase
        .from('clients')
        .select('value')
    )
      .in('status', ['inactive', 'overdue'])
      .gte('next_billing_date', weekStart.toISODate())
      .lt('next_billing_date', weekEnd.toISODate()); // Use lt for exclusive end
    if (churnClientsThisWeekError) throw churnClientsThisWeekError;
    const lostValueThisWeek = (churnClientsThisWeek as ChurnClient[] || []).reduce((sum: number, client: ChurnClient) => sum + (client.value || 0), 0);
    console.log('Edge Function: lostValueThisWeek calculated:', lostValueThisWeek);

    const { data: churnClientsThisMonth, error: churnClientsThisMonthError } = await applyUserIdFilter(
      supabase
        .from('clients')
        .select('value')
    )
      .in('status', ['inactive', 'overdue'])
      .gte('next_billing_date', monthStart.toISODate())
      .lt('next_billing_date', monthEnd.toISODate()); // Use lt for exclusive end
    if (churnClientsThisMonthError) throw churnClientsThisMonthError;
    const lostValueThisMonth = (churnClientsThisMonth as ChurnClient[] || []).reduce((sum: number, client: ChurnClient) => sum + (client.value || 0), 0);
    console.log('Edge Function: lostValueThisMonth calculated:', lostValueThisMonth);

    console.log('Edge Function: Financial summary data prepared successfully.');

    return new Response(
      JSON.stringify({
        receivedToday,
        receivedThisWeek,
        receivedThisMonth,
        receivableToday,
        receivableTomorrow,
        receivableThisWeek,
        receivableThisMonth,
        lostValueToday,
        lostValueThisWeek,
        lostValueThisMonth,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error: any) {
    console.error('Edge Function: Error fetching financial summary:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred in the financial summary function.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/list-all-users/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    // Fetch all profiles and their roles, subscriptions, and user_instances
    const { data: usersData, error: usersError } = await supabaseAdmin
      .from('profiles')
      .select(`
        id,
        name,
        email,
        phone,
        created_at,
        user_roles(role),
        subscriptions(id, plan_name, price, status, next_billing_date),
        user_instances(id, instance_name, status)
      `)
      .order('created_at', { ascending: true });

    if (usersError) throw usersError;
    console.log('Edge Function: Users data fetched, count:', usersData?.length || 0);

    // Fetch all subscriber plans to get their 'is_free' status
    const { data: plansData, error: plansError } = await supabaseAdmin
      .from('subscriber_plans')
      .select('name, is_free');

    if (plansError) throw plansError;
    console.log('Edge Function: Subscriber plans data fetched, count:', plansData?.length || 0);

    const planMap = new Map(plansData.map((plan: { name: string; is_free: boolean }) => [plan.name, plan.is_free]));

    const formattedUsers = (usersData || []).map((profile: any) => {
      const role = Array.isArray(profile.user_roles) ? profile.user_roles[0]?.role : profile.user_roles?.role;
      const subscription = Array.isArray(profile.subscriptions) ? profile.subscriptions[0] : profile.subscriptions;
      const instance = Array.isArray(profile.user_instances) ? profile.user_instances[0] : profile.user_instances;

      let formattedSubscription = null;
      if (subscription) {
        const isFree = planMap.get(subscription.plan_name) || false; // Default to false if plan not found
        formattedSubscription = {
          id: subscription.id,
          plan_name: subscription.plan_name,
          price: subscription.price,
          status: subscription.status,
          next_billing_date: subscription.next_billing_date,
          isFree: isFree, // Add the isFree property
        };
      }

      return {
        id: profile.id,
        name: profile.name,
        email: profile.email,
        phone: profile.phone,
        created_at: profile.created_at,
        role: role || 'user',
        subscription: formattedSubscription, // Use the formatted subscription
        instance: instance ? {
          id: instance.id,
          instance_name: instance.instance_name,
          status: instance.status,
        } : null,
      };
    });

    return new Response(JSON.stringify(formattedUsers), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (error: any) {
    console.error('Edge Function: Error in list-all-users:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/log-n8n-qr-interaction/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseAdmin = createClient(
    // @ts-ignore
    Deno.env.get('SUPABASE_URL') ?? '',
    // @ts-ignore
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    const { requestPayload, responsePayload, statusCode, errorMessage, instanceName } = await req.json();

    // Service role bypasses RLS, so no explicit user_id filter needed here.
    const { error: insertError } = await supabaseAdmin
      .from('n8n_qr_code_history')
      .insert({
        user_id: user.id,
        webhook_type: 'n8n_outbound_qr',
        payload: { instanceName, requestPayload, responsePayload, errorMessage }, // Consolidar payload
        request_payload: requestPayload,
        response_payload: responsePayload,
        status_code: statusCode,
      });

    if (insertError) {
      console.error('log-n8n-qr-interaction: Error inserting into n8n_qr_code_history:', insertError.message);
      throw new Error(`Failed to log QR interaction: ${insertError.message}`);
    }

    return new Response(JSON.stringify({ success: true, message: 'QR interaction logged successfully.' }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });

  } catch (error: any) {
    console.error('log-n8n-qr-interaction: Unhandled error:', error.message);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/mercado-pago-create-charge/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseAdmin = createClient(
    // @ts-ignore
    Deno.env.get('SUPABASE_URL') ?? '',
    // @ts-ignore
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  try {
    console.log('mercado-pago-create-charge: Function started.');

    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      console.error('mercado-pago-create-charge: Unauthorized - Missing Authorization header.');
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      console.error('mercado-pago-create-charge: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    const userId = user.id;
    console.log('mercado-pago-create-charge: User authenticated, userId:', userId);

    const { subscription_id, amount } = await req.json();
    console.log(`mercado-pago-create-charge: Received payload: subscription_id=${subscription_id}, amount=${amount}`);

    if (!subscription_id || !amount) {
      console.error('mercado-pago-create-charge: Missing subscription_id or amount in payload.');
      return new Response(JSON.stringify({ error: 'Missing subscription_id or amount.' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    // 1. Fetch Mercado Pago credentials
    console.log('mercado-pago-create-charge: Fetching Mercado Pago configs...');
    const { data: mpConfig, error: configError } = await supabaseAdmin
      .from('mercado_pago_configs')
      .select('mercado_pago_access_token')
      .eq('id', 1)
      .single();

    if (configError || !mpConfig) {
      console.error('mercado-pago-create-charge: Mercado Pago config not found:', configError?.message);
      return new Response(JSON.stringify({ error: 'Mercado Pago configuration not found. Please contact support.' }), {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('mercado-pago-create-charge: Mercado Pago config fetched successfully.');

    const mercadoPagoAccessToken = mpConfig.mercado_pago_access_token;
    const mercadoPagoApiUrl = 'https://api.mercadopago.com/v1/payments'; // Mercado Pago Payments API

    // 2. Fetch subscription details to get plan_name for description
    console.log('mercado-pago-create-charge: Fetching subscription details...');
    const { data: subscription, error: subscriptionError } = await supabaseAdmin
      .from('subscriptions')
      .select('plan_name')
      .eq('id', subscription_id)
      .single();

    if (subscriptionError || !subscription) {
      console.error('mercado-pago-create-charge: Subscription not found:', subscriptionError?.message);
      return new Response(JSON.stringify({ error: 'Subscription not found for the provided ID.' }), {
        status: 404,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('mercado-pago-create-charge: Subscription details fetched successfully. Plan Name:', subscription.plan_name);

    // 2.1. Fetch customer data from profiles (including email, phone, tax_id)
    console.log('mercado-pago-create-charge: Fetching customer profile...');
    const { data: profile, error: profileError } = await supabaseAdmin
      .from('profiles')
      .select('name, email, phone, tax_id')
      .eq('id', userId)
      .single();

    if (profileError || !profile) {
      console.error('mercado-pago-create-charge: Customer profile not found for userId:', userId, profileError?.message);
      return new Response(JSON.stringify({ error: 'Perfil do usuÃ¡rio nÃ£o encontrado.' }), {
        status: 404,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('mercado-pago-create-charge: Customer profile fetched successfully. Name:', profile.name);

    // ValidaÃ§Ã£o e limpeza do tax_id do perfil
    const cleanedTaxId = profile.tax_id?.replace(/\D/g, '');
    if (!cleanedTaxId || (cleanedTaxId.length !== 11 && cleanedTaxId.length !== 14)) {
      console.error('mercado-pago-create-charge: Invalid or missing CPF/CNPJ in user profile:', profile.tax_id);
      return new Response(JSON.stringify({ error: 'CPF/CNPJ invÃ¡lido ou ausente no perfil do usuÃ¡rio. Por favor, atualize seu perfil.' }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // 3. Build Mercado Pago API Payload for PIX payment
    const mpRequestBody: any = {
      transaction_amount: amount,
      description: `RenovaÃ§Ã£o de Assinatura ${subscription.plan_name}`,
      payment_method_id: 'pix',
      payer: {
        email: profile.email,
        first_name: profile.name.split(' ')[0],
        last_name: profile.name.split(' ').slice(1).join(' ') || '',
        identification: {
          type: cleanedTaxId.length === 11 ? 'CPF' : 'CNPJ',
          number: cleanedTaxId,
        },
        // phone: { // Mercado Pago often requires phone for certain payment methods, but not strictly for PIX
        //   area_code: profile.phone?.substring(2, 4) || '',
        //   number: profile.phone?.substring(4) || '',
        // },
      },
      external_reference: `sub-${subscription_id}-${Date.now()}`, // Unique reference for tracking
      notification_url: `${Deno.env.get('SUPABASE_URL')}/functions/v1/mercado-pago-webhook-receiver`, // Webhook para receber atualizaÃ§Ãµes
    };

    // Gerar um X-Idempotency-Key Ãºnico
    const idempotencyKey = `mp-charge-${subscription_id}-${Date.now()}`;
    console.log(`mercado-pago-create-charge: Using X-Idempotency-Key: ${idempotencyKey}`);

    console.log('mercado-pago-create-charge: Sending request to Mercado Pago API with body:', JSON.stringify(mpRequestBody, null, 2));

    const mpResponse = await fetch(mercadoPagoApiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${mercadoPagoAccessToken}`,
        'X-Idempotency-Key': idempotencyKey, // Adicionado o cabeÃ§alho de idempotÃªncia
      },
      body: JSON.stringify(mpRequestBody),
    });

    const mpResponseData = await mpResponse.json();
    console.log('mercado-pago-create-charge: Mercado Pago API raw response:', JSON.stringify(mpResponseData, null, 2));

    if (!mpResponse.ok) {
      console.error('mercado-pago-create-charge: Mercado Pago API error response:', mpResponseData);
      const errorMessage = mpResponseData.message || mpResponseData.error_messages?.[0]?.message || `Falha ao criar cobranÃ§a PIX no Mercado Pago: ${mpResponse.statusText}`;
      throw new Error(errorMessage);
    }

    // 4. Extract data from Mercado Pago response
    const mercadoPagoPaymentId = mpResponseData.id;
    const qrCodeImageUrl = mpResponseData.point_of_interaction?.transaction_data?.qr_code_base64 
                           ? `data:image/png;base64,${mpResponseData.point_of_interaction.transaction_data.qr_code_base64}`
                           : null;
    const qrCodeText = mpResponseData.point_of_interaction?.transaction_data?.qr_code;

    if (!mercadoPagoPaymentId || !qrCodeImageUrl || !qrCodeText) {
      console.error('mercado-pago-create-charge: Missing required data in Mercado Pago response:', mpResponseData);
      throw new Error('Dados essenciais (ID do pagamento, QR Code) nÃ£o encontrados na resposta do Mercado Pago.');
    }
    console.log('mercado-pago-create-charge: Mercado Pago response parsed successfully. Payment ID:', mercadoPagoPaymentId);

    // 5. Save charge details to mercado_pago_charges
    console.log('mercado-pago-create-charge: Inserting charge into mercado_pago_charges...');
    const { data: newCharge, error: insertError } = await supabaseAdmin
      .from('mercado_pago_charges')
      .insert({
        user_id: userId,
        subscription_id: subscription_id,
        mercado_pago_payment_id: String(mercadoPagoPaymentId), // Ensure it's a string
        status: 'pending', // Initial status
        value: amount,
      })
      .select()
      .single();

    if (insertError) {
      console.error('mercado-pago-create-charge: Error inserting Mercado Pago charge:', insertError.message);
      throw new Error(`Failed to record Mercado Pago charge: ${insertError.message}`);
    }
    console.log('mercado-pago-create-charge: Charge inserted successfully, newChargeId:', newCharge.id);

    const responsePayload = {
      mercado_pago_payment_id: newCharge.mercado_pago_payment_id,
      qr_code_image_url: qrCodeImageUrl,
      qr_code_text: qrCodeText,
      value: amount,
    };
    console.log('mercado-pago-create-charge: Returning response:', JSON.stringify(responsePayload));

    return new Response(JSON.stringify(responsePayload), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });

  } catch (error: any) {
    console.error('mercado-pago-create-charge: Unhandled error in Edge Function:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/mercado-pago-webhook-receiver/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';
// @ts-ignore
import { DateTime } from 'https://esm.sh/luxon@3.4.4';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseAdmin = createClient(
    // @ts-ignore
    Deno.env.get('SUPABASE_URL') ?? '',
    // @ts-ignore
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  try {
    const payload = await req.json();
    console.log('Mercado Pago Webhook received payload:', JSON.stringify(payload, null, 2));

    // Mercado Pago sends different event types. We are interested in 'payment' events.
    // The actual payment ID is usually in payload.data.id for payment events.
    const eventType = payload.type;
    const paymentId = payload.data?.id; // This is the Mercado Pago payment ID

    if (eventType !== 'payment' || !paymentId) {
      console.warn('Mercado Pago Webhook: Not a payment event or missing payment ID. Skipping.');
      return new Response(JSON.stringify({ message: 'Not a relevant event type or missing payment ID.' }), {
        status: 200, // Return 200 to acknowledge receipt, even if not processed
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // 1. Fetch payment details from Mercado Pago API to get the full status
    console(`Mercado Pago Webhook: Fetching payment details for ID: ${paymentId}`);
    const { data: mpConfig, error: configError } = await supabaseAdmin
      .from('mercado_pago_configs')
      .select('mercado_pago_access_token')
      .eq('id', 1)
      .single();

    if (configError || !mpConfig) {
      console.error('Mercado Pago Webhook: Mercado Pago config not found:', configError?.message);
      throw new Error('Mercado Pago configuration not found. Please contact support.');
    }
    const mercadoPagoAccessToken = mpConfig.mercado_pago_access_token;
    const paymentApiUrl = `https://api.mercadopago.com/v1/payments/${paymentId}`;

    const mpResponse = await fetch(paymentApiUrl, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${mercadoPagoAccessToken}`,
      },
    });

    const mpPaymentData = await mpResponse.json();
    console.log('Mercado Pago Webhook: Fetched payment data:', JSON.stringify(mpPaymentData, null, 2));

    if (!mpResponse.ok) {
      console.error('Mercado Pago Webhook: Error fetching payment details from MP API:', mpPaymentData);
      throw new Error(`Failed to fetch payment details from Mercado Pago: ${mpPaymentData.message || mpResponse.statusText}`);
    }

    const mpPaymentStatus = mpPaymentData.status; // e.g., 'approved', 'pending', 'rejected', 'cancelled'
    const externalReference = mpPaymentData.external_reference; // Our reference_id
    const transactionAmount = mpPaymentData.transaction_amount;

    if (!externalReference) {
      console.error('Mercado Pago Webhook: Missing external_reference in payment data.');
      return new Response(JSON.stringify({ error: 'Missing external_reference in payment data.' }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // Extract subscription_id from external_reference (e.g., "sub-UUID-TIMESTAMP")
    const subscriptionIdMatch = externalReference.match(/sub-([a-f0-9-]+)-\d+/);
    const subscription_id = subscriptionIdMatch ? subscriptionIdMatch[1] : null;

    if (!subscription_id) {
      console.error('Mercado Pago Webhook: Could not extract subscription_id from external_reference:', externalReference);
      return new Response(JSON.stringify({ error: 'Could not extract subscription_id from external_reference.' }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // 2. Find the corresponding charge in mercado_pago_charges
    const { data: charge, error: chargeError } = await supabaseAdmin
      .from('mercado_pago_charges')
      .select('id, user_id, subscription_id, status, value')
      .eq('mercado_pago_payment_id', String(paymentId))
      .eq('subscription_id', subscription_id)
      .single();

    if (chargeError || !charge) {
      console.error(`Mercado Pago Webhook: Charge ${paymentId} not found in DB or error:`, chargeError?.message);
      return new Response(JSON.stringify({ error: `Charge ${paymentId} not found.` }), {
        status: 404,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // 3. Process if status is 'approved' and current DB status is 'pending'
    if (mpPaymentStatus === 'approved' && charge.status === 'pending') {
      console.log(`Mercado Pago Webhook: Processing 'approved' status for charge ${paymentId}.`);

      // Update status in mercado_pago_charges
      const { error: updateChargeError } = await supabaseAdmin
        .from('mercado_pago_charges')
        .update({ status: 'approved' })
        .eq('id', charge.id);

      if (updateChargeError) {
        console.error('Mercado Pago Webhook: Error updating mercado_pago_charges status:', updateChargeError.message);
        throw new Error(`Failed to update charge status: ${updateChargeError.message}`);
      }

      // Get subscription details
      const { data: subscription, error: subError } = await supabaseAdmin
        .from('subscriptions')
        .select('id, user_id, plan_name, price, next_billing_date, subscriber_plans(period_days)')
        .eq('id', charge.subscription_id)
        .single();

      if (subError || !subscription) {
        console.error('Mercado Pago Webhook: Subscription not found or error:', subError?.message);
        throw new Error(`Subscription ${charge.subscription_id} not found.`);
      }

      const planData = Array.isArray(subscription.subscriber_plans) ? subscription.subscriber_plans[0] : subscription.subscriber_plans;
      const periodDays = planData?.period_days;

      if (!periodDays) {
        console.error('Mercado Pago Webhook: Plan period_days not found for subscription:', subscription.id);
        throw new Error(`Plan period_days not found for subscription ${subscription.id}.`);
      }

      // Calculate new next_billing_date
      const currentDueDate = DateTime.fromISO(subscription.next_billing_date, { zone: 'local' }).startOf('day');
      const newNextBillingDate = currentDueDate.plus({ days: periodDays }).toISODate();

      // Update subscription
      const { error: updateSubError } = await supabaseAdmin
        .from('subscriptions')
        .update({ next_billing_date: newNextBillingDate, status: 'active' })
        .eq('id', subscription.id);

      if (updateSubError) {
        console.error('Mercado Pago Webhook: Error updating subscription:', updateSubError.message);
        throw new Error(`Failed to update subscription: ${updateSubError.message}`);
      }

      // Get admin_user_id from mercado_pago_configs (assuming the admin who set it up is the one to log revenue)
      const { data: adminConfig, error: adminConfigError } = await supabaseAdmin
        .from('mercado_pago_configs')
        .select('id') // Just need any ID to represent the admin
        .eq('id', 1)
        .single();

      if (adminConfigError || !adminConfig) {
        console.warn('Mercado Pago Webhook: Admin Mercado Pago config not found for logging financial entry. Using generic admin ID.');
      }
      const adminUserId = adminConfig?.id ? String(adminConfig.id) : '00000000-0000-0000-0000-000000000000'; // Fallback to a generic ID

      // Create new entry in admin_financial_entries
      const { error: financialEntryError } = await supabaseAdmin
        .from('admin_financial_entries')
        .insert({
          admin_user_id: adminUserId, // The admin who owns the platform
          subscriber_id: charge.user_id, // The user who paid
          description: `Pagamento PIX - RenovaÃ§Ã£o de Assinatura (${subscription.plan_name})`,
          value: transactionAmount, // Use transactionAmount from MP response
          type: 'credit',
        });

      if (financialEntryError) {
        console.error('Mercado Pago Webhook: Error creating admin financial entry:', financialEntryError.message);
        // Do not throw, as the core payment processing is done
      }

      console.log(`Mercado Pago Webhook: Subscription ${subscription.id} renewed and financial entry created.`);
    } else if (mpPaymentStatus === 'rejected' || mpPaymentStatus === 'cancelled' || mpPaymentStatus === 'refunded') {
      console.log(`Mercado Pago Webhook: Processing ${mpPaymentStatus} status for charge ${paymentId}.`);
      const { error: updateChargeError } = await supabaseAdmin
        .from('mercado_pago_charges')
        .update({ status: mpPaymentStatus })
        .eq('id', charge.id);

      if (updateChargeError) {
        console.error(`Mercado Pago Webhook: Error updating mercado_pago_charges status to ${mpPaymentStatus}:`, updateChargeError.message);
      }
    } else {
      console.log(`Mercado Pago Webhook: Charge ${paymentId} status is ${charge.status} in DB, received ${mpPaymentStatus}. No action taken.`);
    }

    return new Response(JSON.stringify({ success: true, message: 'Webhook processed.' }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });

  } catch (error: any) {
    console.error('Edge Function: Error in mercado-pago-webhook-receiver:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/pagbank-create-charge/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseAdmin = createClient(
    // @ts-ignore
    Deno.env.get('SUPABASE_URL') ?? '',
    // @ts-ignore
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  try {
    console.log('pagbank-create-charge: Function started.');

    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      console.error('pagbank-create-charge: Unauthorized - Missing Authorization header.');
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      console.error('pagbank-create-charge: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    const userId = user.id;
    console.log('pagbank-create-charge: User authenticated, userId:', userId);

    const { subscription_id, amount } = await req.json();
    console.log(`pagbank-create-charge: Received payload: subscription_id=${subscription_id}, amount=${amount}`);

    if (!subscription_id || !amount) {
      console.error('pagbank-create-charge: Missing subscription_id or amount in payload.');
      return new Response(JSON.stringify({ error: 'Missing subscription_id or amount.' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    // 1. Fetch PagBank credentials and environment
    console.log('pagbank-create-charge: Fetching PagBank configs...');
    const { data: pagbankConfig, error: configError } = await supabaseAdmin
      .from('pagbank_configs')
      .select('pagbank_email, pagbank_token, pagbank_pix_key, environment') // NOVO: Incluir 'environment'
      .eq('id', 1)
      .single();

    if (configError || !pagbankConfig) {
      console.error('pagbank-create-charge: PagBank config not found:', configError?.message);
      return new Response(JSON.stringify({ error: 'PagBank configuration not found. Please contact support.' }), {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('pagbank-create-charge: PagBank config fetched successfully. Environment:', pagbankConfig.environment); // NOVO: Log do ambiente

    // NOVO: Definir a URL base da API PagBank com base no ambiente
    const baseUrl = pagbankConfig.environment === 'production'
      ? 'https://api.pagseguro.com'
      : 'https://sandbox.api.pagseguro.com';
    const pagbankApiUrl = `${baseUrl}/orders`; // Usar a baseUrl dinÃ¢mica
    console.log('pagbank-create-charge: Using PagBank API URL:', pagbankApiUrl);


    // 2. Fetch subscription details to get plan_name for description
    console.log('pagbank-create-charge: Fetching subscription details...');
    const { data: subscription, error: subscriptionError } = await supabaseAdmin
      .from('subscriptions')
      .select('plan_name')
      .eq('id', subscription_id)
      .single();

    if (subscriptionError || !subscription) {
      console.error('pagbank-create-charge: Subscription not found:', subscriptionError?.message);
      return new Response(JSON.stringify({ error: 'Subscription not found for the provided ID.' }), {
        status: 404,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('pagbank-create-charge: Subscription details fetched successfully. Plan Name:', subscription.plan_name);

    // 2.1. Fetch customer data from profiles (including phone and new tax_id)
    console.log('pagbank-create-charge: Fetching customer profile...');
    const { data: profile, error: profileError } = await supabaseAdmin
      .from('profiles')
      .select('name, email, phone, tax_id') // IncluÃ­do o novo campo tax_id
      .eq('id', userId)
      .single();

    if (profileError || !profile) {
      console.error('pagbank-create-charge: Customer profile not found for userId:', userId, profileError?.message);
      return new Response(JSON.stringify({ error: 'Perfil do usuÃ¡rio nÃ£o encontrado.' }), {
        status: 404,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('pagbank-create-charge: Customer profile fetched successfully. Name:', profile.name);

    // ValidaÃ§Ã£o e limpeza do tax_id do perfil
    const cleanedTaxId = profile.tax_id?.replace(/\D/g, '');
    if (!cleanedTaxId || (cleanedTaxId.length !== 11 && cleanedTaxId.length !== 14)) {
      console.error('pagbank-create-charge: Invalid or missing CPF/CNPJ in user profile:', profile.tax_id);
      return new Response(JSON.stringify({ error: 'CPF/CNPJ invÃ¡lido ou ausente no perfil do usuÃ¡rio. Por favor, atualize seu perfil.' }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // 3. Build CORRECT PagBank API Payload (based on Pedido.pdf)
    const amountInCents = Math.round(amount * 100); // PagBank expects amount in cents

    const pagbankRequestBody: any = {
      reference_id: `sub-${subscription_id}-${Date.now()}`, // Unique reference for tracking
      customer: {
        name: profile.name,
        email: profile.email,
        tax_id: cleanedTaxId, // Usando o tax_id limpo e validado do perfil
      },
      items: [
        {
          name: `Assinatura ${subscription.plan_name}`,
          quantity: 1,
          unit_amount: amountInCents,
        },
      ],
      qr_codes: [
        {
          amount: {
            value: amountInCents,
          },
          expiration_date: new Date(Date.now() + 3600 * 1000).toISOString(), // 1 hour expiration
        },
      ],
      notification_urls: [
        // @ts-ignore
        `${Deno.env.get('SUPABASE_URL')}/functions/v1/pagbank-webhook-receiver` // CORRIGIDO: Usando SUPABASE_URL
      ],
    };

    // Populate customer phones conditionally
    const cleanedPhone = profile.phone?.replace(/\D/g, '');
    if (cleanedPhone && cleanedPhone.length >= 10 && cleanedPhone.startsWith('55')) { // Basic validation for BR phone
      const areaCode = cleanedPhone.substring(2, 4); // Assuming 55DD
      const phoneNumber = cleanedPhone.substring(4); // Rest of the number
      pagbankRequestBody.customer.phones = [
        {
          country: "55",
          area: areaCode,
          number: phoneNumber,
          type: "MOBILE" // Assuming mobile phone
        }
      ];
    }

    console.log('pagbank-create-charge: Sending request to PagBank API with body:', JSON.stringify(pagbankRequestBody, null, 2));

    const pagbankResponse = await fetch(pagbankApiUrl, { // Usar pagbankApiUrl dinÃ¢mica
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${pagbankConfig.pagbank_token}`,
        'x-api-version': '2024-03-01' // As suggested, or check latest PagBank docs
      },
      body: JSON.stringify(pagbankRequestBody),
    });

    const pagbankResponseData = await pagbankResponse.json();
    console.log('pagbank-create-charge: PagBank API raw response:', JSON.stringify(pagbankResponseData, null, 2));

    if (!pagbankResponse.ok) {
      console.error('pagbank-create-charge: PagBank API error response:', pagbankResponseData);
      const errorMessage = pagbankResponseData.message || pagbankResponseData.error_messages?.[0]?.description || `Falha ao criar cobranÃ§a PIX no PagBank: ${pagbankResponse.statusText}`;
      throw new Error(errorMessage);
    }

    // 4. Extract data from PagBank response (for /orders endpoint)
    const pagbankChargeId = pagbankResponseData.id;
    // CORRIGIDO: ExtraÃ§Ã£o da URL da imagem do QR Code
    const qrCodeImageUrl = pagbankResponseData.qr_codes?.[0]?.links?.find((link: any) => link.rel === 'QRCODE.PNG')?.href;
    const qrCodeText = pagbankResponseData.qr_codes?.[0]?.text;

    if (!pagbankChargeId || !qrCodeImageUrl || !qrCodeText) {
      console.error('pagbank-create-charge: Missing required data in PagBank response:', pagbankResponseData);
      throw new Error('Dados essenciais (ID da cobranÃ§a, QR Code) nÃ£o encontrados na resposta do PagBank.');
    }
    console.log('pagbank-create-charge: PagBank response parsed successfully. Charge ID:', pagbankChargeId);

    // 5. Save charge details to pagbank_charges
    console.log('pagbank-create-charge: Inserting charge into pagbank_charges...');
    const { data: newCharge, error: insertError } = await supabaseAdmin
      .from('pagbank_charges')
      .insert({
        user_id: userId,
        subscription_id: subscription_id,
        pagbank_charge_id: pagbankChargeId,
        status: 'PENDING',
        value: amount,
      })
      .select()
      .single();

    if (insertError) {
      console.error('pagbank-create-charge: Error inserting PagBank charge:', insertError.message);
      throw new Error(`Failed to record PagBank charge: ${insertError.message}`);
    }
    console.log('pagbank-create-charge: Charge inserted successfully, newChargeId:', newCharge.id);

    const responsePayload = {
      pagbank_charge_id: newCharge.pagbank_charge_id,
      qr_code_image_url: qrCodeImageUrl,
      qr_code_text: qrCodeText,
      value: amount,
    };
    console.log('pagbank-create-charge: Returning response:', JSON.stringify(responsePayload));

    return new Response(JSON.stringify(responsePayload), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });

  } catch (error: any) {
    console.error('pagbank-create-charge: Unhandled error in Edge Function:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/pagbank-webhook-receiver/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';
// @ts-ignore
import { DateTime } from 'https://esm.sh/luxon@3.4.4';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseAdmin = createClient(
    // @ts-ignore
    Deno.env.get('SUPABASE_URL') ?? '',
    // @ts-ignore
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  try {
    const payload = await req.json();
    console.log('PagBank Webhook received payload:', JSON.stringify(payload, null, 2));

    // Mock PagBank payload structure for demonstration
    // In a real scenario, you would parse the actual PagBank webhook payload
    const pagbankChargeId = payload.charge_id || payload.id; // Assuming charge_id or id is present
    const pagbankStatus = payload.status; // Assuming status is 'PAID', 'PENDING', 'EXPIRED'

    if (!pagbankChargeId || !pagbankStatus) {
      console.error('PagBank Webhook: Missing charge_id or status in payload.');
      return new Response(JSON.stringify({ error: 'Missing charge_id or status in payload.' }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // 1. Find the corresponding charge in pagbank_charges
    const { data: charge, error: chargeError } = await supabaseAdmin
      .from('pagbank_charges')
      .select('id, user_id, subscription_id, status, value')
      .eq('pagbank_charge_id', pagbankChargeId)
      .single();

    if (chargeError || !charge) {
      console.error(`PagBank Webhook: Charge ${pagbankChargeId} not found in DB or error:`, chargeError?.message);
      return new Response(JSON.stringify({ error: `Charge ${pagbankChargeId} not found.` }), {
        status: 404,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // 2. Process if status is PAID and current DB status is PENDING
    if (pagbankStatus === 'PAID' && charge.status === 'PENDING') {
      console.log(`PagBank Webhook: Processing PAID status for charge ${pagbankChargeId}.`);

      // Update status in pagbank_charges
      const { error: updateChargeError } = await supabaseAdmin
        .from('pagbank_charges')
        .update({ status: 'PAID' })
        .eq('id', charge.id);

      if (updateChargeError) {
        console.error('PagBank Webhook: Error updating pagbank_charges status:', updateChargeError.message);
        throw new Error(`Failed to update charge status: ${updateChargeError.message}`);
      }

      // Get subscription details
      const { data: subscription, error: subError } = await supabaseAdmin
        .from('subscriptions')
        .select('id, user_id, plan_name, price, next_billing_date, subscriber_plans(period_days)')
        .eq('id', charge.subscription_id)
        .single();

      if (subError || !subscription) {
        console.error('PagBank Webhook: Subscription not found or error:', subError?.message);
        throw new Error(`Subscription ${charge.subscription_id} not found.`);
      }

      const planData = Array.isArray(subscription.subscriber_plans) ? subscription.subscriber_plans[0] : subscription.subscriber_plans;
      const periodDays = planData?.period_days;

      if (!periodDays) {
        console.error('PagBank Webhook: Plan period_days not found for subscription:', subscription.id);
        throw new Error(`Plan period_days not found for subscription ${subscription.id}.`);
      }

      // Calculate new next_billing_date
      const currentDueDate = DateTime.fromISO(subscription.next_billing_date, { zone: 'local' }).startOf('day');
      const newNextBillingDate = currentDueDate.plus({ days: periodDays }).toISODate();

      // Update subscription
      const { error: updateSubError } = await supabaseAdmin
        .from('subscriptions')
        .update({ next_billing_date: newNextBillingDate, status: 'active' })
        .eq('id', subscription.id);

      if (updateSubError) {
        console.error('PagBank Webhook: Error updating subscription:', updateSubError.message);
        throw new Error(`Failed to update subscription: ${updateSubError.message}`);
      }

      // Get admin_user_id from pagbank_configs (assuming the admin who set it up is the one to log revenue)
      const { data: adminConfig, error: adminConfigError } = await supabaseAdmin
        .from('pagbank_configs')
        .select('id') // Just need any ID to represent the admin
        .eq('id', 1)
        .single();

      if (adminConfigError || !adminConfig) {
        console.warn('PagBank Webhook: Admin PagBank config not found for logging financial entry. Using generic admin ID.');
      }
      const adminUserId = adminConfig?.id ? String(adminConfig.id) : '00000000-0000-0000-0000-000000000000'; // Fallback to a generic ID

      // Create new entry in admin_financial_entries
      const { error: financialEntryError } = await supabaseAdmin
        .from('admin_financial_entries')
        .insert({
          admin_user_id: adminUserId, // The admin who owns the platform
          subscriber_id: charge.user_id, // The user who paid
          description: `Pagamento PIX - RenovaÃ§Ã£o de Assinatura (${subscription.plan_name})`,
          value: charge.value,
          type: 'credit',
        });

      if (financialEntryError) {
        console.error('PagBank Webhook: Error creating admin financial entry:', financialEntryError.message);
        // Do not throw, as the core payment processing is done
      }

      console.log(`PagBank Webhook: Subscription ${subscription.id} renewed and financial entry created.`);
    } else if (pagbankStatus === 'EXPIRED' && charge.status === 'PENDING') {
      console.log(`PagBank Webhook: Processing EXPIRED status for charge ${pagbankChargeId}.`);
      const { error: updateChargeError } = await supabaseAdmin
        .from('pagbank_charges')
        .update({ status: 'EXPIRED' })
        .eq('id', charge.id);

      if (updateChargeError) {
        console.error('PagBank Webhook: Error updating pagbank_charges status to EXPIRED:', updateChargeError.message);
      }
    } else {
      console.log(`PagBank Webhook: Charge ${pagbankChargeId} status is ${charge.status} in DB, received ${pagbankStatus}. No action taken.`);
    }

    return new Response(JSON.stringify({ success: true, message: 'Webhook processed.' }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });

  } catch (error: any) {
    console.error('Edge Function: Error in pagbank-webhook-receiver:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/populate-send-queue/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

// @ts-ignore
import { addDays, format, startOfDay } from 'https://esm.sh/date-fns@3.6.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Define the type for the client rows fetched from the database
interface ClientRow {
  id: string;
  user_id: string;
  next_billing_date: string;
  status: 'active' | 'inactive' | 'overdue'; // Assuming these are the enum values
}

// Define the type for automation rows fetched from the database
interface AutomationRow {
  id: string;
  user_id: string;
  days_offset: number;
  template_id: string;
  client_ids: string[];
  created_at: string;
  updated_at: string;
}

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    console.log('Edge Function: populate-send-queue started.');

    const today = startOfDay(new Date());
    // Removed: const todayFormatted = format(today, 'yyyy-MM-dd');

    // 1. Buscar todas as regras de automaÃ§Ã£o
    // This function is called by a cron job, so it needs to process all users' automations.
    // RLS on automations table will ensure only admins can see all, but the service role bypasses RLS.
    const { data: automationsData, error: automationsError } = await supabaseAdmin
      .from('automations')
      .select('*');

    if (automationsError) throw automationsError;
    console.log(`Edge Function: Found ${automationsData?.length || 0} automations.`);

    if (!automationsData || automationsData.length === 0) {
      return new Response(JSON.stringify({ message: 'No automations found to process.' }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      });
    }

    const automations: AutomationRow[] = automationsData as AutomationRow[];

    // 2. Buscar todos os clientes ativos ou vencidos
    // This function is called by a cron job, so it needs to process all users' clients.
    // RLS on clients table will ensure only admins can see all, but the service role bypasses RLS.
    const { data: clientsData, error: clientsError } = await supabaseAdmin
      .from('clients')
      .select('id, user_id, next_billing_date, status');

    if (clientsError) throw clientsError;
    console.log(`Edge Function: Found ${clientsData?.length || 0} clients.`);

    // Cast clientsData to the defined ClientRow type
    const clients: ClientRow[] = clientsData as ClientRow[];
    const clientsMap = new Map(clients.map(c => [c.id, c]));

    const pendingSendsToInsert: any[] = [];

    // 3. Processar Regras
    for (const automation of automations) {
      for (const clientId of automation.client_ids) {
        const client = clientsMap.get(clientId);

        // Ensure the client belongs to the automation's user_id
        if (!client || client.user_id !== automation.user_id || (client.status !== 'active' && client.status !== 'overdue')) {
          // Ignorar clientes nÃ£o encontrados, nÃ£o pertencentes ao usuÃ¡rio da automaÃ§Ã£o, ou inativos
          continue;
        }

        const nextBillingDate = new Date(client.next_billing_date + 'T00:00:00'); // Tratar como data local
        const scheduledFor = addDays(nextBillingDate, automation.days_offset);
        const scheduledForFormatted = format(scheduledFor, 'yyyy-MM-dd');

        // CondiÃ§Ã£o: Se a scheduled_for calculada for hoje ou uma data no futuro
        if (scheduledFor >= today) {
          pendingSendsToInsert.push({
            user_id: client.user_id,
            client_id: client.id,
            automation_id: automation.id,
            template_id: automation.template_id,
            scheduled_for: scheduledForFormatted,
          });
        }
      }
    }

    if (pendingSendsToInsert.length > 0) {
      const { error: insertError } = await supabaseAdmin
        .from('pending_sends')
        .upsert(pendingSendsToInsert, { 
          onConflict: 'client_id,automation_id,scheduled_for',
          ignoreDuplicates: true 
        });

      if (insertError) throw insertError;
      console.log(`Edge Function: Successfully inserted/skipped ${pendingSendsToInsert.length} pending sends.`);
    } else {
      console.log('Edge Function: No new pending sends to insert.');
    }

    return new Response(JSON.stringify({ message: 'Send queue populated successfully.' }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (error: any) {
    console.error('Edge Function: Error populating send queue:', error.message);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred in populate-send-queue.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/process-queue-and-send/index.ts ---
// @ts-ignore
/// <reference lib="deno.ns" />
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

// @ts-ignore
import { DateTime } from 'https://esm.sh/luxon@3.4.4'; // Use Luxon

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Definindo a interface para o objeto de notificaÃ§Ã£o
interface NotificationItem {
  id: string;
  user_id: string; // Adicionado para logs
}

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  // 1. SeguranÃ§a: Verificar o segredo do cron
  // @ts-ignore
  const cronSecret = Deno.env.get('CRON_SECRET');
  const authHeader = req.headers.get('Authorization');
  if (!cronSecret || authHeader !== `Bearer ${cronSecret}`) {
    console.warn('process-queue-and-send: Unauthorized access attempt.');
    return new Response('Unauthorized', { status: 401, headers: corsHeaders });
  }

  try {
    console.log('process-queue-and-send: Function started.');
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    // POLÃTICA DE TIMEZONE: Sempre trabalhar em UTC no backend
    const currentTime = DateTime.now().toUTC(); // Use Luxon for current UTC time
    const currentTimeISO = currentTime.toISO();
    console.log(`process-queue-and-send: Current UTC time for comparison: ${currentTimeISO}`);
    console.log(`process-queue-and-send: Current UTC timestamp: ${currentTime.toMillis()}`);

    // 2. Buscar notificaÃ§Ãµes pendentes que jÃ¡ devem ser enviadas
    // IMPORTANTE: send_at jÃ¡ estÃ¡ em UTC (salvo pelo frontend via Luxon)
    // This function is called by a cron job, so it needs to process all users' scheduled notifications.
    // RLS on scheduled_notifications table will ensure only admins can see all, but the service role bypasses RLS.
    const { data: notifications, error } = await supabaseAdmin
      .from('scheduled_notifications')
      .select('id, user_id, send_at, client_id, clients(name)') // Adiciona client info para logs
      .eq('status', 'pending')
      .lte('send_at', currentTimeISO)
      .order('send_at', { ascending: true });

    if (error) {
      console.error('process-queue-and-send: Error fetching pending notifications:', error.message);
      throw error;
    }
    
    console.log(`process-queue-and-send: Found ${notifications?.length || 0} notifications where send_at <= ${currentTimeISO}`);
    
    if (notifications && notifications.length > 0) {
      notifications.forEach((n: any) => { 
        const sendAtDateTime = DateTime.fromISO(n.send_at, { zone: 'utc' }); // Parse send_at as UTC
        const clientData = Array.isArray(n.clients) ? n.clients[0] : n.clients;
        const clientName = clientData?.name || 'Unknown';
        const delayMinutes = Math.round((currentTime.diff(sendAtDateTime, 'minutes').minutes)); // Luxon diff
        console.log(`  - ID: ${n.id}, Client: ${clientName}, User: ${n.user_id}, Send at: ${n.send_at} UTC (${delayMinutes} minutes ago)`);
      });
    }
    
    if (!notifications || notifications.length === 0) {
      console.log('process-queue-and-send: No notifications to process at this time.');
      return new Response(JSON.stringify({ message: 'No notifications to process.' }), {
        status: 200,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    // 3. Invocar a funÃ§Ã£o de envio para cada notificaÃ§Ã£o
    const sendPromises = notifications.map(async (notification: NotificationItem) => {
      const notifStartTime = DateTime.now().toUTC().toISO(); // Use Luxon
      console.log(`\nð process-queue-and-send: Starting to process notification ID: ${notification.id}`);
      console.log(`   User: ${notification.user_id}, Started at: ${notifStartTime}`);
      
      // Atualizar status para 'processing'
      const { error: updateError } = await supabaseAdmin
        .from('scheduled_notifications')
        .update({ status: 'processing' })
        .eq('id', notification.id);

      if (updateError) {
        console.error(`â process-queue-and-send: Error updating status to 'processing' for ID ${notification.id}:`, updateError.message);
        // Continuar mesmo com erro de update, para tentar invocar a funÃ§Ã£o de envio
      } else {
        console.log(`â process-queue-and-send: Notification ID ${notification.id} status updated to 'processing'`);
      }
      
      // Invocar a outra Edge Function
      console.log(`ð¤ process-queue-and-send: Invoking send-scheduled-notification for ID ${notification.id}...`);
      const invokeStartTime = DateTime.now(); // Use Luxon
      
      const { data: invokeData, error: invokeError } = await supabaseAdmin.functions.invoke('send-scheduled-notification', {
        body: { id: notification.id },
      });

      const invokeEndTime = DateTime.now(); // Use Luxon
      const invokeDuration = invokeEndTime.diff(invokeStartTime, 'milliseconds').milliseconds; // Luxon diff

      if (invokeError) {
        console.error(`â process-queue-and-send: Error invoking send-scheduled-notification for ID ${notification.id}:`);
        console.error(`   Error message: ${invokeError.message}`);
        console.error(`   Duration: ${invokeDuration}ms`);
        // A funÃ§Ã£o send-scheduled-notification jÃ¡ lida com a atualizaÃ§Ã£o para 'failed' e loga o erro.
      } else {
        console.log(`â process-queue-and-send: Successfully invoked send-scheduled-notification for ID ${notification.id}`);
        console.log(`   Duration: ${invokeDuration}ms`);
        console.log(`   Response:`, JSON.stringify(invokeData));
      }
    });

    await Promise.all(sendPromises);
    console.log(`process-queue-and-send: Finished processing ${notifications.length} notifications.`);

    return new Response(JSON.stringify({ message: `Processed ${notifications.length} notifications.` }), {
      status: 200,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });

  } catch (err: any) {
    console.error('process-queue-and-send: Unhandled error in Edge Function:', err.message);
    return new Response(JSON.stringify({ error: err.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/renew-subscriber-subscription/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

// @ts-ignore
import { DateTime } from 'https://esm.sh/luxon@3.4.4';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: adminRoleData, error: adminRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (adminRoleError || adminRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const { subscriptionId, targetUserId, planName, currentNextBillingDate, price } = await req.json();

    if (!subscriptionId || !targetUserId || !planName || !currentNextBillingDate || price === undefined) {
      return new Response(JSON.stringify({ error: 'Missing required fields for subscription renewal.' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    // 1. Fetch subscriber plan details to get period_days
    const { data: planData, error: planError } = await supabaseAdmin
      .from('subscriber_plans')
      .select('period_days')
      .eq('name', planName)
      .single();

    if (planError || !planData) {
      console.error('Edge Function: Error fetching subscriber plan:', planError?.message || 'Plan not found');
      throw new Error(`Subscriber plan "${planName}" not found.`);
    }

    const periodDays = planData.period_days;

    // 2. Calculate new next_billing_date using Luxon
    const currentDueDate = DateTime.fromISO(currentNextBillingDate, { zone: 'local' }).startOf('day');
    const newNextBillingDate = currentDueDate.plus({ days: periodDays }).toISODate();

    // 3. Update subscription
    const { data: updatedSubscription, error: updateError } = await supabaseAdmin
      .from('subscriptions')
      .update({ next_billing_date: newNextBillingDate, status: 'active' })
      .eq('id', subscriptionId)
      .eq('user_id', targetUserId)
      .select()
      .single();

    if (updateError) throw updateError;

    // NOVO: Buscar o nome do assinante
    const { data: subscriberProfile, error: profileError } = await supabaseAdmin
      .from('profiles')
      .select('name')
      .eq('id', targetUserId)
      .single();

    const subscriberName = subscriberProfile?.name || 'Assinante Desconhecido';

    // 4. Record financial entry
    const { error: financialEntryError } = await supabaseAdmin
      .from('admin_financial_entries')
      .insert({
        admin_user_id: user.id,
        subscriber_id: targetUserId,
        description: `RenovaÃ§Ã£o de Assinatura - ${planName} (${subscriberName})`, // DescriÃ§Ã£o atualizada
        value: price,
        type: 'credit',
      });

    if (financialEntryError) {
      console.error('Edge Function: Error recording financial entry:', financialEntryError.message);
      // Do not throw, as subscription update is more critical
    }

    return new Response(JSON.stringify({ success: true, data: updatedSubscription }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (error: any) {
    console.error('Edge Function: Error in renew-subscriber-subscription:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/schedule-notifications-for-rule/index.ts ---
// @ts-ignore
/// <reference lib="deno.ns" />
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Define a interface para o payload que a Edge Function espera
interface EdgeFunctionPayload {
  automationId: string;
  notifications: {
    user_id: string; // Adicionado para consistÃªncia com o frontend
    client_id: string;
    template_id: string;
    automation_id: string;
    send_at: string; // ISO string UTC, jÃ¡ calculada pelo frontend
    status: 'pending'; // Sempre 'pending' ao inserir
  }[];
}

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseAdmin = createClient(
    // @ts-ignore
    Deno.env.get('SUPABASE_URL') ?? '',
    // @ts-ignore
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  let userId: string | null = null; // Para logs e RLS
  let automationIdForLog: string | null = null;

  try {
    console.log('schedule-notifications-for-rule: Function started.');

    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      console.error('schedule-notifications-for-rule: Unauthorized - Missing Authorization header.');
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    // Usar o cliente Supabase com o token do usuÃ¡rio para obter o user.id
    const supabaseClientForUser = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabaseClientForUser.auth.getUser();
    if (userError || !user) {
      console.error('schedule-notifications-for-rule: User authentication failed:', userError?.message);
      throw new Error(userError?.message || 'User not authenticated');
    }
    userId = user.id;
    console.log(`schedule-notifications-for-rule: Authenticated user: ${userId}`);

    const { automationId, notifications }: EdgeFunctionPayload = await req.json();
    automationIdForLog = automationId;
    console.log(`schedule-notifications-for-rule: Received request for automationId: ${automationId} with ${notifications?.length || 0} notifications.`);

    if (!automationId || !notifications) {
      console.error('schedule-notifications-for-rule: automationId and notifications array are required.');
      throw new Error('automationId and notifications array are required.');
    }

    // â POLÃTICA UTC: Validar que todas as datas estÃ£o em formato UTC vÃ¡lido
    const nowUtc = new Date();
    for (const notification of notifications) {
      const sendAtDate = new Date(notification.send_at);
      
      // Verificar se Ã© uma data vÃ¡lida
      if (isNaN(sendAtDate.getTime())) {
        console.error(`schedule-notifications-for-rule: Invalid send_at date: ${notification.send_at}`);
        throw new Error(`Invalid send_at date for client ${notification.client_id}`);
      }
      
      // Verificar se estÃ¡ no futuro (com margem de 1 minuto para evitar descartes por latÃªncia de rede)
      if (sendAtDate.getTime() < nowUtc.getTime() - 60000) {
        console.warn(`schedule-notifications-for-rule: Skipping past notification: ${notification.send_at} (now: ${nowUtc.toISOString()}) for client ${notification.client_id}`);
      }
    }
    
    console.log(`schedule-notifications-for-rule: Scheduling ${notifications.length} notifications for automation ${automationId}:`);
    notifications.forEach(n => {
      console.log(`  â Client ${n.client_id}: send_at=${n.send_at} UTC`);
    });

    // 1. Delete existing pending scheduled notifications for this automation and user
    console.log(`schedule-notifications-for-rule: Attempting to delete existing pending notifications for automation ${automationId}.`);
    // Service role bypasses RLS, but we still filter by user_id to ensure data integrity.
    const { error: deleteError } = await supabaseAdmin
      .from('scheduled_notifications')
      .delete()
      .eq('automation_id', automationId)
      .eq('user_id', userId) // Garante que o usuÃ¡rio sÃ³ delete seus prÃ³prios agendamentos
      .eq('status', 'pending');

    if (deleteError) {
      console.error(`schedule-notifications-for-rule: Failed to delete existing pending notifications: ${deleteError.message}`);
      throw new Error(`Failed to delete existing pending notifications: ${deleteError.message}`);
    }
    console.log(`schedule-notifications-for-rule: Successfully deleted existing pending notifications for automation ${automationId}.`);

    // 2. Insert new scheduled notifications
    if (notifications.length > 0) {
      // Adiciona o status 'pending' e o user_id a cada notificaÃ§Ã£o antes de inserir
      const notificationsToInsert = notifications.map(n => ({
        ...n,
        user_id: userId, // Garante que o user_id estÃ¡ correto
        automation_id: automationId, // Garante que o automation_id estÃ¡ correto
        status: 'pending',
      }));

      // Service role bypasses RLS, but we still ensure user_id is set correctly.
      const { error: insertError } = await supabaseAdmin
        .from('scheduled_notifications')
        .insert(notificationsToInsert);

      if (insertError) {
        console.error(`schedule-notifications-for-rule: Failed to insert scheduled notifications: ${insertError.message}`);
        throw new Error(`Failed to insert scheduled notifications: ${insertError.message}`);
      }
      console.log(`schedule-notifications-for-rule: Successfully inserted ${notificationsToInsert.length} scheduled notifications.`);
    } else {
      console.log('schedule-notifications-for-rule: No new notifications to insert.');
    }

    return new Response(JSON.stringify({ success: true, message: 'Notifications scheduled successfully.', count: notifications.length }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });

  } catch (error: any) {
    console.error(`schedule-notifications-for-rule: An unexpected error occurred for automation ${automationIdForLog || 'N/A'}: ${error.message}`);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/schedule-subscriber-notifications/index.ts ---
// @ts-ignore
/// <reference lib="deno.ns" />
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

// @ts-ignore
import { DateTime } from 'https://esm.sh/luxon@3.4.4'; // Import Luxon for timezone handling

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Define a interface para o payload que a Edge Function espera
interface EdgeFunctionPayload {
  automationId: string;
  notifications: {
    user_id: string; // ID do assinante (user_id da tabela auth.users)
    subscriber_template_id: string;
    send_at: string; // ISO string UTC
    status: 'pending'; // Sempre 'pending' ao inserir
  }[];
}

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseAdmin = createClient(
    // @ts-ignore
    Deno.env.get('SUPABASE_URL') ?? '',
    // @ts-ignore
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  let adminUserId: string | null = null; // Para logs e RLS
  let automationIdForLog: string | null = null;

  try {
    console.log('schedule-subscriber-notifications: Function started.');

    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      console.error('schedule-subscriber-notifications: Unauthorized - Missing Authorization header.');
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    // Usar o cliente Supabase com o token do usuÃ¡rio para obter o user.id
    const supabaseClientForUser = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabaseClientForUser.auth.getUser();
    if (userError || !user) {
      console.error('schedule-subscriber-notifications: User authentication failed:', userError?.message);
      throw new Error(userError?.message || 'User not authenticated');
    }
    adminUserId = user.id;
    console.log(`schedule-subscriber-notifications: Authenticated admin user: ${adminUserId}`);

    // Verify admin role
    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', adminUserId)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', adminUserId);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');


    const { automationId, notifications }: EdgeFunctionPayload = await req.json();
    automationIdForLog = automationId;
    console.log(`schedule-subscriber-notifications: Received request for automationId: ${automationId} with ${notifications?.length || 0} notifications.`);

    if (!automationId || !notifications) {
      console.error('schedule-subscriber-notifications: automationId and notifications array are required.');
      throw new Error('automationId and notifications array are required.');
    }

    // Validar que todas as datas estÃ£o em formato UTC vÃ¡lido
    const nowUtc = DateTime.now().toUTC();
    for (const notification of notifications) {
      const sendAtDateTime = DateTime.fromISO(notification.send_at, { zone: 'utc' });
      
      if (!sendAtDateTime.isValid) {
        console.error(`schedule-subscriber-notifications: Invalid send_at date: ${notification.send_at}`);
        throw new Error(`Invalid send_at date for subscriber ${notification.user_id}`);
      }
      
      // Adicionar margem de 1 minuto para evitar descartes por latÃªncia de rede
      if (sendAtDateTime < nowUtc.minus({ minutes: 1 })) {
        console.warn(`schedule-subscriber-notifications: Skipping past notification: ${notification.send_at} (now: ${nowUtc.toISO()}) for subscriber ${notification.user_id}`);
      }
    }
    
    console.log(`schedule-subscriber-notifications: Scheduling ${notifications.length} notifications for subscriber automation ${automationId}:`);
    notifications.forEach(n => {
      console.log(`  â Subscriber ${n.user_id}: send_at=${n.send_at} UTC`);
    });

    // 1. Delete existing pending scheduled notifications for this automation and type
    console.log(`schedule-subscriber-notifications: Attempting to delete existing pending subscriber notifications for automation ${automationId}.`);
    const { error: deleteError } = await supabaseAdmin
      .from('scheduled_notifications')
      .delete()
      .eq('automation_id', automationId)
      .eq('type', 'subscriber_notification') // Filter by the new type
      .eq('user_id', adminUserId) // Ensure admin only deletes their own subscriber automations
      .eq('status', 'pending');

    if (deleteError) {
      console.error(`schedule-subscriber-notifications: Failed to delete existing pending notifications: ${deleteError.message}`);
      throw new Error(`Failed to delete existing pending notifications: ${deleteError.message}`);
    }
    console.log(`schedule-subscriber-notifications: Successfully deleted existing pending subscriber notifications for automation ${automationId}.`);

    // 2. Insert new scheduled notifications
    if (notifications.length > 0) {
      const notificationsToInsert = notifications.map(n => ({
        user_id: n.user_id, // This is the subscriber's user_id
        client_id: n.user_id, // For subscriber notifications, client_id is the subscriber's user_id
        template_id: n.subscriber_template_id,
        automation_id: automationId,
        send_at: n.send_at,
        status: 'pending',
        type: 'subscriber_notification', // Set the new type
      }));

      const { error: insertError } = await supabaseAdmin
        .from('scheduled_notifications')
        .insert(notificationsToInsert);

      if (insertError) {
        console.error(`schedule-subscriber-notifications: Failed to insert scheduled notifications: ${insertError.message}`);
        throw new Error(`Failed to insert scheduled notifications: ${insertError.message}`);
      }
      console.log(`schedule-subscriber-notifications: Successfully inserted ${notificationsToInsert.length} scheduled notifications.`);
    } else {
      console.log('schedule-subscriber-notifications: No new notifications to insert.');
    }

    return new Response(JSON.stringify({ success: true, message: 'Subscriber notifications scheduled successfully.', count: notifications.length }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });

  } catch (error: any) {
    console.error(`schedule-subscriber-notifications: An unexpected error occurred for automation ${automationIdForLog || 'N/A'}: ${error.message}`);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/send-scheduled-notification/index.ts ---
// @ts-ignore
/// <reference lib="deno.ns" />
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseAdmin = createClient(
    // @ts-ignore
    Deno.env.get('SUPABASE_URL') ?? '',
    // @ts-ignore
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  );

  let scheduledNotificationId: string | null = null;
  let userId: string | null = null;
  let clientId: string | null = null;
  let templateId: string | null = null;
  let n8nWebhookUrl: string | null = null;
  let statusCode: number | null = null;
  let errorMessage: string = 'An unknown error occurred.';
  let requestBody: any = {};
  let responseBody: any = null;
  let clientNameForLog: string = 'Unknown Client';
  let instanceName: string | null = null; // VariÃ¡vel para armazenar o instanceName

  try {
    const currentTimeStart = new Date().toISOString();
    console.log(`send-scheduled-notification: Function started at ${currentTimeStart}`);
    const { id } = await req.json();
    scheduledNotificationId = id;
    console.log(`send-scheduled-notification: Received request for scheduledNotificationId: ${scheduledNotificationId}`);

    if (!scheduledNotificationId) {
      errorMessage = 'Scheduled notification ID is required.';
      console.error(`send-scheduled-notification: ${errorMessage}`);
      throw new Error(errorMessage);
    }

    // Fetch scheduled notification details
    // Service role bypasses RLS, so no explicit user_id filter needed here.
    const { data: notification, error: notificationError } = await supabaseAdmin
      .from('scheduled_notifications')
      .select(`
        user_id,
        client_id,
        template_id,
        clients(name, phone, value, next_billing_date, plans(name)),
        templates(name, content)
      `)
      .eq('id', scheduledNotificationId)
      .single();

    if (notificationError || !notification) {
      errorMessage = `Failed to fetch scheduled notification: ${notificationError?.message || 'Not found'}`;
      console.error(`send-scheduled-notification: ${errorMessage}`);
      throw new Error(errorMessage);
    }

    userId = notification.user_id;
    clientId = notification.client_id;
    templateId = notification.template_id;
    const client = Array.isArray(notification.clients) ? notification.clients[0] : notification.clients;
    const template = Array.isArray(notification.templates) ? notification.templates[0] : notification.templates;

    if (!client) {
      errorMessage = 'Client not found for scheduled notification.';
      console.error(`send-scheduled-notification: ${errorMessage}`);
      throw new Error(errorMessage);
    }
    if (!template) {
      errorMessage = 'Template not found for scheduled notification.';
      console.error(`send-scheduled-notification: ${errorMessage}`);
      throw new Error(errorMessage);
    }

    clientNameForLog = client.name;
    const scheduledFor = notification.send_at || 'unknown';
    const delayFromScheduled = new Date().getTime() - new Date(scheduledFor).getTime();
    const delayMinutes = Math.round(delayFromScheduled / 60000);
    console.log(`send-scheduled-notification: Processing notification ID ${scheduledNotificationId}`);
    console.log(`  â Client: ${clientNameForLog}`);
    console.log(`  â Template: ${template.name}`);
    console.log(`  â Scheduled for: ${scheduledFor} UTC`);
    console.log(`  â Delay: ${delayMinutes} minutes`);

    // --- NOVO: Buscar o instanceName do usuÃ¡rio ---
    // Service role bypasses RLS, so no explicit user_id filter needed here.
    const { data: userInstance, error: instanceError } = await supabaseAdmin
      .from('user_instances')
      .select('instance_name')
      .eq('user_id', userId)
      .single();

    if (instanceError || !userInstance?.instance_name) {
      errorMessage = `User ${userId} does not have an active instance configured. Skipping notification.`;
      console.error(`send-scheduled-notification: ${errorMessage}`);
      // NÃ£o lanÃ§ar erro aqui, mas atualizar o status da notificaÃ§Ã£o para 'failed' e logar.
      // O bloco finally cuidarÃ¡ do log e da atualizaÃ§Ã£o de status.
      statusCode = 412; // Precondition Failed, ou um cÃ³digo customizado para "instÃ¢ncia nÃ£o configurada"
      throw new Error(errorMessage); // LanÃ§a para ir para o bloco finally
    }
    instanceName = userInstance.instance_name;
    console.log(`send-scheduled-notification: Instance Name for user ${userId}: ${instanceName}`);

    // Fetch n8n webhook URL (global config, no user_id filter needed)
    const { data: webhookConfig, error: webhookError } = await supabaseAdmin
      .from('webhook_configs')
      .select('url')
      .eq('type', 'n8n_message_sender')
      .maybeSingle();

    if (webhookError || !webhookConfig?.url) {
      errorMessage = `N8N message sender webhook URL not configured. Configure in Webhooks page.`;
      console.error(`send-scheduled-notification: ${errorMessage}`);
      throw new Error(errorMessage);
    }
    n8nWebhookUrl = webhookConfig.url;
    console.log(`send-scheduled-notification: N8N Webhook URL: ${n8nWebhookUrl}`);

    // --- NOVO: Buscar a chave PIX do perfil do usuÃ¡rio ---
    const { data: userProfile, error: profileError } = await supabaseAdmin
      .from('profiles')
      .select('pix_key')
      .eq('id', userId)
      .single();

    if (profileError && profileError.code !== 'PGRST116') { // PGRST116 = No rows found
      console.error(`send-scheduled-notification: Error fetching user profile for pix_key: ${profileError.message}`);
    }
    const pixKey = userProfile?.pix_key || 'Chave PIX nÃ£o cadastrada';
    console.log(`send-scheduled-notification: User PIX Key: ${pixKey}`);

    // Variable substitution
    let renderedText = template.content;
    renderedText = renderedText.replaceAll('{{customer_name}}', client.name);
    
    // â POLÃTICA UTC: next_billing_date jÃ¡ estÃ¡ no formato YYYY-MM-DD (data local sem timezone)
    // NÃ£o precisa converter timezone, apenas formatar para pt-BR
    const dueDate = new Date(client.next_billing_date + 'T00:00:00');
    const formattedDate = dueDate.toLocaleDateString('pt-BR', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric'
    });
    renderedText = renderedText.replaceAll('{{due_date}}', formattedDate);
    
    const planData = Array.isArray(client.plans) ? client.plans[0] : client.plans;
    renderedText = renderedText.replaceAll('{{plan_name}}', planData?.name || 'Plano Desconhecido');
    renderedText = renderedText.replaceAll('{{value}}', new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(client.value));
    renderedText = renderedText.replaceAll('{{pix_key}}', pixKey); // --- NOVO: SubstituiÃ§Ã£o da chave PIX ---
    console.log(`send-scheduled-notification: Rendered message: ${renderedText}`);

    requestBody = {
      body: [
        {
          instanceName: instanceName, // --- NOVO: Adicionado o instanceName aqui ---
          contact_name: client.name,
          number: client.phone, // Assumindo que o formato jÃ¡ Ã© adequado para WhatsApp
          text: renderedText,
          mode: "real"
        }
      ]
    };
    console.log(`send-scheduled-notification: Sending payload to n8n: ${JSON.stringify(requestBody)}`);

    // Send message via n8n webhook
    if (!n8nWebhookUrl) {
      errorMessage = 'N8N webhook URL is null or undefined before fetch.';
      console.error(`send-scheduled-notification: ${errorMessage}`);
      throw new Error(errorMessage);
    }
    const response = await fetch(n8nWebhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody),
    });

    statusCode = response.status;
    console.log(`send-scheduled-notification: N8N Webhook response status: ${statusCode}`);

    // Tenta ler o corpo da resposta, seja sucesso ou erro
    try {
      responseBody = await response.json();
    } catch (jsonError) {
      // Se nÃ£o for JSON, tenta ler como texto
      responseBody = await response.text();
      console.warn(`send-scheduled-notification: N8N response was not JSON, read as text. Error: ${jsonError}`);
    }
    console.log(`send-scheduled-notification: N8N Webhook response body: ${JSON.stringify(responseBody)}`);


    if (!response.ok) {
      errorMessage = String(responseBody?.message || response.statusText || `Automation server returned an error with status ${statusCode}.`);
      console.error(`send-scheduled-notification: N8N Webhook error response: ${JSON.stringify(responseBody)}`);
      throw new Error(errorMessage);
    }

    // Update scheduled notification status to 'sent'
    const { error: updateSentError } = await supabaseAdmin
      .from('scheduled_notifications')
      .update({ status: 'sent' })
      .eq('id', scheduledNotificationId);
    
    if (updateSentError) {
      console.error(`send-scheduled-notification: Error updating status to 'sent': ${updateSentError.message}`);
    } else {
      console.log(`send-scheduled-notification: â Notification ${scheduledNotificationId} marked as 'sent' successfully`);
    }

    // Log to n8n_message_sender_history (NOVA TABELA)
    const { error: historyInsertError } = await supabaseAdmin
      .from('n8n_message_sender_history') // Alterado para a nova tabela
      .insert({
        user_id: userId,
        client_id: clientId,
        template_id: templateId,
        webhook_type: 'n8n_message_outbound_automated',
        payload: requestBody,
        request_payload: requestBody,
        response_payload: responseBody,
        status_code: statusCode,
        client_name_snapshot: clientNameForLog, // Save client name snapshot
      });
    
    if (historyInsertError) {
      console.error(`send-scheduled-notification: Error logging to n8n_message_sender_history: ${historyInsertError.message}`);
    } else {
      console.log(`send-scheduled-notification: â Logged to n8n_message_sender_history for ${scheduledNotificationId}`);
    }

    return new Response(JSON.stringify({ success: true, message: 'Notification sent successfully.' }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });

  } catch (error: any) {
    console.error(`send-scheduled-notification: Error processing notification ${scheduledNotificationId} for client ${clientNameForLog}: ${error.message}`);
    errorMessage = String(error.message);

    // Update scheduled notification status to 'failed'
    if (scheduledNotificationId) {
      await supabaseAdmin
        .from('scheduled_notifications')
        .update({ status: 'failed' })
        .eq('id', scheduledNotificationId);
      console.log(`send-scheduled-notification: Scheduled notification ${scheduledNotificationId} status updated to 'failed'.`);
    }

    // Log error to n8n_message_sender_history (NOVA TABELA)
    if (userId) {
      await supabaseAdmin
        .from('n8n_message_sender_history') // Alterado para a nova tabela
        .insert({
          user_id: userId,
          client_id: clientId,
          template_id: templateId,
          webhook_type: 'n8n_message_outbound_automated',
          payload: requestBody,
          request_payload: requestBody,
          response_payload: responseBody,
          status_code: statusCode || 500,
          client_name_snapshot: clientNameForLog, // Save client name snapshot even on error
        });
      console.log(`send-scheduled-notification: Logged error to n8n_message_sender_history for ${scheduledNotificationId}.`);
    }

    return new Response(JSON.stringify({ error: errorMessage || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/set-subscriber-due-today/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

// @ts-ignore
import { DateTime } from 'https://esm.sh/luxon@3.4.4';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: adminRoleData, error: adminRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (adminRoleError || adminRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const { subscriptionId, targetUserId, currentStatus, price } = await req.json();

    if (!subscriptionId || !targetUserId || !currentStatus || price === undefined) {
      return new Response(JSON.stringify({ error: 'Missing required fields for setting due date to today.' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    // 1. Calculate today's date in YYYY-MM-DD format (local)
    const todayDate = DateTime.local().toISODate();

    // 2. Determine new status
    const newStatus = currentStatus === 'inactive' ? 'active' : currentStatus;

    // 3. Update subscription
    const { data: updatedSubscription, error: updateError } = await supabaseAdmin
      .from('subscriptions')
      .update({ next_billing_date: todayDate, status: newStatus })
      .eq('id', subscriptionId)
      .eq('user_id', targetUserId)
      .select()
      .single();

    if (updateError) throw updateError;

    // 4. Record financial entry (optional, but good for tracking)
    // REMOVIDO: A criaÃ§Ã£o de entrada financeira para "Vencimento para Hoje"
    // const { error: financialEntryError } = await supabaseAdmin
    //   .from('admin_financial_entries')
    //   .insert({
    //     admin_user_id: user.id,
    //     subscriber_id: targetUserId,
    //     description: `Vencimento para Hoje - Assinatura`,
    //     value: price, // Assuming this is a payment received
    //     type: 'credit',
    //   });

    // if (financialEntryError) {
    //   console.error('Edge Function: Error recording financial entry:', financialEntryError.message);
    //   // Do not throw, as subscription update is more critical
    // }

    return new Response(JSON.stringify({ success: true, data: updatedSubscription }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (error: any) {
    console.error('Edge Function: Error in set-subscriber-due-today:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/update-user-instance-status/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: adminRoleData, error: adminRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (adminRoleError || adminRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const { instanceId, newStatus } = await req.json();

    if (!instanceId || !newStatus) {
      return new Response(JSON.stringify({ error: 'Missing instanceId or newStatus.' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    // Update the user_instances table
    const { data, error } = await supabaseAdmin
      .from('user_instances')
      .update({ status: newStatus, qr_code_base64: newStatus === 'connecting' ? null : undefined }) // Clear QR code if setting to connecting
      .eq('id', instanceId)
      .select()
      .single();

    if (error) throw error;

    return new Response(JSON.stringify({ success: true, data }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (error: any) {
    console.error('Edge Function: Error in update-user-instance-status:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/update-user-role/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      console.error('Edge Function: User authentication failed:', userError?.message);
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: User authenticated, userId:', user.id);

    // Fetch user role using service role to bypass RLS for user_roles table
    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: adminRoleData, error: adminRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (adminRoleError || adminRoleData?.role !== 'admin') {
      console.warn('Edge Function: Unauthorized access attempt by non-admin user:', user.id);
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }
    console.log('Edge Function: Admin user confirmed.');

    const { targetUserId, newRole } = await req.json();

    if (!targetUserId || !newRole) {
      return new Response(JSON.stringify({ error: 'Missing targetUserId or newRole.' }), { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    // Primeiro, tenta atualizar a role do usuÃ¡rio existente
    let { data, error } = await supabaseAdmin
      .from('user_roles')
      .update({ role: newRole }) // Apenas atualiza a role
      .eq('user_id', targetUserId) // Filtra pelo usuÃ¡rio especÃ­fico
      .select()
      .single(); // Espera encontrar um Ãºnico registo

    // Se o update falhar porque o user_id nÃ£o existe (error.code === 'PGRST116'),
    // entÃ£o insere um novo registo
    if (error && error.code === 'PGRST116') { // PGRST116: No rows found
        console.warn(`Edge Function: User role not found for user ${targetUserId}, attempting insert.`);
        const { data: insertData, error: insertError } = await supabaseAdmin
            .from('user_roles')
            .insert({ user_id: targetUserId, role: newRole })
            .select()
            .single();

        if (insertError) throw insertError; // LanÃ§a o erro de inserÃ§Ã£o se falhar
        data = insertData; // Usa os dados da inserÃ§Ã£o para o retorno
    } else if (error) {
        // Se houve outro erro durante o update, lanÃ§a o erro
        throw error;
    }

    return new Response(JSON.stringify({ success: true, data }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (error: any) {
    console.error('Edge Function: Error in update-user-role:', error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: supabase/functions/update-user-subscription/index.ts ---
// @ts-ignore
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
// @ts-ignore
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.45.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response('Unauthorized', { status: 401, headers: corsHeaders });
    }

    const token = authHeader.replace('Bearer ', '');
    const supabase = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: `Bearer ${token}` },
        },
      }
    );

    const { data: { user }, error: userError } = await supabase.auth.getUser();

    if (userError || !user) {
      return new Response(JSON.stringify({ error: userError?.message || 'User not authenticated' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    const supabaseAdmin = createClient(
      // @ts-ignore
      Deno.env.get('SUPABASE_URL') ?? '',
      // @ts-ignore
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: userRoleData, error: userRoleError } = await supabaseAdmin
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (userRoleError || userRoleData?.role !== 'admin') {
      return new Response(JSON.stringify({ error: 'Access denied: Admin role required.' }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    if (req.method === 'POST') {
      const { subscriptionId, userId, plan_name, price, status, next_billing_date } = await req.json();

      // Basic validation for always required fields
      if (!subscriptionId || !userId || !plan_name || price === undefined || status === undefined) {
        return new Response(JSON.stringify({ error: 'Missing required fields for subscription update.' }), {
          status: 400,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        });
      }

      // Fetch the subscriber plan to check if it's free
      const { data: subscriberPlan, error: planError } = await supabaseAdmin
        .from('subscriber_plans')
        .select('is_free')
        .eq('name', plan_name)
        .single();

      if (planError) {
        return new Response(JSON.stringify({ error: `Failed to fetch plan details: ${planError.message}` }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        });
      }

      const isFreePlan = subscriberPlan?.is_free || false;

      // Adjusted validation for next_billing_date and price based on isFreePlan
      if (!isFreePlan) {
        if (next_billing_date === null || next_billing_date === undefined) {
          return new Response(JSON.stringify({ error: 'Next billing date is required for non-free plans.' }), {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          });
        }
        if (price <= 0) {
          return new Response(JSON.stringify({ error: 'Price must be positive for non-free plans.' }), {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          });
        }
      } else { // If it's a free plan, ensure price is 0 and next_billing_date is null
        if (price !== 0) {
          return new Response(JSON.stringify({ error: 'Price must be 0 for free plans.' }), {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          });
        }
        if (next_billing_date !== null) {
          return new Response(JSON.stringify({ error: 'Next billing date must be null for free plans.' }), {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          });
        }
      }

      const { data, error } = await supabaseAdmin
        .from('subscriptions')
        .update({
          plan_name,
          price,
          status,
          next_billing_date,
        })
        .eq('id', subscriptionId)
        .eq('user_id', userId)
        .select()
        .single();

      if (error) {
        throw error;
      }

      // Log financial entry for price changes or new subscriptions (if not free)
      if (price > 0) {
        const { error: financialEntryError } = await supabaseAdmin
          .from('admin_financial_entries')
          .insert({
            admin_user_id: user.id,
            subscriber_id: userId,
            description: `AtualizaÃ§Ã£o de assinatura para ${plan_name}`,
            value: price,
            type: 'income', // Assuming it's an income for the admin
          });

        if (financialEntryError) {
          console.error('Error inserting financial entry:', financialEntryError.message);
          // Don't throw, as subscription update is more critical
        }
      }

      return new Response(JSON.stringify(data), {
        status: 200,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    return new Response('Method Not Allowed', {
      status: 405,
      headers: corsHeaders,
    });
  } catch (error: any) {
    console.error('Edge Function: Error in update-user-subscription:', error.message, error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred.' }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
--- ConteÃºdo de: src/pages/Auth.tsx ---
import { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { supabase } from "@/integrations/supabase/client";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { toast } from "sonner";
import { z } from "zod";

const authSchema = z.object({
  email: z.string().email("E-mail invÃ¡lido"),
  password: z.string().min(6, "Senha deve ter no mÃ­nimo 6 caracteres"),
  name: z.string().min(2, "Nome deve ter no mÃ­nimo 2 caracteres").optional(),
});

export default function Auth() {
  const navigate = useNavigate();
  const [loading, setLoading] = useState(false);
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [name, setName] = useState("");

  useEffect(() => {
    const checkSession = async () => {
      const { data: { session } } = await supabase.auth.getSession();
      if (session) {
        navigate("/dashboard");
      }
    };

    checkSession();

    const { data: { subscription } } = supabase.auth.onAuthStateChange((_, session) => {
      if (session) {
        navigate("/dashboard");
      }
    });

    return () => subscription.unsubscribe();
  }, [navigate]);

  const handleSignIn = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      authSchema.omit({ name: true }).parse({ email, password });

      const { error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });

      if (error) throw error;

      toast.success("Login realizado com sucesso!", { description: "VocÃª serÃ¡ redirecionado..." });
    } catch (error: any) {
      if (error instanceof z.ZodError) {
        toast.error("Erro de validaÃ§Ã£o", { description: error.errors[0].message });
      } else {
        let description = error.message;
        if (error.message === 'Email not confirmed') {
          description = 'Seu e-mail ainda nÃ£o foi confirmado. Por favor, verifique sua caixa de entrada.';
        } else if (error.message === 'Invalid login credentials') {
          description = 'Credenciais de login invÃ¡lidas. Verifique seu e-mail e senha.';
        }
        toast.error("Erro ao fazer login", { description });
      }
    } finally {
      setLoading(false);
    }
  };

  const handleSignUp = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      authSchema.parse({ email, password, name });

      const { error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          emailRedirectTo: `${window.location.origin}/dashboard`,
          data: {
            name,
          },
        },
      });

      if (error) throw error;

      toast.success("Cadastro realizado!", { description: "Verifique seu e-mail para validar sua conta antes de fazer login." });
    } catch (error: any) {
      if (error instanceof z.ZodError) {
        toast.error("Erro de validaÃ§Ã£o", { description: error.errors[0].message });
      } else {
        toast.error("Erro ao criar conta", { description: error.message });
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center p-4">
      <div className="w-full max-w-md">
        <div className="text-center mb-8">
          <div className="inline-flex items-center justify-center w-16 h-16 rounded-2xl bg-gradient-to-br from-primary to-primary-glow mb-4 shadow-glow">
            <span className="text-2xl font-bold text-primary-foreground">AC</span>
          </div>
          <h1 className="text-3xl font-bold text-foreground">Acerto Certo</h1>
          <p className="text-muted-foreground mt-2">Sistema de CobranÃ§a e Gerenciamento</p>
        </div>

        <Card className="border-border bg-card shadow-lg">
          <CardHeader>
            <CardTitle>Bem-vindo</CardTitle>
            <CardDescription>Entre ou crie sua conta para continuar</CardDescription>
          </CardHeader>
          <CardContent>
            <Tabs defaultValue="signin" className="w-full">
              <TabsList className="grid w-full grid-cols-2 mb-4">
                <TabsTrigger value="signin">Entrar</TabsTrigger>
                <TabsTrigger value="signup">Cadastrar</TabsTrigger>
              </TabsList>

              <TabsContent value="signin">
                <form onSubmit={handleSignIn} className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="signin-email">E-mail</Label>
                    <Input
                      id="signin-email"
                      type="email"
                      placeholder="seu@email.com"
                      value={email}
                      onChange={(e) => setEmail(e.target.value)}
                      required
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="signin-password">Senha</Label>
                    <Input
                      id="signin-password"
                      type="password"
                      placeholder="â¢â¢â¢â¢â¢â¢â¢â¢"
                      value={password}
                      onChange={(e) => setPassword(e.target.value)}
                      required
                    />
                  </div>
                  <Button type="submit" className="w-full" disabled={loading}>
                    {loading ? "Entrando..." : "Entrar"}
                  </Button>
                </form>
              </TabsContent>

              <TabsContent value="signup">
                <form onSubmit={handleSignUp} className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="signup-name">Nome</Label>
                    <Input
                      id="signup-name"
                      type="text"
                      placeholder="Seu nome"
                      value={name}
                      onChange={(e) => setName(e.target.value)}
                      required
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="signup-email">E-mail</Label>
                    <Input
                      id="signup-email"
                      type="email"
                      placeholder="seu@email.com"
                      value={email}
                      onChange={(e) => setEmail(e.target.value)}
                      required
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="signup-password">Senha</Label>
                    <Input
                      id="signup-password"
                      type="password"
                      placeholder="â¢â¢â¢â¢â¢â¢â¢â¢"
                      value={password}
                      onChange={(e) => setPassword(e.target.value)}
                      required
                    />
                  </div>
                  <Button type="submit" className="w-full" disabled={loading}>
                    {loading ? "Criando conta..." : "Criar conta"}
                  </Button>
                </form>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
        <footer className="mt-8 text-center text-xs text-slate-500">
          <p>Desenvolvido por <br/> {" "}
            <a 
              href="https://digitalsouloficial.vercel.app/" 
              target="_blank" 
              rel="noopener noreferrer" 
              className="font-semibold text-slate-400 hover:underline"
            >
              Digital Soul Solutions
            </a>
          </p>
          <p className="mt-1">CNPJ: 58.870.696/0001-97</p>
        </footer>
      </div>
    </div>
  );
}
--- ConteÃºdo de: src/pages/Automations.tsx ---
import { DateTime } from 'luxon';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Table, TableBody, TableHead, TableHeader, TableRow, TableCell } from '@/components/ui/table';
import { useTemplates } from '@/hooks/useTemplates';
import { useClients } from '@/hooks/useClients';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { Automation, AutomationInsert, AutomationUpdate, Client } from '@/integrations/supabase/schema';
import { toast } from 'sonner';
import { PlusCircle as PlusCircleIcon, Search as SearchIcon, Trash2, Users } from 'lucide-react';
import { useEffect, useState, useMemo } from 'react';
import { useAuth } from '@/contexts/AuthContext';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Checkbox } from '@/components/ui/checkbox';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from '@/components/ui/alert-dialog';

// --- HOOKS DE DADOS REAIS ---

// Fetch Automations
const fetchAutomations = async (userId: string, userRole: string | null): Promise<Automation[]> => {
  let query = supabase
    .from('automations')
    .select('*')
    .order('created_at', { ascending: true });

  // Aplica o filtro APENAS se o usuÃ¡rio NÃO for admin
  if (userRole !== 'admin') {
    query = query.eq('user_id', userId);
  }

  const { data, error } = await query;

  if (error) throw new Error(error.message);
  return data || [];
};

export const useAutomations = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();

  return useQuery<Automation[], Error>({
    queryKey: ['automations', user?.id, role],
    queryFn: () => {
      if (!user?.id) throw new Error("UsuÃ¡rio nÃ£o autenticado");
      return fetchAutomations(user.id, role);
    },
    enabled: !isLoadingAuth && !!user?.id,
  });
};

// Interface para o payload que a Edge Function espera
interface EdgeFunctionNotificationPayload {
  client_id: string;
  template_id: string;
  send_at: string; // ISO string UTC
}

// Interface para o payload da mutaÃ§Ã£o no frontend
interface ScheduleNotificationsForRuleMutationPayload {
  automation: Automation;
  clients: Client[];
}

const scheduleNotificationsForRule = async (payload: ScheduleNotificationsForRuleMutationPayload) => {
  const { automation, clients } = payload;
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const notificationsToInsert: EdgeFunctionNotificationPayload[] = [];
  const SAO_PAULO_TIMEZONE = 'America/Sao_Paulo';
  const [scheduledHour, scheduledMinute] = automation.scheduled_time.split(':').map(Number);
  const now = DateTime.now();

  // Filtra apenas clientes ativos ou vencidos que estÃ£o na automaÃ§Ã£o
  const relevantClients = clients.filter(c => 
    automation.client_ids.includes(c.id) && (c.status === 'active' || c.status === 'overdue')
  );

  for (const client of relevantClients) {
    if (!client.next_billing_date) continue;

    // A data do Supabase vem como 'YYYY-MM-DD'. Adicionar T00:00:00 para tratar como data local.
    const localBillingDate = DateTime.fromISO(client.next_billing_date, { zone: SAO_PAULO_TIMEZONE }).startOf('day');
    const targetDate = localBillingDate.plus({ days: automation.days_offset });
    
    // Cria a data/hora final no fuso horÃ¡rio local (SÃ£o Paulo) usando Luxon
    const localTargetDateTime = targetDate.set({
        hour: scheduledHour,
        minute: scheduledMinute
    });

    // Converte para UTC e obtÃ©m a string ISO
    const sendAtUtcIso = localTargetDateTime.toUTC().toISO();

    // Adicionar verificaÃ§Ã£o para sendAtUtcIso ser null
    if (!sendAtUtcIso) {
        console.warn(`Skipping notification for client ${client.id} due to invalid date/time conversion.`);
        continue;
    }

    // Adiciona Ã  lista se a data for no futuro (ou no mÃ¡ximo 1 minuto no passado para tolerÃ¢ncia)
    if (localTargetDateTime.toMillis() >= now.toMillis() - (60 * 1000)) {
        notificationsToInsert.push({
            client_id: client.id,
            template_id: automation.template_id,
            send_at: sendAtUtcIso,
        });
    }
  }
  
  // Se nÃ£o houver nada a agendar, nÃ£o chama a funÃ§Ã£o da Edge Function
  if (notificationsToInsert.length === 0) {
      console.log("Nenhuma notificaÃ§Ã£o futura para agendar para esta regra.");
      return { success: true, message: 'Nenhuma notificaÃ§Ã£o futura para agendar.' };
  }

  // A URL da Edge Function
  const SUPABASE_PROJECT_ID = "cgqyfpsfymhntumrmbzj";
  const EDGE_FUNCTION_NAME = "schedule-notifications-for-rule";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  // O body da requisiÃ§Ã£o agora envia os agendamentos prontos
  const response = await fetch(EDGE_FUNCTION_URL, {
      method: "POST",
      headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${session.access_token}`,
      },
      body: JSON.stringify({ automationId: automation.id, notifications: notificationsToInsert }),
  });

  if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || "Erro ao invocar a Edge Function.");
  }

  return response.json();
};

export const useScheduleNotificationsForRule = () => {
  const queryClient = useQueryClient();
  return useMutation<any, Error, ScheduleNotificationsForRuleMutationPayload>({
    mutationFn: scheduleNotificationsForRule,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['scheduledNotifications'] });
      queryClient.invalidateQueries({ queryKey: ['connectionMetrics'] });
      toast.success('Fila de envios agendada com sucesso!');
    },
    onError: (error) => toast.error(`Erro ao agendar fila de envios: ${error.message}`),
  });
};

// Create Automation
export const useCreateAutomation = () => {
  const queryClient = useQueryClient();
  const scheduleMutation = useScheduleNotificationsForRule();
  const { data: clients } = useClients();

  return useMutation<Automation, Error, AutomationInsert>({
    mutationFn: async (newAutomationData) => {
      const { data: { user } = {} } = await supabase.auth.getUser();
      if (!user) throw new Error("UsuÃ¡rio nÃ£o autenticado");

      const { data, error } = await supabase
        .from('automations')
        .insert({ ...newAutomationData, user_id: user.id })
        .select()
        .single();

      if (error) throw new Error(error.message);
      return data as Automation;
    },
    onSuccess: async (newAutomation) => {
      queryClient.invalidateQueries({ queryKey: ['automations'] });
      queryClient.invalidateQueries({ queryKey: ['connectionMetrics'] });
      toast.success('AutomaÃ§Ã£o criada!');

      if (clients) {
        await scheduleMutation.mutateAsync({ 
          automation: newAutomation, 
          clients: clients 
        });
      }
    },
    onError: (error) => toast.error(`Erro ao criar automaÃ§Ã£o: ${error.message}`),
  });
};

// Update Automation
export const useUpdateAutomation = () => {
  const queryClient = useQueryClient();
  const scheduleMutation = useScheduleNotificationsForRule();
  const { data: clients } = useClients();

  return useMutation<Automation, Error, AutomationUpdate & { id: string }>({
    mutationFn: async (updatedAutomationData) => {
      const { id, ...updateData } = updatedAutomationData;
      const { data: { user } = {} } = await supabase.auth.getUser();
      if (!user) throw new Error("UsuÃ¡rio nÃ£o autenticado");

      const { data, error } = await supabase
        .from('automations')
        .update(updateData)
        .eq('id', id)
        .eq('user_id', user.id)
        .select()
        .single();

      if (error) throw new Error(error.message);
      return data as Automation;
    },
    onSuccess: async (updatedAutomation) => {
      queryClient.invalidateQueries({ queryKey: ['automations'] });
      queryClient.invalidateQueries({ queryKey: ['connectionMetrics'] });
      toast.success('AutomaÃ§Ã£o atualizada!');

      if (clients) {
        await scheduleMutation.mutateAsync({ 
          automation: updatedAutomation, 
          clients: clients 
        });
      }
    },
    onError: (error) => toast.error(`Erro ao atualizar automaÃ§Ã£o: ${error.message}`),
  });
};

// Delete Automation
const deleteAutomation = async (id: string): Promise<void> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("UsuÃ¡rio nÃ£o autenticado");

  // Deleta agendamentos pendentes associados a esta automaÃ§Ã£o
  await supabase
    .from('scheduled_notifications')
    .delete()
    .eq('automation_id', id)
    .eq('user_id', user.id);

  const { error } = await supabase
    .from('automations')
    .delete()
    .eq('id', id)
    .eq('user_id', user.id);

  if (error) throw new Error(error.message);
};

export const useDeleteAutomation = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string>({
    mutationFn: deleteAutomation,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['automations'] });
      queryClient.invalidateQueries({ queryKey: ['connectionMetrics'] });
      queryClient.invalidateQueries({ queryKey: ['scheduledNotifications'] });
      toast.success('AutomaÃ§Ã£o excluÃ­da e agendamentos removidos!');
    },
    onError: (error) => toast.error(`Erro ao excluir automaÃ§Ã£o: ${error.message}`),
  });
};

export default function AutomationsPage() {
  const { data: automations, isLoading: isLoadingAutomations, error: automationsError } = useAutomations();
  const { data: templates, isLoading: isLoadingTemplates, error: templatesError } = useTemplates();
  const { data: clients, isLoading: isLoadingClients, error: clientsError } = useClients();

  const createAutomationMutation = useCreateAutomation();
  const updateAutomationMutation = useUpdateAutomation();
  const deleteAutomationMutation = useDeleteAutomation();

  const [searchTerm, setSearchTerm] = useState('');
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [automationToDelete, setAutomationToDelete] = useState<Automation | null>(null);
  const [openPopovers, setOpenPopovers] = useState<Record<string, boolean>>({});
  const [tempClientSelections, setTempClientSelections] = useState<Record<string, string[]>>({});
  const [searchTermClients, setSearchTermClients] = useState<Record<string, string>>({}); // Novo estado para busca de clientes no popover

  useEffect(() => {
    if (automationsError) toast.error(`Erro ao carregar automaÃ§Ãµes: ${automationsError.message}`);
    if (templatesError) toast.error(`Erro ao carregar templates: ${templatesError.message}`);
    if (clientsError) toast.error(`Erro ao carregar clientes: ${clientsError.message}`);
  }, [automationsError, templatesError, clientsError]);

  const handleAddAutomation = async () => {
    if (!templates || templates.length === 0) {
      toast.error("Ã necessÃ¡rio ter pelo menos um template cadastrado para criar uma automaÃ§Ã£o.");
      return;
    }
    if (!clients || clients.length === 0) {
      toast.error("Ã necessÃ¡rio ter pelo menos um cliente cadastrado para criar uma automaÃ§Ã£o.");
      return;
    }

    try {
      const { data: { user } = {} } = await supabase.auth.getUser();
      if (!user) throw new Error("UsuÃ¡rio nÃ£o autenticado");

      await createAutomationMutation.mutateAsync({
        days_offset: -1,
        template_id: templates[0].id,
        client_ids: clients.filter((c: Client) => c.status === 'active').map((c: Client) => c.id),
        scheduled_time: '09:00:00',
        user_id: user.id,
      });
    } catch (error) {
      // Erro jÃ¡ tratado no onSuccess/onError do hook
    }
  };

  const isLoadingPage = isLoadingAutomations || isLoadingTemplates || isLoadingClients;

  const handleDeleteConfirm = async () => {
    if (!automationToDelete) return;
    try {
      await deleteAutomationMutation.mutateAsync(automationToDelete.id);
      toast.success("AutomaÃ§Ã£o excluÃ­da com sucesso!");
    } catch (err: any) {
      toast.error("Erro ao excluir automaÃ§Ã£o", { description: err.message });
    } finally {
      setDeleteDialogOpen(false);
      setAutomationToDelete(null);
    }
  };

  const handleOpenClientsPopover = (automationId: string, currentClientIds: string[]) => {
    setTempClientSelections(prev => ({ ...prev, [automationId]: currentClientIds }));
    setSearchTermClients(prev => ({ ...prev, [automationId]: '' })); // Reset search term when opening
    setOpenPopovers(prev => ({ ...prev, [automationId]: true }));
  };

  const handleSaveClients = (automationId: string) => {
    const selectedIds = tempClientSelections[automationId] || [];
    updateAutomationMutation.mutate({ id: automationId, client_ids: selectedIds });
    setOpenPopovers(prev => ({ ...prev, [automationId]: false }));
  };

  const handleToggleClient = (automationId: string, clientId: string) => {
    setTempClientSelections(prev => {
      const current = prev[automationId] || [];
      const updated = current.includes(clientId)
        ? current.filter(id => id !== clientId)
        : [...current, clientId];
      return { ...prev, [automationId]: updated };
    });
  };

  const handleSelectAllClients = (automationId: string, filteredActiveClients: Client[]) => {
    setTempClientSelections(prev => {
      const currentSelected = new Set(prev[automationId] || []);
      filteredActiveClients.forEach(client => currentSelected.add(client.id));
      return { ...prev, [automationId]: Array.from(currentSelected) };
    });
  };

  const handleDeselectAllClients = (automationId: string, filteredActiveClients: Client[]) => {
    setTempClientSelections(prev => {
      const currentSelected = new Set(prev[automationId] || []);
      filteredActiveClients.forEach(client => currentSelected.delete(client.id));
      return { ...prev, [automationId]: Array.from(currentSelected) };
    });
  };

  const offsetOptions = [
    { value: -7, label: '7 dias antes do vencimento' },
    { value: -5, label: '5 dias antes do vencimento' },
    { value: -3, label: '3 dias antes do vencimento' },
    { value: -2, label: '2 dias antes do vencimento' },
    { value: -1, label: '1 dia antes do vencimento' },
    { value: 0, label: 'No dia do vencimento' },
    { value: 1, label: '1 dia apÃ³s o vencimento' },
    { value: 2, label: '2 dias apÃ³s o vencimento' },
    { value: 3, label: '3 dias apÃ³s o vencimento' },
    { value: 5, label: '5 dias apÃ³s o vencimento' },
    { value: 7, label: '7 dias apÃ³s o vencimento' },
  ];

  // Filter automations based on search term
  const filteredAutomations = useMemo(() => {
    if (!automations) return [];
    if (!searchTerm) return automations;

    const lowerCaseSearchTerm = searchTerm.toLowerCase();
    return automations.filter(automation => {
      const templateName = templates?.find(t => t.id === automation.template_id)?.name.toLowerCase() || '';
      const clientNames = automation.client_ids.map(clientId => {
        return clients?.find(c => c.id === clientId)?.name.toLowerCase() || '';
      }).join(', ');

      return (
        automation.id.toLowerCase().includes(lowerCaseSearchTerm) ||
        templateName.includes(lowerCaseSearchTerm) ||
        clientNames.includes(lowerCaseSearchTerm) ||
        automation.days_offset.toString().includes(lowerCaseSearchTerm) ||
        automation.scheduled_time.includes(lowerCaseSearchTerm)
      );
    });
  }, [automations, searchTerm, templates, clients]);


  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-2xl sm:text-3xl font-bold text-foreground">AutomaÃ§Ãµes de Clientes</h1>
        <p className="text-muted-foreground mt-1">Configure regras para enviar mensagens automaticamente aos clientes da plataforma.</p>
      </div>

      <div className="flex flex-col sm:flex-row gap-4 justify-between">
        <div className="relative w-full sm:flex-1 sm:max-w-xs">
          <SearchIcon className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Buscar automaÃ§Ãµes..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="pl-10 text-sm"
          />
        </div>
        <Button onClick={handleAddAutomation} disabled={isLoadingPage || createAutomationMutation.isPending} className="w-full sm:w-auto">
          <PlusCircleIcon className="mr-2 h-4 w-4" />
          Nova Regra
        </Button>
      </div>

      {isLoadingPage ? (
        <Card className="border-border bg-card">
          <CardContent className="h-64 flex items-center justify-center">
            <p className="text-muted-foreground text-sm">Carregando automaÃ§Ãµes...</p>
          </CardContent>
        </Card>
      ) : filteredAutomations.length === 0 ? (
        <Card className="border-border bg-card">
          <CardContent className="flex flex-col items-center justify-center py-12">
            <p className="text-muted-foreground text-center text-sm">
              Nenhuma automaÃ§Ã£o encontrada com os filtros aplicados.
            </p>
          </CardContent>
        </Card>
      ) : (
        <div className="border rounded-lg overflow-x-auto">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead className="whitespace-nowrap text-xs sm:text-sm">Quando Enviar</TableHead>
                <TableHead className="whitespace-nowrap text-xs sm:text-sm">HorÃ¡rio</TableHead>
                <TableHead className="whitespace-nowrap text-xs sm:text-sm">Template da Mensagem</TableHead>
                <TableHead className="whitespace-nowrap text-xs sm:text-sm">Clientes Configurados</TableHead>
                <TableHead className="w-[50px] text-xs sm:text-sm"></TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredAutomations.map((automation) => {
                const activeClients = clients?.filter(c => c.status === 'active' || c.status === 'overdue') || [];
                const selectedCount = automation.client_ids.filter(id => activeClients.some(c => c.id === id)).length;
                const totalCount = activeClients.length;

                // Filter clients for the popover based on searchTermClients
                const filteredClientsForPopover = activeClients.filter(client =>
                  client.name.toLowerCase().includes(searchTermClients[automation.id]?.toLowerCase() || '')
                );
                const isAllFilteredSelected = filteredClientsForPopover.length > 0 && filteredClientsForPopover.every(client => (tempClientSelections[automation.id] || []).includes(client.id));


                return (
                  <TableRow key={automation.id}>
                    <TableCell className="text-xs sm:text-sm">
                      <Select
                        value={automation.days_offset.toString()}
                        onValueChange={(value) => {
                          updateAutomationMutation.mutate({
                            id: automation.id,
                            days_offset: parseInt(value),
                          });
                        }}
                      >
                        <SelectTrigger className="w-full min-w-[200px]">
                          <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                          {offsetOptions.map((option) => (
                            <SelectItem key={option.value} value={option.value.toString()}>
                              {option.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    </TableCell>

                    <TableCell className="text-xs sm:text-sm">
                      <Input
                        type="time"
                        value={automation.scheduled_time.slice(0, 5)}
                        onChange={(e) => {
                          const newTime = e.target.value + ':00';
                          updateAutomationMutation.mutate({
                            id: automation.id,
                            scheduled_time: newTime,
                          });
                        }}
                        className="w-full min-w-[120px]"
                      />
                    </TableCell>

                    <TableCell className="text-xs sm:text-sm">
                      <Select
                        value={automation.template_id}
                        onValueChange={(value) => {
                          updateAutomationMutation.mutate({
                            id: automation.id,
                            template_id: value,
                          });
                        }}
                      >
                        <SelectTrigger className="w-full min-w-[150px]">
                          <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                          {templates?.map((template) => (
                            <SelectItem key={template.id} value={template.id}>
                              {template.name}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    </TableCell>

                    <TableCell className="text-xs sm:text-sm">
                      <Popover
                        open={openPopovers[automation.id] || false}
                        onOpenChange={(open) => {
                          if (open) {
                            handleOpenClientsPopover(automation.id, automation.client_ids);
                          } else {
                            setOpenPopovers(prev => ({ ...prev, [automation.id]: false }));
                          }
                        }}
                      >
                        <PopoverTrigger asChild>
                          <Button variant="outline" className="w-full min-w-[140px] justify-start">
                            <Users className="mr-2 h-4 w-4" />
                            {selectedCount} / {totalCount} clientes
                          </Button>
                        </PopoverTrigger>
                        <PopoverContent className="w-80" align="start">
                          <div className="space-y-4">
                            <h4 className="font-medium text-sm">Selecionar Clientes</h4>
                            <div className="relative">
                              <SearchIcon className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                              <Input
                                placeholder="Buscar cliente..."
                                value={searchTermClients[automation.id] || ''}
                                onChange={(e) => setSearchTermClients(prev => ({ ...prev, [automation.id]: e.target.value }))}
                                className="pl-10 text-sm"
                              />
                            </div>
                            <div className="flex justify-between items-center text-sm">
                              <div className="flex items-center space-x-2">
                                <Checkbox
                                  id={`select-all-${automation.id}`}
                                  checked={isAllFilteredSelected}
                                  onCheckedChange={(checked) => {
                                    if (checked) {
                                      handleSelectAllClients(automation.id, filteredClientsForPopover);
                                    } else {
                                      handleDeselectAllClients(automation.id, filteredClientsForPopover);
                                    }
                                  }}
                                />
                                <label htmlFor={`select-all-${automation.id}`} className="font-medium cursor-pointer">
                                  Selecionar Todos
                                </label>
                              </div>
                              <Button
                                variant="link"
                                size="sm"
                                onClick={() => handleDeselectAllClients(automation.id, activeClients)}
                                className="text-xs p-0 h-auto"
                              >
                                Desmarcar Todos
                              </Button>
                            </div>
                            <div className="max-h-[300px] overflow-y-auto space-y-2">
                              {filteredClientsForPopover.length === 0 ? (
                                <p className="text-muted-foreground text-sm text-center">Nenhum cliente encontrado.</p>
                              ) : (
                                filteredClientsForPopover.map((client) => {
                                  const isChecked = (tempClientSelections[automation.id] || automation.client_ids).includes(client.id);
                                  return (
                                    <div key={client.id} className="flex items-center space-x-2">
                                      <Checkbox
                                        id={`${automation.id}-${client.id}`}
                                        checked={isChecked}
                                        onCheckedChange={() => handleToggleClient(automation.id, client.id)}
                                      />
                                      <label
                                        htmlFor={`${automation.id}-${client.id}`}
                                        className="text-sm flex-1 cursor-pointer"
                                      >
                                        {client.name}
                                      </label>
                                    </div>
                                  );
                                })
                              )}
                            </div>
                            <div className="flex gap-2 pt-2 border-t">
                              <Button
                                size="sm"
                                variant="outline"
                                onClick={() => setOpenPopovers(prev => ({ ...prev, [automation.id]: false }))}
                                className="flex-1"
                              >
                                Cancelar
                              </Button>
                              <Button
                                size="sm"
                                onClick={() => handleSaveClients(automation.id)}
                                className="flex-1"
                              >
                                Salvar
                              </Button>
                            </div>
                          </div>
                        </PopoverContent>
                      </Popover>
                    </TableCell>

                    <TableCell className="text-xs sm:text-sm">
                      <Button
                        variant="ghost"
                        size="icon"
                        onClick={() => {
                          setAutomationToDelete(automation);
                          setDeleteDialogOpen(true);
                        }}
                        className="text-destructive hover:text-destructive"
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    </TableCell>
                  </TableRow>
                );
              })}
            </TableBody>
          </Table>
        </div>
      )}

      <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Confirmar exclusÃ£o de automaÃ§Ã£o</AlertDialogTitle>
            <AlertDialogDescription>
              Tem certeza que deseja excluir a automaÃ§Ã£o? Esta aÃ§Ã£o Ã© irreversÃ­vel e removerÃ¡ todos os agendamentos futuros associados a ela.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancelar</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDeleteConfirm}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
              disabled={deleteAutomationMutation.isPending}
            >
              {deleteAutomationMutation.isPending ? "Excluindo..." : "Excluir AutomaÃ§Ã£o"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
--- ConteÃºdo de: src/pages/Clients.tsx ---
import { useEffect, useState } from "react";
import { supabase } from "@/integrations/supabase/client";
import { Button } from "@/components/ui/button";
import { Plus, Search, MoreHorizontal, Pencil, Trash2, ArrowUpDown, RefreshCw, Bell, Check, ListChecks, CalendarCheck } from "lucide-react";
import { Input } from "@/components/ui/input";
import { toast } from "sonner";
import { Badge } from "@/components/ui/badge";
import { ClientDialog } from "@/components/clients/ClientDialog";
import { NotificationDialog } from "@/components/clients/NotificationDialog";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
} from "@/components/ui/dropdown-menu";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { ClientStatus } from "@/integrations/supabase/schema"; // Importar ClientStatus do schema
import { Client, useClients, useDeleteClient, useRenewClient, useUpdateClientStatus, useSetClientDueToday } from "@/hooks/useClients"; // Corrigido: Importar Client do hook useClients
import { format } from "date-fns"; // Importar format para exibiÃ§Ã£o
import { Card, CardContent } from "@/components/ui/card"; // Importar Card e CardContent

type SortField = "name" | "due_date";
type SortOrder = "asc" | "desc";

export default function Clients() {
  const { data: clients, isLoading, error } = useClients();
  const deleteClientMutation = useDeleteClient();
  const renewClientMutation = useRenewClient();
  const updateClientStatusMutation = useUpdateClientStatus();
  const setClientDueTodayMutation = useSetClientDueToday();

  const [searchTerm, setSearchTerm] = useState("");
  const [statusFilter, setStatusFilter] = useState<string>("all");
  const [sortField, setSortField] = useState<SortField>("due_date");
  const [sortOrder, setSortOrder] = useState<SortOrder>("asc");
  const [dialogOpen, setDialogOpen] = useState(false);
  const [selectedClient, setSelectedClient] = useState<Client | null>(null);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [clientToDelete, setClientToDelete] = useState<Client | null>(null);
  const [notificationDialogOpen, setNotificationDialogOpen] = useState(false);
  const [clientToNotify, setClientToNotify] = useState<Client | null>(null);
  const [dueTodayDialogOpen, setDueTodayDialogOpen] = useState(false);
  const [clientToDueToday, setClientToDueToday] = useState<Client | null>(null);

  useEffect(() => {
    if (error) {
      toast.error("Erro ao carregar clientes", { description: error.message });
    }
  }, [error]);

  const filteredAndSortedClients = (clients || [])
    .filter((client) => {
      const matchesSearch =
        client.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        client.phone.includes(searchTerm);
      const matchesStatus = statusFilter === "all" || client.status === statusFilter;
      return matchesSearch && matchesStatus;
    })
    .sort((a, b) => {
      const multiplier = sortOrder === "asc" ? 1 : -1;
      if (sortField === "name") {
        return multiplier * a.name.localeCompare(b.name);
      }
      return multiplier * (new Date(a.next_billing_date).getTime() - new Date(b.next_billing_date).getTime());
    });

  const getStatusBadge = (status: string) => {
    const variants: Record<string, { label: string; variant: "default" | "secondary" | "destructive" }> = {
      active: { label: "Em dia", variant: "default" },
      inactive: { label: "Cancelado", variant: "secondary" },
      overdue: { label: "Atrasado", variant: "destructive" },
    };
    const config = variants[status] || variants.active;
    return <Badge variant={config.variant}>{config.label}</Badge>;
  };

  const handleRenewClient = async (client: Client) => {
    if (!client.plan_id) {
      toast.error("Erro ao renovar cliente", { description: "Cliente nÃ£o possui plano associado." });
      return;
    }

    try {
      const { data: planData, error: planError } = await supabase
        .from("plans")
        .select("period_days")
        .eq("id", client.plan_id)
        .single();

      if (planError) throw planError;
      if (!planData) throw new Error("Plano associado nÃ£o encontrado.");

      await renewClientMutation.mutateAsync({
        clientId: client.id,
        planPeriodDays: planData.period_days,
        currentNextBillingDate: client.next_billing_date,
        clientName: client.name,
        clientValue: client.value,
      });

      toast.success("Cliente renovado!", { description: `O cliente ${client.name} foi renovado com sucesso.` });
    } catch (error: any) {
      toast.error("Erro ao renovar cliente", { description: error.message });
    }
  };

  const handleChangeStatus = async (client: Client, newStatus: ClientStatus) => {
    try {
      await updateClientStatusMutation.mutateAsync({
        clientId: client.id,
        newStatus,
        clientName: client.name,
        planId: client.plan_id || '', // Garante que planId nÃ£o Ã© nulo
        planName: client.planDetailsValue ? `Plano de R$${client.planDetailsValue.toFixed(2)}` : 'Plano Desconhecido', // Placeholder ou buscar nome do plano
        clientValue: client.value,
      });

      toast.success("Status atualizado!", { description: "O status do cliente foi alterado com sucesso." });
    } catch (error: any) {
      toast.error("Erro ao mudar status", { description: error.message });
    }
  };

  const handleDueToday = (client: Client) => {
    setClientToDueToday(client);
    setDueTodayDialogOpen(true);
  };

  const handleConfirmDueToday = async () => {
    if (!clientToDueToday) return;

    try {
      await setClientDueTodayMutation.mutateAsync({
        clientId: clientToDueToday.id,
        clientName: clientToDueToday.name,
        currentStatus: clientToDueToday.status as ClientStatus,
      });

      toast.success("Vencimento alterado!", { description: `O vencimento de ${clientToDueToday.name} foi definido para hoje.` });
    } catch (error: any) {
      toast.error("Erro ao alterar vencimento", { description: error.message });
    } finally {
      setDueTodayDialogOpen(false);
      setClientToDueToday(null);
    }
  };

  const handleDeleteConfirm = async () => {
    if (!clientToDelete) return;

    try {
      await deleteClientMutation.mutateAsync(clientToDelete.id);
      toast.success("Cliente excluÃ­do", { description: "O cliente foi removido com sucesso." });
    } catch (error: any) {
      toast.error("Erro ao excluir cliente", { description: error.message });
    } finally {
      setDeleteDialogOpen(false);
      setClientToDelete(null);
    }
  };

  const toggleSort = (field: SortField) => {
    if (sortField === field) {
      setSortOrder(sortOrder === "asc" ? "desc" : "asc");
    } else {
      setSortField(field);
      setSortOrder("asc");
    }
  };

  const handleOpenDialog = (client?: Client) => {
    setSelectedClient(client || null);
    setDialogOpen(true);
  };

  const handleOpenNotificationDialog = (client: Client) => {
    setClientToNotify(client);
    setNotificationDialogOpen(true);
  };

  return (
    <div className="space-y-6">
      <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
        <div>
          <h1 className="text-2xl sm:text-3xl font-bold text-foreground">Clientes</h1>
          <p className="text-sm sm:text-base text-muted-foreground mt-1">Gerencie seus clientes e cobranÃ§as</p>
        </div>
        <Button onClick={() => handleOpenDialog()} className="gap-2 w-full sm:w-auto">
          <Plus className="h-4 w-4" />
          Novo Cliente
        </Button>
      </div>

      <div className="flex flex-col sm:flex-row gap-4">
        <div className="relative w-full sm:flex-1">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Buscar por nome ou telefone..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="pl-10 text-sm"
          />
        </div>
        <Select value={statusFilter} onValueChange={setStatusFilter}>
          <SelectTrigger className="w-full sm:w-[180px] text-sm">
            <SelectValue placeholder="Filtrar por status" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">Todos</SelectItem>
            <SelectItem value="active">Em dia</SelectItem>
            <SelectItem value="overdue">Atrasado</SelectItem>
            <SelectItem value="inactive">Cancelado</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {isLoading ? (
        <Card className="border rounded-lg">
          <CardContent className="h-64 flex items-center justify-center">
            <p className="text-muted-foreground text-sm">Carregando...</p>
          </CardContent>
        </Card>
      ) : filteredAndSortedClients.length === 0 ? (
        <Card className="border rounded-lg">
          <CardContent className="flex flex-col items-center justify-center py-12">
            <p className="text-muted-foreground text-center text-sm">
              {searchTerm || statusFilter !== "all"
                ? "Nenhum cliente encontrado com os filtros aplicados."
                : "Nenhum cliente cadastrado. Adicione seu primeiro cliente!"}
            </p>
          </CardContent>
        </Card>
      ) : (
        <div className="border rounded-lg overflow-x-auto">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead className="whitespace-nowrap text-xs sm:text-sm">
                  <Button
                    variant="ghost"
                    onClick={() => toggleSort("name")}
                    className="gap-2 hover:bg-transparent p-0 text-xs sm:text-sm"
                  >
                    Nome
                    <ArrowUpDown className="h-4 w-4" />
                  </Button>
                </TableHead>
                <TableHead className="whitespace-nowrap text-xs sm:text-sm">
                  <Button
                    variant="ghost"
                    onClick={() => toggleSort("due_date")}
                    className="gap-2 hover:bg-transparent p-0 text-xs sm:text-sm"
                  >
                    PrÃ³ximo Vencimento
                    <ArrowUpDown className="h-4 w-4" />
                  </Button>
                </TableHead>
                <TableHead className="whitespace-nowrap text-xs sm:text-sm">Telefone</TableHead>
                <TableHead className="whitespace-nowrap text-xs sm:text-sm">Valor</TableHead>
                <TableHead className="whitespace-nowrap text-xs sm:text-sm">Status</TableHead>
                <TableHead className="w-[50px] text-xs sm:text-sm"></TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredAndSortedClients.map((client) => (
                <TableRow key={client.id}>
                  <TableCell className="font-medium text-xs sm:text-sm">{client.name}</TableCell>
                  <TableCell className="text-xs sm:text-sm">
                    {(() => {
                      if (!client.next_billing_date) return '-';
                      
                      // A data vem como 'YYYY-MM-DD' do Supabase
                      const dateString = client.next_billing_date;

                      // Divide a string e cria um objeto Date local para evitar interpretaÃ§Ã£o UTC
                      const parts = dateString.split('-').map(Number);
                      // MÃªs Ã© 0-indexado no construtor de Date
                      const localDate = new Date(parts[0], parts[1] - 1, parts[2]);

                      // Formata o objeto Date local para exibiÃ§Ã£o
                      return format(localDate, 'dd/MM/yyyy');
                    })()}
                  </TableCell>
                  <TableCell className="text-xs sm:text-sm">{client.phone}</TableCell>
                  <TableCell className="text-xs sm:text-sm">
                    {client.planDetailsValue !== undefined && client.planDetailsValue !== null
                      ? new Intl.NumberFormat("pt-BR", { style: "currency", currency: "BRL" }).format(client.planDetailsValue)
                      : "N/A"}
                  </TableCell>
                  <TableCell className="whitespace-nowrap text-xs sm:text-sm">{getStatusBadge(client.status)}</TableCell>
                  <TableCell className="text-xs sm:text-sm">
                    <DropdownMenu>
                      <DropdownMenuTrigger asChild>
                        <Button variant="ghost" size="icon">
                          <MoreHorizontal className="h-4 w-4" />
                        </Button>
                      </DropdownMenuTrigger>
                      <DropdownMenuContent align="end">
                        <DropdownMenuItem onClick={() => handleOpenDialog(client)} className="text-sm">
                          <Pencil className="h-4 w-4 mr-2" />
                          Editar
                        </DropdownMenuItem>
                        <DropdownMenuItem onClick={() => handleRenewClient(client)} className="text-sm">
                          <RefreshCw className="h-4 w-4 mr-2" />
                          Renovar
                        </DropdownMenuItem>
                        <DropdownMenuItem onClick={() => handleOpenNotificationDialog(client)} className="text-sm">
                          <Bell className="h-4 w-4 mr-2" />
                          Notificar
                        </DropdownMenuItem>
                        <DropdownMenuItem onClick={() => handleDueToday(client)} className="text-sm">
                          <CalendarCheck className="h-4 w-4 mr-2" />
                          Vencer Hoje
                        </DropdownMenuItem>
                        <DropdownMenuSub>
                          <DropdownMenuSubTrigger className="text-sm">
                            <ListChecks className="h-4 w-4 mr-2" />
                            Mudar Status
                          </DropdownMenuSubTrigger>
                          <DropdownMenuSubContent>
                            <DropdownMenuItem onClick={() => handleChangeStatus(client, "active")} className="text-sm">
                              {client.status === "active" && <Check className="h-4 w-4 mr-2" />}
                              Ativo
                            </DropdownMenuItem>
                            <DropdownMenuItem onClick={() => handleChangeStatus(client, "inactive")} className="text-sm">
                              {client.status === "inactive" && <Check className="h-4 w-4 mr-2" />}
                              Inativo
                            </DropdownMenuItem>
                            {/* A opÃ§Ã£o 'Vencido' foi removida daqui */}
                          </DropdownMenuSubContent>
                        </DropdownMenuSub>
                        <DropdownMenuItem
                          onClick={() => {
                            setClientToDelete(client);
                            setDeleteDialogOpen(true);
                          }}
                          className="text-destructive text-sm"
                        >
                          <Trash2 className="h-4 w-4 mr-2" />
                          Excluir
                        </DropdownMenuItem>
                      </DropdownMenuContent>
                    </DropdownMenu>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </div>
      )}

      <ClientDialog
        open={dialogOpen}
        onOpenChange={setDialogOpen}
        client={selectedClient}
      />

      <NotificationDialog
        open={notificationDialogOpen}
        onOpenChange={setNotificationDialogOpen}
        client={clientToNotify}
      />

      <AlertDialog open={dueTodayDialogOpen} onOpenChange={setDueTodayDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle className="text-lg">Confirmar Vencimento para Hoje</AlertDialogTitle>
            <AlertDialogDescription className="text-sm">
              Tem certeza que deseja alterar o vencimento do cliente "{clientToDueToday?.name}" para hoje?
              Se o cliente estiver inativo, ele serÃ¡ ativado.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel className="text-sm">Cancelar</AlertDialogCancel>
            <AlertDialogAction onClick={handleConfirmDueToday} className="bg-primary text-primary-foreground hover:bg-primary/90 text-sm">
              Confirmar
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle className="text-lg">Confirmar exclusÃ£o</AlertDialogTitle>
            <AlertDialogDescription className="text-sm">
              Tem certeza que deseja excluir o cliente "{clientToDelete?.name}"? Esta aÃ§Ã£o nÃ£o pode ser desfeita.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel className="text-sm">Cancelar</AlertDialogCancel>
            <AlertDialogAction onClick={handleDeleteConfirm} className="bg-destructive text-destructive-foreground hover:bg-destructive/90 text-sm">
              Excluir
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
--- ConteÃºdo de: src/pages/Connection.tsx ---
import { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import { supabase } from "@/integrations/supabase/client";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { nanoid } from 'nanoid';
import { UserInstance, UserInstanceInsert, UserInstanceUpdate } from "@/integrations/supabase/schema";
import { useWebhookConfig } from '@/hooks/useWebhookConfig';
import { useLogEvolutionLogoutHistory } from '@/hooks/useEvolutionLogoutHistory'; // NOVO: Importar o hook de histÃ³rico de logout

type ConnectionStatus = "disconnected" | "connecting" | "connected";

// Define a URL fixa da Edge Function que atua como listener da Evolution API
const SUPABASE_PROJECT_ID = 'cgqyfpsfymhntumrmbzj';
const EVOLUTION_WEBHOOK_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/evolution-webhook-receiver`;

// --- Hooks para gerenciar a instÃ¢ncia do usuÃ¡rio ---
const fetchUserInstance = async (): Promise<UserInstance | null> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("UsuÃ¡rio nÃ£o autenticado");

  const { data, error } = await supabase
    .from('user_instances')
    .select('*')
    .eq('user_id', user.id)
    .single();

  if (error && error.code !== 'PGRST116') throw error; // PGRST116 = No rows found
  return data;
};

export const useUserInstance = () => {
  return useQuery<UserInstance | null, Error>({
    queryKey: ['userInstance'],
    queryFn: fetchUserInstance,
  });
};

const createUserInstance = async (newEntry: UserInstanceInsert): Promise<UserInstance> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("UsuÃ¡rio nÃ£o autenticado");

  const { data, error } = await supabase
    .from('user_instances')
    .insert({ ...newEntry, user_id: user.id })
    .select()
    .single();

  if (error) throw new Error(error.message);
  return data as UserInstance;
};

export const useCreateUserInstance = () => {
  const queryClient = useQueryClient();
  return useMutation<UserInstance, Error, UserInstanceInsert>({
    mutationFn: createUserInstance,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['userInstance'] });
    },
  });
};

const updateUserInstance = async (updatedEntry: UserInstanceUpdate & { id: string }): Promise<UserInstance> => {
  const { id, ...updateData } = updatedEntry;
  const { data, error } = await supabase
    .from('user_instances')
    .update(updateData)
    .eq('id', id)
    .select()
    .single();

  if (error) throw new Error(error.message);
  return data as UserInstance;
};

export const useUpdateUserInstance = () => {
  const queryClient = useQueryClient();
  return useMutation<UserInstance, Error, UserInstanceUpdate & { id: string }>({
    mutationFn: updateUserInstance,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['userInstance'] });
    },
  });
};

export default function Connection() {
  const { data: userInstance, isLoading: isLoadingInstance, error: instanceError } = useUserInstance();
  const updateUserInstanceMutation = useUpdateUserInstance();
  const logEvolutionLogoutMutation = useLogEvolutionLogoutHistory(); // NOVO: Hook de mutaÃ§Ã£o para log de logout

  // BLOC 1: Buscar a URL do webhook de geraÃ§Ã£o de QR Code do n8n
  const { data: n8nQrWebhookConfig, isLoading: isLoadingN8nQrConfig, error: n8nQrConfigError } = useWebhookConfig('n8n_qr_code_generator');
  // NOVO: Buscar a URL do webhook de logout da Evolution API
  const { data: n8nEvolutionLogoutConfig, isLoading: isLoadingN8nEvolutionLogout, error: n8nEvolutionLogoutError } = useWebhookConfig('n8n_evolution_logout');


  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>("disconnected");
  const [qrCodeBase64, setQrCodeBase64] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [currentUserId, setCurrentUserId] = useState<string | null>(null);

  useEffect(() => {
    supabase.auth.getUser().then(({ data: { user } }) => {
      setCurrentUserId(user?.id || null);
    });
  }, []);

  useEffect(() => {
    if (userInstance) {
      setConnectionStatus(userInstance.status as ConnectionStatus);
      setQrCodeBase64(userInstance.qr_code_base64 || null);
    } else if (!isLoadingInstance && !instanceError) {
      setConnectionStatus("disconnected");
      setQrCodeBase64(null);
    }
  }, [userInstance, isLoadingInstance, instanceError]);

  useEffect(() => {
    if (instanceError) {
      toast.error("Erro ao carregar dados da conexÃ£o", { description: instanceError.message });
    }
    // Exibir erro se a configuraÃ§Ã£o do webhook de QR Code falhar
    if (n8nQrConfigError) {
      toast.error("Erro ao carregar configuraÃ§Ã£o do webhook de QR Code", { description: n8nQrConfigError.message });
    }
    // NOVO: Exibir erro se a configuraÃ§Ã£o do webhook de logout falhar
    if (n8nEvolutionLogoutError) {
      toast.error("Erro ao carregar configuraÃ§Ã£o do webhook de logout", { description: n8nEvolutionLogoutError.message });
    }
  }, [instanceError, n8nQrConfigError, n8nEvolutionLogoutError]);

  // --- Supabase Realtime Listener ---
  useEffect(() => {
    if (!currentUserId) return;

    const channel = supabase.channel('instance-status-updates')
      .on(
        'postgres_changes',
        { event: 'UPDATE', schema: 'public', table: 'user_instances', filter: `user_id=eq.${currentUserId}` },
        (payload) => {
          console.log('Status da instÃ¢ncia alterado via Realtime!', payload.new);
          const newStatus = payload.new.status as ConnectionStatus;
          const newQrCode = payload.new.qr_code_base64 || null;
          setConnectionStatus(newStatus);
          setQrCodeBase64(newQrCode);

          if (newStatus === 'connected') {
            toast.success("Conectado!", { description: "Seu WhatsApp foi conectado com sucesso." });
          } else if (newStatus === 'disconnected' && !isLoading) {
            toast.error("Desconectado", { description: "Seu WhatsApp foi desconectado." });
          }
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [currentUserId, isLoading]);


  const getStatusDisplay = (status: ConnectionStatus) => {
    switch (status) {
      case "disconnected":
        return { label: "Desconectado", variant: "destructive" as const };
      case "connecting":
        return { label: "Aguardando QR Code...", variant: "secondary" as const };
      case "connected":
        return { label: "Conectado", variant: "default" as const };
      default:
        return { label: "Desconhecido", variant: "secondary" as const };
    }
  };

  const logN8nQrInteraction = async (
    requestPayload: any,
    responsePayload: any,
    statusCode: number | null,
    errorMessage: string | null,
    instanceName: string
  ) => {
    if (!currentUserId) return;

    try {
      const { error: invokeError } = await supabase.functions.invoke('log-n8n-qr-interaction', {
        body: {
          requestPayload,
          responsePayload,
          statusCode,
          errorMessage,
          instanceName,
        },
        headers: {
          'Authorization': `Bearer ${await supabase.auth.getSession().then(s => s.data.session?.access_token)}`,
        },
      });

      if (invokeError) {
        console.error('Error invoking log-n8n-qr-interaction:', invokeError.message);
      }
    } catch (logError: any) {
      console.error('Failed to log N8N QR interaction:', logError.message);
    }
  };

  const handleGenerateQrCode = async () => {
    setIsLoading(true);
    setError(null);
    setQrCodeBase64(null);
    setConnectionStatus("connecting");

    let requestBody: any = {};
    let responseData: any = null;
    let httpStatusCode: number | null = null;
    let currentInstanceName: string = '';
    let currentInstanceId: string | undefined = userInstance?.id;
    let operationErrorMessage: string | null = null;

    try {
      // BLOC 1: Obter a URL do webhook de geraÃ§Ã£o de QR Code do n8n
      if (isLoadingN8nQrConfig) {
        throw new Error('ConfiguraÃ§Ã£o do webhook de QR Code ainda estÃ¡ carregando.');
      }
      if (n8nQrConfigError) {
        throw new Error('Erro ao carregar URL do webhook de QR Code: ' + n8nQrConfigError.message);
      }
      if (!n8nQrWebhookConfig?.url) {
        throw new Error('URL do webhook de QR Code do n8n nÃ£o configurada. Configure em ConexÃ£o > Webhooks.');
      }

      const n8n_qr_code_webhook_url = n8nQrWebhookConfig.url;
      const evolution_listener_url = EVOLUTION_WEBHOOK_URL; // URL fixa da nossa Edge Function

      // --- PASSO 2: GARANTIR A EXISTÃNCIA DE UMA INSTÃNCIA PARA O UTILIZADOR ---
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Utilizador nÃ£o autenticado.');

      if (userInstance) {
        currentInstanceName = userInstance.instance_name;
        currentInstanceId = userInstance.id;
        await updateUserInstanceMutation.mutateAsync({
          id: currentInstanceId,
          status: "connecting",
          qr_code_base64: null,
        });
      } else {
        const newName = `user-${nanoid(10)}`;
        const { data: newInstance, error: createError } = await supabase
          .from('user_instances')
          .insert({ user_id: user.id, instance_name: newName, status: "connecting", qr_code_base64: null })
          .select('id, instance_name')
          .single();
        
        if (createError) {
          throw new Error('Erro ao criar a instÃ¢ncia do utilizador: ' + createError.message);
        }
        currentInstanceName = newInstance.instance_name;
        currentInstanceId = newInstance.id;
      }

      // --- PASSO 3: ENVIAR A REQUISIÃÃO PARA O N8N COM TODOS OS DADOS ---
      requestBody = {
        instanceName: currentInstanceName,
        webhook: {
          url: evolution_listener_url, // Esta Ã© a URL da nossa Supabase Edge Function
          events: ['CONNECTION_UPDATE']
        }
      };

      const response = await fetch(n8n_qr_code_webhook_url, { // Usar a URL correta do webhook do n8n
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      });

      httpStatusCode = response.status;
      
      try {
        responseData = await response.json();
        console.log('N8N QR Code webhook raw JSON response:', JSON.stringify(responseData, null, 2)); // Log adicionado
      } catch (jsonError) {
        responseData = await response.text();
        console.warn("N8N QR Code webhook response was not JSON, read as text.", jsonError);
        console.log('N8N QR Code webhook raw text response:', responseData); // Log adicionado
      }

      // --- NEW LOGIC: Prioritize QR code display if available ---
      let qrCodeBase64FromResponse: string | null = null;

      // CORRECTED LOGIC HERE
      if (Array.isArray(responseData) && responseData.length > 0 && responseData[0].base64) {
        qrCodeBase64FromResponse = responseData[0].base64;
        console.log('QR Code found at responseData[0].base64'); // Log adicionado
      } else if (responseData?.responsePayload?.qrcode?.base64) { // Fallback for a different structure if it ever occurs
        qrCodeBase64FromResponse = responseData.responsePayload.qrcode.base64;
        console.log('QR Code found at responseData.responsePayload.qrcode.base64 (fallback)'); // Log adicionado
      } else if (responseData?.base64) { // Fallback for QR code directly at root
        qrCodeBase64FromResponse = responseData.base64;
        console.log('QR Code found at responseData.base64 (fallback)'); // Log adicionado
      } else {
        console.warn('QR Code not found in expected paths within responseData.'); // Log adicionado
      }
      
      console.log('handleGenerateQrCode: Extracted qrCodeBase64FromResponse:', qrCodeBase64FromResponse ? 'YES' : 'NO'); // Added log

      const instanceNameFromResponse = responseData?.instanceName || currentInstanceName;

      if (qrCodeBase64FromResponse) {
        setQrCodeBase64(qrCodeBase64FromResponse);
        if (currentInstanceId) {
          await updateUserInstanceMutation.mutateAsync({
            id: currentInstanceId,
            instance_name: instanceNameFromResponse,
            qr_code_base64: qrCodeBase64FromResponse,
            status: "connecting",
          });
        }
        toast.success("QR Code gerado!", { description: "Escaneie o QR Code com seu celular para conectar." });
        return;
      }

      if (!response.ok) {
        throw new Error(responseData.message || 'O servidor de automaÃ§Ã£o retornou um erro.');
      }

      console.log('handleGenerateQrCode: qrCodeBase64FromResponse is empty, throwing error.'); // Added log
      throw new Error('NÃ£o foi possÃ­vel obter o QR Code na resposta do servidor. Tente novamente.');

    } catch (err: any) {
      operationErrorMessage = err.message;
      setError(err.message);
      // BLOC 2: Tratamento de Erro no Envio do POST - Reverter status para 'disconnected' no DB
      if (userInstance?.id) {
        await updateUserInstanceMutation.mutateAsync({
          id: userInstance.id,
          status: "disconnected",
          qr_code_base64: null,
        });
      }
      setConnectionStatus("disconnected"); // Atualiza o estado local imediatamente
      setQrCodeBase64(null); // Limpa o QR code imediatamente
      console.error("Erro detalhado no processo de gerar QR Code:", err);
      toast.error("Erro ao gerar QR Code", { description: err.message });
    } finally {
      setIsLoading(false);
      // Logar a interaÃ§Ã£o com o N8N QR Code, independentemente do sucesso ou falha
      if (currentUserId && currentInstanceName) {
        logN8nQrInteraction(
          requestBody,
          responseData,
          httpStatusCode,
          operationErrorMessage,
          currentInstanceName
        );
      }
    }
  };

  const handleDisconnect = async () => {
    if (!userInstance || !userInstance.id || !userInstance.instance_name) {
      toast.error("Erro", { description: "Nenhuma instÃ¢ncia para desconectar." });
      return;
    }

    setIsLoading(true);
    setError(null);

    let requestBody: any = {};
    let responseData: any = null;
    let httpStatusCode: number | null = null;
    let operationErrorMessage: string | null = null;

    try {
      // NOVO: Buscar a URL do webhook de logout do n8n
      if (isLoadingN8nEvolutionLogout) {
        throw new Error('ConfiguraÃ§Ã£o do webhook de logout ainda estÃ¡ carregando.');
      }
      if (n8nEvolutionLogoutError) {
        throw new Error('Erro ao carregar URL do webhook de logout: ' + n8nEvolutionLogoutError.message);
      }
      if (!n8nEvolutionLogoutConfig?.url) {
        throw new Error('URL do webhook de logout do n8n nÃ£o configurada. Configure em ConexÃ£o > Webhooks.');
      }

      const n8n_evolution_logout_webhook_url = n8nEvolutionLogoutConfig.url;
      const instanceName = userInstance.instance_name;

      requestBody = {
        instanceName: instanceName,
        Event: "Disconnect" // Payload conforme especificado
      };

      const response = await fetch(n8n_evolution_logout_webhook_url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      });

      httpStatusCode = response.status;
      
      try {
        responseData = await response.json();
      } catch (jsonError) {
        responseData = await response.text();
        console.warn("N8N Evolution Logout webhook response was not JSON, read as text.", jsonError);
      }

      if (!response.ok) {
        throw new Error(responseData.message || 'O servidor de automaÃ§Ã£o retornou um erro ao tentar desconectar.');
      }

      toast.success("SolicitaÃ§Ã£o de desconexÃ£o enviada!", { description: "Aguarde a confirmaÃ§Ã£o da Evolution API." });
      // O status serÃ¡ atualizado via Realtime pelo evolution-webhook-receiver
      
    } catch (err: any) {
      operationErrorMessage = err.message;
      setError(err.message);
      console.error("Erro detalhado no processo de desconexÃ£o:", err);
      toast.error("Erro ao desconectar", { description: err.message });
    } finally {
      setIsLoading(false);
      // Logar a interaÃ§Ã£o de logout, independentemente do sucesso ou falha
      if (currentUserId && userInstance?.instance_name) {
        logEvolutionLogoutMutation.mutate({
          requestPayload: requestBody,
          responsePayload: responseData,
          statusCode: httpStatusCode,
          errorMessage: operationErrorMessage,
          instanceName: userInstance.instance_name,
        });
      }
    }
  };

  // BLOC 3: FunÃ§Ã£o para o botÃ£o "Cancelar"
  const handleCancelConnection = async () => {
    if (!userInstance || !userInstance.id) {
      toast.error("Erro", { description: "Nenhuma instÃ¢ncia para cancelar a conexÃ£o." });
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      await updateUserInstanceMutation.mutateAsync({
        id: userInstance.id,
        status: "disconnected",
        qr_code_base64: null,
      });
      // O listener Realtime irÃ¡ atualizar o estado local automaticamente
      toast.info("ConexÃ£o cancelada", { description: "O processo de conexÃ£o foi cancelado." });
    } catch (err: any) {
      setError(err.message);
      toast.error("Erro ao cancelar conexÃ£o", { description: err.message });
    } finally {
      setIsLoading(false);
    }
  };

  const { label, variant } = getStatusDisplay(connectionStatus);

  if (isLoadingInstance) {
    return (
      <div className="min-h-screen flex items-center justify-center p-4 sm:p-6 lg:p-8">
        <div className="text-center">
          <div className="w-16 h-16 border-4 border-primary border-t-transparent rounded-full animate-spin mx-auto mb-4" />
          <p className="text-muted-foreground text-sm">Carregando status da conexÃ£o...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-2xl sm:text-3xl font-bold text-foreground">ConexÃ£o com WhatsApp</h1>
        <p className="text-sm sm:text-base text-muted-foreground mt-1">Gerencie a integraÃ§Ã£o do seu sistema com o WhatsApp</p>
      </div>

      <Card className="border-border bg-card">
        <CardHeader>
          <CardTitle className="flex flex-col sm:flex-row items-start sm:items-center gap-2 text-lg sm:text-xl">
            Status: <Badge variant={variant}>{label}</Badge>
          </CardTitle>
          <CardDescription className="text-sm">
            {connectionStatus === "disconnected" && "Para enviar notificaÃ§Ãµes, conecte seu nÃºmero de WhatsApp."}
            {connectionStatus === "connecting" && "Aguardando leitura do QR Code..."}
            {connectionStatus === "connected" && "Dispositivo conectado com sucesso!"}
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {error && (
            <div className="bg-destructive/10 text-destructive p-3 rounded-md text-sm">
              <p className="font-medium">Erro:</p>
              <p>{error}</p>
            </div>
          )}

          {connectionStatus === "disconnected" && (
            <Button onClick={handleGenerateQrCode} className="w-full" disabled={isLoading || isLoadingN8nQrConfig}>
              {isLoading || isLoadingN8nQrConfig ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" /> Gerando QR Code...
                </>
              ) : (
                "Gerar QR Code"
              )}
            </Button>
          )}

          {connectionStatus === "connecting" && (
            <div className="flex flex-col items-center justify-center space-y-4">
              {isLoading ? (
                <Loader2 className="h-12 w-12 animate-spin text-primary" />
              ) : qrCodeBase64 ? (
                <div>
                  <p className="text-muted-foreground mb-4 text-sm">Escaneie o QR Code com o seu WhatsApp.</p>
                  <img 
                    src={
                      qrCodeBase64.startsWith('data:image') 
                        ? qrCodeBase64 
                        : `data:image/png;base64,${qrCodeBase64}`
                    } 
                    alt="WhatsApp QR Code"
                    className="mx-auto rounded-lg border-4 border-white bg-white max-w-full h-auto"
                  />
                  <p className="text-xs text-muted-foreground mt-4">Escaneie o QR Code com o seu celular.</p>
                </div>
              ) : (
                <p className="text-muted-foreground mb-4 text-sm">Gerando QR Code... Por favor, aguarde.</p>
              )}
              <Button onClick={handleCancelConnection} variant="outline" className="w-full" disabled={isLoading}>
                {isLoading ? (
                  <>
                    <Loader2 className="h-4 w-4 mr-2 animate-spin" /> Cancelando...
                  </>
                ) : (
                  "Cancelar"
                )}
              </Button>
            </div>
          )}

          {connectionStatus === "connected" && (
            <Button onClick={handleDisconnect} variant="destructive" className="w-full" disabled={isLoading || isLoadingN8nEvolutionLogout}>
              {isLoading || isLoadingN8nEvolutionLogout ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" /> Desconectando...
                </>
              ) : (
                "Desconectar"
              )}
            </Button>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
--- ConteÃºdo de: src/pages/Dashboard.tsx ---
import { useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Users, FileText, AlertCircle, TrendingUp } from "lucide-react";
import { toast } from "sonner";
import { useDashboardStats } from "@/hooks/useDashboardStats";

export default function Dashboard() {
  const { data: stats, isLoading, error } = useDashboardStats();

  useEffect(() => {
    if (error) {
      toast.error("Erro ao carregar estatÃ­sticas", { description: error.message });
    }
  }, [error]);

  const statCards = [
    {
      title: "Total de Clientes",
      value: stats?.totalClients || 0,
      icon: Users,
      color: "text-primary",
    },
    {
      title: "Clientes Ativos",
      value: stats?.activeClients || 0,
      icon: TrendingUp,
      color: "text-success",
    },
    {
      title: "Planos Cadastrados",
      value: stats?.totalPlans || 0,
      icon: FileText,
      color: "text-accent",
    },
    {
      title: "CobranÃ§as Atrasadas",
      value: stats?.overdueClients || 0,
      icon: AlertCircle,
      color: "text-destructive",
    },
  ];

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-2xl sm:text-3xl font-bold text-foreground">Dashboard</h1>
        <p className="text-sm sm:text-base text-muted-foreground mt-1">
          VisÃ£o geral do seu sistema de cobranÃ§a
        </p>
      </div>

      {isLoading ? (
        <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-4">
          {[...Array(4)].map((_, i) => (
            <Card key={i} className="border-border bg-card">
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <div className="h-4 bg-muted rounded w-24 animate-pulse" />
                <div className="h-4 w-4 bg-muted rounded animate-pulse" />
              </CardHeader>
              <CardContent>
                <div className="h-8 bg-muted rounded w-16 animate-pulse" />
              </CardContent>
            </Card>
          ))}
        </div>
      ) : (
        <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-4">
          {statCards.map((stat) => (
            <Card
              key={stat.title}
              className="border-border bg-card hover:shadow-md transition-shadow"
            >
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <CardTitle className="text-sm font-medium text-muted-foreground">
                  {stat.title}
                </CardTitle>
                <stat.icon className={`h-4 w-4 ${stat.color}`} />
              </CardHeader>
              <CardContent>
                <div className={`text-2xl sm:text-3xl font-bold ${stat.color}`}>{stat.value}</div>
              </CardContent>
            </Card>
          ))}
        </div>
      )}

      <Card className="border-border bg-card">
        <CardHeader>
          <CardTitle className="text-lg sm:text-xl">Bem-vindo ao Acerto Certo</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-muted-foreground">
            Gerencie seus clientes, planos e cobranÃ§as de forma eficiente. Use o menu lateral
            para navegar entre as diferentes funcionalidades do sistema.
          </p>
        </CardContent>
      </Card>
    </div>
  );
}
--- ConteÃºdo de: src/pages/NotFound.tsx ---
import { useLocation } from "react-router-dom";
import { useEffect } from "react";

const NotFound = () => {
  const location = useLocation();

  useEffect(() => {
    console.error("404 Error: User attempted to access non-existent route:", location.pathname);
  }, [location.pathname]);

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-100">
      <div className="text-center">
        <h1 className="mb-4 text-4xl font-bold">404</h1>
        <p className="mb-4 text-xl text-gray-600">Oops! Page not found</p>
        <a href="/" className="text-blue-500 underline hover:text-blue-700">
          Return to Home
        </a>
      </div>
    </div>
  );
};

export default NotFound;

--- ConteÃºdo de: src/pages/Plans.tsx ---
import { useEffect, useState } from "react";
import { Button } from "@/components/ui/button";
import { Plus, MoreHorizontal, Pencil, Trash2 } from "lucide-react";
import { toast } from "sonner";
import { PlanDialog } from "@/components/plans/PlanDialog";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { usePlans, useDeletePlan } from "@/hooks/usePlans";
import { Plan } from "@/integrations/supabase/schema"; // Importar Plan do schema
import { Card, CardContent } from "@/components/ui/card"; // Importar Card e CardContent

export default function Plans() {
  const { data: plans, isLoading, error } = usePlans();
  const deletePlanMutation = useDeletePlan();

  const [dialogOpen, setDialogOpen] = useState(false);
  const [selectedPlan, setSelectedPlan] = useState<Plan | null>(null);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [planToDelete, setPlanToDelete] = useState<Plan | null>(null);

  useEffect(() => {
    if (error) {
      toast.error("Erro ao carregar planos", { description: error.message });
    }
  }, [error]);

  const handleOpenDialog = (plan?: Plan) => {
    setSelectedPlan(plan || null);
    setDialogOpen(true);
  };

  const getPeriodLabel = (days: number) => {
    if (days === 1) return "DiÃ¡rio";
    if (days === 7) return "Semanal";
    if (days === 30) return "Mensal";
    return `${days} dias`;
  };

  const handleDeleteConfirm = async () => {
    if (!planToDelete) return;

    try {
      await deletePlanMutation.mutateAsync(planToDelete.id);
      toast.success("Plano excluÃ­do", { description: "O plano foi removido com sucesso." });
    } catch (error: any) {
      toast.error("Erro ao excluir plano", { description: error.message });
    } finally {
      setDeleteDialogOpen(false);
      setPlanToDelete(null);
    }
  };

  return (
    <div className="space-y-6">
      <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
        <div>
          <h1 className="text-2xl sm:text-3xl font-bold text-foreground">Planos</h1>
          <p className="text-sm sm:text-base text-muted-foreground mt-1">Gerencie seus planos de cobranÃ§a</p>
        </div>
        <Button onClick={() => handleOpenDialog()} className="gap-2 w-full sm:w-auto">
          <Plus className="h-4 w-4" />
          Novo Plano
        </Button>
      </div>

      {isLoading ? (
        <Card className="border rounded-lg">
          <CardContent className="h-64 flex items-center justify-center">
            <p className="text-muted-foreground text-sm">Carregando...</p>
          </CardContent>
        </Card>
      ) : (plans || []).length === 0 ? (
        <Card className="border-border bg-card">
          <CardContent className="flex flex-col items-center justify-center py-12">
            <p className="text-muted-foreground text-center text-sm">
              Nenhum plano cadastrado. Crie seu primeiro plano!
            </p>
          </CardContent>
        </Card>
      ) : (
        <div className="border rounded-lg overflow-x-auto">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead className="text-xs sm:text-sm">Nome do Plano</TableHead>
                <TableHead className="text-xs sm:text-sm">Valor</TableHead>
                <TableHead className="text-xs sm:text-sm">PerÃ­odo (dias)</TableHead>
                <TableHead className="w-[50px] text-xs sm:text-sm"></TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {(plans || []).map((plan) => (
                <TableRow key={plan.id}>
                  <TableCell className="font-medium text-xs sm:text-sm">{plan.name}</TableCell>
                  <TableCell className="text-xs sm:text-sm">R$ {Number(plan.value).toFixed(2)}</TableCell>
                  <TableCell className="text-xs sm:text-sm">{getPeriodLabel(plan.period_days)}</TableCell>
                  <TableCell className="text-xs sm:text-sm">
                    <DropdownMenu>
                      <DropdownMenuTrigger asChild>
                        <Button variant="ghost" size="icon">
                          <MoreHorizontal className="h-4 w-4" />
                        </Button>
                      </DropdownMenuTrigger>
                      <DropdownMenuContent align="end">
                        <DropdownMenuItem onClick={() => handleOpenDialog(plan)} className="text-sm">
                          <Pencil className="h-4 w-4 mr-2" />
                          Editar
                        </DropdownMenuItem>
                        <DropdownMenuItem
                          onClick={() => {
                            setPlanToDelete(plan);
                            setDeleteDialogOpen(true);
                          }}
                          className="text-destructive text-sm"
                        >
                          <Trash2 className="h-4 w-4 mr-2" />
                          Excluir
                        </DropdownMenuItem>
                      </DropdownMenuContent>
                    </DropdownMenu>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </div>
      )}

      <PlanDialog
        open={dialogOpen}
        onOpenChange={setDialogOpen}
        plan={selectedPlan}
      />

      <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle className="text-lg">Confirmar exclusÃ£o</AlertDialogTitle>
            <AlertDialogDescription className="text-sm">
              Tem certeza que deseja excluir o plano "{planToDelete?.name}"? Esta aÃ§Ã£o nÃ£o pode ser desfeita.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel className="text-sm">Cancelar</AlertDialogCancel>
            <AlertDialogAction onClick={handleDeleteConfirm} className="bg-destructive text-destructive-foreground hover:bg-destructive/90 text-sm">
              Excluir
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
--- ConteÃºdo de: src/pages/Profile.tsx ---
import React, { useState, useEffect } from 'react';
import { useMutation } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { User, Mail, Lock, Save, QrCode, KeyRound, ShieldCheck, LockKeyhole, Gem, Phone, UserCheck } from 'lucide-react';
import { toast } from 'sonner';
import { Skeleton } from '@/components/ui/skeleton';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import { useProfileAndSubscriptionData, useUpdateProfile } from '@/hooks/useProfileData';
import { useLocation, useNavigate } from 'react-router-dom'; // CorreÃ§Ã£o aqui
import { PixPaymentModal } from '@/components/profile/PixPaymentModal';
import { MercadoPagoPaymentModal } from '@/components/profile/MercadoPagoPaymentModal';
import { useActiveGateway } from '@/hooks/useActiveGateway';

// --- LÃGICA DE DADOS (HOOKS) ---
const useUpdatePassword = () => {
    return useMutation({
        mutationFn: async ({ newPassword }: { newPassword: string }) => {
            const { error } = await supabase.auth.updateUser({ password: newPassword });
            if (error) throw new Error(error.message);
        },
        onSuccess: () => toast.success('Senha atualizada com sucesso!'),
        onError: (error) => toast.error(`Erro ao atualizar senha: ${error.message}`),
    });
};

// --- COMPONENTE PRINCIPAL DA PÃGINA ---
export default function Profile() {
    const [isPixModalOpen, setIsPixModalOpen] = useState(false);
    const [isMercadoPagoModalForZeroPrice, setIsMercadoPagoModalForZeroPrice] = useState(false);
    const { data, isLoading, error } = useProfileAndSubscriptionData();
    const { data: activeGateway, isLoading: isLoadingActiveGateway } = useActiveGateway();
    const updateProfileMutation = useUpdateProfile();
    const updatePasswordMutation = useUpdatePassword();
    const location = useLocation();
    const navigate = useNavigate();
    const [highlightPhone, setHighlightPhone] = useState(false);
    const [highlightTaxId, setHighlightTaxId] = useState(false);

    useEffect(() => {
        const params = new URLSearchParams(location.search);
        if (params.get('missingPhone') === 'true') {
            toast.error('Telefone obrigatÃ³rio', {
                description: 'Por favor, preencha seu nÃºmero de telefone para continuar navegando no sistema.',
            });
            setHighlightPhone(true);
            params.delete('missingPhone');
            navigate({ search: params.toString() }, { replace: true });
        }
    }, [location.search, navigate]);

    const handleProfileSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        setHighlightTaxId(false);
        const formData = new FormData(e.target as HTMLFormElement);
        const name = formData.get('name') as string;
        const pix_key = formData.get('pix_key') as string;
        const phone = formData.get('phone') as string;
        const tax_id = formData.get('tax_id') as string;

        const cleanedTaxId = tax_id.replace(/\D/g, '');
        if (cleanedTaxId && (cleanedTaxId.length !== 11 && cleanedTaxId.length !== 14)) {
            toast.error("CPF/CNPJ invÃ¡lido", { description: "Deve conter 11 (CPF) ou 14 (CNPJ) nÃºmeros." });
            setHighlightTaxId(true);
            return;
        }

        updateProfileMutation.mutate({ 
            name, 
            pix_key: pix_key || null, 
            phone: phone || null,
            tax_id: cleanedTaxId || null,
        });
    };
    
    const handlePasswordSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        const formData = new FormData(e.target as HTMLFormElement);
        const newPassword = formData.get('password') as string;
        if (newPassword && newPassword.length >= 6) {
            updatePasswordMutation.mutate({ newPassword });
        } else {
            toast.error('A nova senha deve ter pelo menos 6 caracteres.');
        }
    };

    const formatDate = (dateString: string | null) => {
        if (!dateString) return "N/A";
        return new Date(dateString + 'T00:00:00').toLocaleDateString('pt-BR', { year: 'numeric', month: 'long', day: 'numeric' });
    };

    if (isLoading || isLoadingActiveGateway) return (
        <div className="min-h-screen p-4 sm:p-6 lg:p-8">
            <Skeleton className="h-12 w-1/3" />
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mt-8">
                <div className="lg:col-span-2 space-y-8">
                    <Skeleton className="h-64 w-full" />
                    <Skeleton className="h-48 w-full" />
                </div>
                <div className="lg:col-span-1">
                    <Skeleton className="h-64 w-full" />
                </div>
            </div>
        </div>
    );
    if (error) return <div className="p-8 text-destructive">Erro ao carregar dados do perfil: {error.message}</div>;

    if (!data) return null; 
    const { profile, subscription } = data;

    const isPagbankActive = activeGateway?.gateway_name === 'pagbank';
    const isMercadoPagoActive = activeGateway?.gateway_name === 'mercadopago';
    // Considera o plano gratuito se o flag isFree for true OU se o preÃ§o for 0
    const isFreePlan = subscription?.isFree || (subscription?.price === 0); 

    return (
        <div className="bg-background min-h-screen text-foreground p-4 sm:p-6 lg:p-8 font-sans">
            <div className="max-w-4xl mx-auto space-y-8">
                <header>
                    <h1 className="text-3xl font-bold text-foreground">Gerenciar Perfil</h1>
                    <p className="text-muted-foreground mt-1">Atualize suas informaÃ§Ãµes pessoais e gerencie sua assinatura.</p>
                </header>
                <main className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                    <div className="lg:col-span-2 space-y-8">
                        <Card className="rounded-xl">
                            <form onSubmit={handleProfileSubmit}>
                                <CardHeader className="p-6">
                                    <CardTitle className="text-lg font-semibold text-foreground flex items-center">
                                        <User className="w-5 h-5 mr-2 text-primary" />
                                        InformaÃ§Ãµes do Perfil
                                    </CardTitle>
                                    <CardDescription className="text-sm text-muted-foreground mt-1">Edite seu nome, e-mail, telefone e chave PIX.</CardDescription>
                                </CardHeader>
                                <CardContent className="p-6 pt-0">
                                    <div className="mt-6 space-y-4">
                                        <div className="relative">
                                            <User className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                                            <Input id="name" name="name" defaultValue={profile.name} className="block w-full rounded-lg pl-10" />
                                        </div>
                                        <div className="relative">
                                            <Mail className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                                            <Input id="email" name="email" type="email" defaultValue={profile.email} disabled className="block w-full rounded-lg pl-10 text-muted-foreground" />
                                        </div>
                                        <div className="relative">
                                            <Phone className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                                            <Input 
                                                id="phone" 
                                                name="phone" 
                                                type="tel" 
                                                defaultValue={profile.phone || ''} 
                                                placeholder="Seu telefone (ex: 5511984701079)" 
                                                className={cn("block w-full rounded-lg pl-10", highlightPhone && "border-2 border-destructive")}
                                            />
                                        </div>
                                        <div className="relative">
                                            <UserCheck className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                                            <Input 
                                                id="tax_id" 
                                                name="tax_id" 
                                                defaultValue={profile.tax_id || ''} 
                                                placeholder="Seu CPF ou CNPJ (apenas nÃºmeros)" 
                                                className={cn("block w-full rounded-lg pl-10", highlightTaxId && "border-2 border-destructive")}
                                            />
                                        </div>
                                        <div className="relative">
                                            <KeyRound className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                                            <Input id="pix_key" name="pix_key" defaultValue={profile.pix_key || ''} placeholder="Sua chave PIX (e-mail, telefone ou aleatÃ³ria)" className="block w-full rounded-lg pl-10" />
                                        </div>
                                    </div>
                                </CardContent>
                                <CardFooter className="bg-card/50 border-t border-border px-6 py-4 rounded-b-xl flex justify-end">
                                    <Button type="submit" disabled={updateProfileMutation.isPending}>
                                        <Save className="h-4 w-4 mr-2" />
                                        {updateProfileMutation.isPending ? "Salvando..." : "Salvar AlteraÃ§Ãµes"}
                                    </Button>
                                </CardFooter>
                            </form>
                        </Card>
                        <Card className="rounded-xl">
                             <form onSubmit={handlePasswordSubmit}>
                                <CardHeader className="p-6">
                                    <CardTitle className="text-lg font-semibold text-foreground flex items-center">
                                        <ShieldCheck className="w-5 h-5 mr-2 text-primary" />
                                        SeguranÃ§a
                                    </CardTitle>
                                    <CardDescription className="text-sm text-muted-foreground mt-1">Altere sua senha de acesso.</CardDescription>
                                </CardHeader>
                                <CardContent className="p-6 pt-0">
                                    <div className="mt-6">
                                        <div className="relative">
                                            <Lock className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                                            <Input id="password" name="password" type="password" placeholder="â¢â¢â¢â¢â¢â¢â¢â¢" className="block w-full rounded-lg pl-10" />
                                        </div>
                                    </div>
                                </CardContent>
                                <CardFooter className="bg-card/50 border-t border-border px-6 py-4 rounded-b-xl flex justify-end">
                                    <Button type="submit" disabled={updatePasswordMutation.isPending}>
                                        <LockKeyhole className="h-4 w-4 mr-2" />
                                        {updatePasswordMutation.isPending ? "Atualizando..." : "Atualizar Senha"}
                                    </Button>
                                </CardFooter>
                            </form>
                        </Card>
                    </div>
                    <div className="lg:col-span-1">
                        <Card className="rounded-xl">
                            <CardHeader className="p-6">
                                <CardTitle className="text-lg font-semibold text-foreground flex items-center">
                                    <Gem className="w-5 h-5 mr-2 text-primary" />
                                    Assinatura
                                </CardTitle>
                            </CardHeader>
                            <CardContent className="p-6 pt-0">
                                {subscription ? (
                                    <div className="mt-6 p-4 rounded-lg bg-muted/50 space-y-4">
                                        <div className="flex items-center justify-between">
                                            <span className="font-semibold text-foreground">{subscription.planName}</span>
                                            <span className={cn(
                                                "py-1 px-3 rounded-full text-xs font-semibold",
                                                subscription.status === 'active' ? 'bg-success/10 text-success' : 'bg-destructive/10 text-destructive'
                                            )}>
                                                {subscription.status === 'active' ? 'Ativa' : subscription.status === 'overdue' ? 'Atrasada' : 'Inativa'}
                                            </span>
                                        </div>
                                        <div className="text-center">
                                            <p className="text-4xl font-bold text-foreground">
                                                {subscription.price.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}
                                                {!isFreePlan && <span className="text-base font-medium text-muted-foreground">/mÃªs</span>}
                                            </p>
                                        </div>
                                        <div className="text-sm text-muted-foreground text-center border-t border-border pt-3">
                                            {/* LÃ³gica de exibiÃ§Ã£o da data de vencimento ajustada */}
                                            <p>PrÃ³xima cobranÃ§a em {isFreePlan ? "Sem data de vencimento" : formatDate(subscription.nextBillingDate)}</p>
                                        </div>
                                    </div>
                                ) : (
                                    <div className="mt-6 p-4 rounded-lg bg-muted/50 text-center text-muted-foreground">
                                        Nenhuma assinatura ativa.
                                    </div>
                                )}
                            </CardContent>
                            <CardFooter className="bg-card/50 border-t border-border px-6 py-4 rounded-b-xl">
                                {isPagbankActive && (
                                    <Button 
                                        className="w-full bg-secondary hover:bg-secondary/80 text-secondary-foreground" 
                                        onClick={() => {
                                            if (!subscription) {
                                                toast.error("Erro", { description: "VocÃª nÃ£o possui uma assinatura ativa para renovar." });
                                                return;
                                            }
                                            setIsPixModalOpen(true);
                                        }}
                                        disabled={!subscription || isFreePlan} // Desabilitar se for plano gratuito
                                    >
                                        <QrCode className="w-5 h-5 mr-2" />
                                        Renovar com PIX
                                    </Button>
                                )}
                                {isMercadoPagoActive && (
                                    <Button 
                                        className="w-full bg-secondary hover:bg-secondary/80 text-secondary-foreground" 
                                        onClick={() => {
                                            if (!subscription) {
                                                toast.error("Erro", { description: "VocÃª nÃ£o possui uma assinatura ativa para renovar." });
                                                return;
                                            }
                                            setIsMercadoPagoModalForZeroPrice(true);
                                        }}
                                        disabled={!subscription || isFreePlan} // Desabilitar se for plano gratuito
                                    >
                                        <QrCode className="w-5 h-5 mr-2" />
                                        Renovar com PIX
                                    </Button>
                                )}
                                {!isPagbankActive && !isMercadoPagoActive && (
                                    <Button 
                                        className="w-full bg-muted-foreground text-muted" 
                                        disabled
                                    >
                                        Nenhum gateway de pagamento ativo
                                    </Button>
                                )}
                            </CardFooter>
                        </Card>
                    </div>
                </main>
            </div>

            {/* Modal de Pagamento PIX */}
            {isPixModalOpen && subscription && (
                <PixPaymentModal
                    open={isPixModalOpen}
                    onOpenChange={setIsPixModalOpen}
                    subscriptionId={subscription.id}
                    amount={subscription.price}
                    planName={subscription.planName}
                />
            )}

            {/* NOVO: Modal de Pagamento Mercado Pago */}
            {isMercadoPagoModalForZeroPrice && subscription && (
                <MercadoPagoPaymentModal
                    open={isMercadoPagoModalForZeroPrice}
                    onOpenChange={setIsMercadoPagoModalForZeroPrice}
                    subscriptionId={subscription.id}
                    amount={subscription.price}
                    planName={subscription.planName}
                />
            )}
        </div>
    );
}
--- ConteÃºdo de: src/pages/Templates.tsx ---
import { useEffect, useState } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Plus } from "lucide-react";
import { toast } from "sonner";
import { TemplateDialog } from "@/components/templates/TemplateDialog";
import { Badge } from "@/components/ui/badge";
import { useTemplates, Template } from "@/hooks/useTemplates"; // Importar Template do hook useTemplates
import { useAuth } from "@/contexts/AuthContext"; // Importar useAuth

export default function Templates() {
  const { user, role } = useAuth(); // Obter user e role do AuthContext
  const { data: templates, isLoading, error } = useTemplates();
  // Removed: const deleteTemplateMutation = useDeleteTemplate(); // Usar o hook de delete

  const [dialogOpen, setDialogOpen] = useState(false);
  const [selectedTemplate, setSelectedTemplate] = useState<Template | null>(null);

  useEffect(() => {
    if (error) {
      toast.error("Erro ao carregar templates", { description: error.message });
    }
  }, [error]);

  const handleOpenDialog = (template?: Template) => {
    setSelectedTemplate(template || null);
    setDialogOpen(true);
  };

  // REMOVIDO: getCategoryLabel e getCategoryColor

  const canEditOrDelete = (template: Template) => {
    if (!user) return false;
    // Admins podem editar/deletar qualquer template
    if (role === 'admin') return true;
    // UsuÃ¡rio comum sÃ³ pode editar/deletar seus prÃ³prios templates E que sejam do tipo 'normal'
    return template.user_id === user.id && template.type === 'normal';
  };

  return (
    <div className="space-y-6">
      <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
        <div>
          <h1 className="text-2xl sm:text-3xl font-bold text-foreground">Templates</h1>
          <p className="text-sm sm:text-base text-muted-foreground mt-1">Gerencie suas mensagens automÃ¡ticas</p>
        </div>
        <Button onClick={() => handleOpenDialog()} className="gap-2 w-full sm:w-auto">
          <Plus className="h-4 w-4" />
          Novo Template
        </Button>
      </div>

      {isLoading ? (
        <div className="grid gap-4 md:grid-cols-2">
          {[...Array(4)].map((_, i) => (
            <Card key={i} className="border-border bg-card">
              <CardHeader>
                <div className="h-6 bg-muted rounded w-3/4 animate-pulse" />
              </CardHeader>
              <CardContent className="space-y-2">
                <div className="h-4 bg-muted rounded w-full animate-pulse" />
                <div className="h-4 bg-muted rounded w-2/3 animate-pulse" />
              </CardContent>
            </Card>
          ))}
        </div>
      ) : (templates || []).length === 0 ? (
        <Card className="border-border bg-card">
          <CardContent className="flex flex-col items-center justify-center py-12">
            <p className="text-muted-foreground text-center text-sm">
              Nenhum template cadastrado. Crie seu primeiro template!
            </p>
          </CardContent>
        </Card>
      ) : (
        <div className="grid gap-4 md:grid-cols-2">
          {(templates || []).map((template: Template) => (
            <Card
              key={template.id}
              className={`border-border bg-card hover:shadow-md transition-shadow ${canEditOrDelete(template) ? 'cursor-pointer' : 'cursor-not-allowed opacity-80'}`}
              onClick={() => canEditOrDelete(template) && handleOpenDialog(template)}
            >
              <CardHeader>
                <div className="flex items-start justify-between">
                  <CardTitle className="text-base sm:text-lg">{template.name}</CardTitle>
                  <div className="flex gap-2 items-center">
                    {template.user_id === null && (
                      <Badge variant="secondary" className="bg-blue-800/20 text-blue-300 text-xs">PadrÃ£o</Badge>
                    )}
                    {template.type === 'global' && (
                      <Badge variant="secondary" className="bg-purple-800/20 text-purple-300 text-xs">Global</Badge>
                    )}
                  </div>
                </div>
              </CardHeader>
              <CardContent>
                <CardDescription className="line-clamp-3 text-sm">
                  {template.content}
                </CardDescription>
              </CardContent>
            </Card>
          ))}
        </div>
      )}

      <Card className="border-border bg-card">
        <CardHeader>
          <CardTitle className="text-lg sm:text-xl">Placeholders DisponÃ­veis</CardTitle>
          <CardDescription className="text-sm">
            Use estes marcadores em suas mensagens para personalizaÃ§Ã£o automÃ¡tica
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="grid gap-2 md:grid-cols-2">
            <div className="flex items-center gap-2">
              <code className="px-2 py-1 rounded bg-muted text-xs sm:text-sm">
                {"{{customer_name}}"}
              </code>
              <span className="text-xs sm:text-sm text-muted-foreground">Nome do cliente</span>
            </div>
            <div className="flex items-center gap-2">
              <code className="px-2 py-1 rounded bg-muted text-xs sm:text-sm">
                {"{{plan_name}}"}
              </code>
              <span className="text-xs sm:text-sm text-muted-foreground">Nome do plano</span>
            </div>
            <div className="flex items-center gap-2">
              <code className="px-2 py-1 rounded bg-muted text-xs sm:text-sm">
                {"{{due_date}}"}
              </code>
              <span className="text-xs sm:text-sm text-muted-foreground">Data de vencimento</span>
            </div>
            <div className="flex items-center gap-2">
              <code className="px-2 py-1 rounded bg-muted text-xs sm:text-sm">
                {"{{value}}"}
              </code>
              <span className="text-xs sm:text-sm text-muted-foreground">Valor da cobranÃ§a</span>
            </div>
            <div className="flex items-center gap-2">
              <code className="px-2 py-1 rounded bg-muted text-xs sm:text-sm">
                {"{{pix_key}}"}
              </code>
              <span className="text-xs sm:text-sm text-muted-foreground">Chave PIX do seu perfil</span>
            </div>
          </div>
        </CardContent>
      </Card>

      <TemplateDialog
        open={dialogOpen}
        onOpenChange={setDialogOpen}
        template={selectedTemplate}
      />
    </div>
  );
}
--- ConteÃºdo de: src/hooks/useActiveGateway.ts ---
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { toast } from "sonner";
import { ActivePaymentGateway, ActivePaymentGatewayInsert } from '@/integrations/supabase/schema';
import { useAuth } from '@/contexts/AuthContext';

const SUPABASE_PROJECT_ID = "cgqyfpsfymhntumrmbzj";
const EDGE_FUNCTION_NAME = "crud-active-gateway";
const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

// --- Fetch Active Payment Gateway ---
const fetchActiveGateway = async (): Promise<ActivePaymentGateway | null> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao buscar gateway de pagamento ativo.");
  }

  return response.json();
};

export const useActiveGateway = () => {
  const { user, isLoading: isLoadingAuth } = useAuth(); // Removed role from destructuring
  return useQuery<ActivePaymentGateway | null, Error>({
    queryKey: ["activePaymentGateway", user?.id], // Removed role from query key
    queryFn: fetchActiveGateway,
    enabled: !isLoadingAuth && !!user?.id, // Removed role === 'admin' condition
    staleTime: 1000 * 60 * 5, // Cache por 5 minutos
  });
};

// --- Save Active Payment Gateway (Upsert) ---
const saveActiveGateway = async (gatewayName: string): Promise<ActivePaymentGateway> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const payload: ActivePaymentGatewayInsert = { gateway_name: gatewayName };

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST", // Usamos POST para upsert, a Edge Function lida com a lÃ³gica
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao salvar gateway de pagamento ativo.");
  }

  return response.json();
};

export const useSaveActiveGateway = () => {
  const queryClient = useQueryClient();
  return useMutation<ActivePaymentGateway, Error, string>({
    mutationFn: saveActiveGateway,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['activePaymentGateway'] });
      toast.success("Gateway ativo salvo com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao salvar gateway ativo", { description: error.message });
    },
  });
};
--- ConteÃºdo de: src/hooks/useAdminFinancialData.ts ---
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
// @ts-ignore
import { AdminFinancialEntry, AdminFinancialEntryInsert, AdminFinancialEntryUpdate, TransactionType } from '@/integrations/supabase/schema';
import { toast } from "sonner";
import { useAuth } from '@/contexts/AuthContext';

// --- Interfaces para dados de resumo e anÃ¡lise ---
export interface AdminFinancialSummary {
  receivedToday: number;
  receivedThisWeek: number;
  receivedThisMonth: number;
  receivableToday: number;
  receivableTomorrow: number;
  receivableThisWeek: number;
  receivableThisMonth: number;
  lostValueToday: number;
  lostValueThisWeek: number;
  lostValueThisMonth: number;
}

export interface AdminKpis {
  currentMonthRevenue: number;
  previousMonthRevenue: number;
  monthlyGrowthPercentage: number;
  newSubscribersThisMonth: number;
  activeSubscribers: number;
  revenueForecast: number;
}

export interface AdminRevenueData {
  date: string;
  revenue: number;
}

export interface AdminMonthlyRevenueHistory {
  month: string;
  revenue: number;
}

export interface AdminWeeklyRevenue {
  [key: string]: {
    currentMonth: number;
    previousMonth: number;
  };
}

export interface AdminRevenueByPlan {
  planName: string;
  totalRevenue: number;
}

export interface AdminChurnByPlan {
  planName: string;
  lostCount: number;
}

export interface AdminChurnAnalysis {
  lostSubscribersThisMonth: number;
  lostRevenueThisMonth: number;
  churnRate: number;
  churnByPlan: AdminChurnByPlan[];
}

export interface AdminFinancialAnalysis {
  kpis: AdminKpis;
  revenueLast30Days: AdminRevenueData[];
  monthlyRevenueHistory: AdminMonthlyRevenueHistory[];
  weeklyRevenueComparison: AdminWeeklyRevenue;
  revenueByPlan: AdminRevenueByPlan[];
  churnAnalysis: AdminChurnAnalysis;
}

const SUPABASE_PROJECT_ID = "cgqyfpsfymhntumrmbzj";

// --- Fetch Admin Financial Summary ---
const fetchAdminFinancialSummary = async (): Promise<AdminFinancialSummary> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "admin-financial-summary";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao buscar resumo financeiro administrativo.");
  }

  return response.json();
};

export const useAdminFinancialSummary = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();
  return useQuery<AdminFinancialSummary, Error>({
    queryKey: ["adminFinancialSummary", user?.id, role],
    queryFn: fetchAdminFinancialSummary,
    enabled: !isLoadingAuth && !!user?.id && role === 'admin',
    staleTime: 1000 * 60 * 5,
  });
};

// --- Fetch Admin Financial Analysis ---
const fetchAdminFinancialAnalysis = async (): Promise<AdminFinancialAnalysis> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "admin-financial-analysis";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao buscar anÃ¡lise financeira administrativa.");
  }

  return response.json();
};

export const useAdminFinancialAnalysis = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();
  return useQuery<AdminFinancialAnalysis, Error>({
    queryKey: ["adminFinancialAnalysis", user?.id, role],
    queryFn: fetchAdminFinancialAnalysis,
    enabled: !isLoadingAuth && !!user?.id && role === 'admin',
    staleTime: 1000 * 60 * 5,
  });
};

// --- Fetch Admin Financial Entries (CRUD) ---
const fetchAdminFinancialEntries = async (): Promise<AdminFinancialEntry[]> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "admin-financial-entries";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao buscar extrato financeiro administrativo.");
  }

  return response.json();
};

export const useAdminFinancialEntries = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();
  return useQuery<AdminFinancialEntry[], Error>({
    queryKey: ["adminFinancialEntries", user?.id, role],
    queryFn: fetchAdminFinancialEntries,
    enabled: !isLoadingAuth && !!user?.id && role === 'admin',
    staleTime: 1000 * 60,
  });
};

// --- Create Admin Financial Entry ---
const createAdminFinancialEntry = async (newEntry: AdminFinancialEntryInsert): Promise<AdminFinancialEntry> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "admin-financial-entries";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(newEntry),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao criar lanÃ§amento financeiro administrativo.");
  }

  return response.json();
};

export const useCreateAdminFinancialEntry = () => {
  const queryClient = useQueryClient();
  return useMutation<AdminFinancialEntry, Error, AdminFinancialEntryInsert>({
    mutationFn: createAdminFinancialEntry,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['adminFinancialEntries'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialAnalysis'] });
      toast.success("LanÃ§amento financeiro administrativo criado com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao criar lanÃ§amento financeiro administrativo", { description: error.message });
    },
  });
};

// --- Update Admin Financial Entry ---
const updateAdminFinancialEntry = async (updatedEntry: AdminFinancialEntryUpdate & { id: string }): Promise<AdminFinancialEntry> => {
  const { id, ...updateData } = updatedEntry;
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "admin-financial-entries";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}?id=${id}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "PUT",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(updateData),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao atualizar lanÃ§amento financeiro administrativo.");
  }

  return response.json();
};

export const useUpdateAdminFinancialEntry = () => {
  const queryClient = useQueryClient();
  return useMutation<AdminFinancialEntry, Error, AdminFinancialEntryUpdate & { id: string }>({
    mutationFn: updateAdminFinancialEntry,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['adminFinancialEntries'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialAnalysis'] });
      toast.success("LanÃ§amento financeiro administrativo atualizado com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao atualizar lanÃ§amento financeiro administrativo", { description: error.message });
    },
  });
};

// --- Delete Admin Financial Entry ---
const deleteAdminFinancialEntry = async (id: string): Promise<void> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "admin-financial-entries";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}?id=${id}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "DELETE",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao excluir lanÃ§amento financeiro administrativo.");
  }
};

export const useDeleteAdminFinancialEntry = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string>({
    mutationFn: deleteAdminFinancialEntry,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['adminFinancialEntries'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialAnalysis'] });
      toast.success("LanÃ§amento financeiro administrativo excluÃ­do com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao excluir lanÃ§amento financeiro administrativo", { description: error.message });
    },
  });
};
--- ConteÃºdo de: src/hooks/useClients.ts ---
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { Client as BaseClient, ClientInsert, ClientUpdate, ClientStatus, Plan } from '@/integrations/supabase/schema';
import { format } from 'date-fns';
import { useAuth } from '@/contexts/AuthContext'; // Import useAuth

// Estender o tipo Client para incluir as propriedades adicionadas no hook
export interface Client extends BaseClient {
  planDetailsValue?: number | null;
  planDetailsName?: string | null;
}

// O tipo Client jÃ¡ Ã© importado de schema.ts, que jÃ¡ inclui a relaÃ§Ã£o com 'plans'.
// NÃ£o precisamos mais de BaseClient ou de estender Client aqui.

// --- Fetch Clients ---
const fetchClients = async (userId: string, userRole: string | null): Promise<Client[]> => { // Usar o tipo Client estendido
  let query = supabase
    .from('clients')
    .select('*, plans(name, value)') // Seleciona todos os campos do cliente e o 'name' e 'value' do plano
    .order('name');

  // Aplica o filtro APENAS se o usuÃ¡rio NÃO for admin
  if (userRole !== 'admin') {
    query = query.eq('user_id', userId);
  }

  const { data, error } = await query;

  if (error) throw new Error(error.message);
  
  // Mapeia os dados para incluir o valor e o nome do plano diretamente no objeto do cliente
  return data.map(client => ({
    ...client,
    planDetailsValue: (client.plans as Plan | null)?.value, // Atribui o valor do plano Ã  nova propriedade
    planDetailsName: (client.plans as Plan | null)?.name, // Atribui o nome do plano Ã  nova propriedade
  })) as Client[]; // Adiciona type assertion para garantir que o tipo estÃ¡ correto
};

export const useClients = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth(); // Get user and role from AuthContext

  return useQuery<Client[], Error>({ // Usar o tipo Client estendido
    queryKey: ['clients', user?.id, role], // Add role to query key
    queryFn: () => {
      if (!user?.id) throw new Error("UsuÃ¡rio nÃ£o autenticado");
      return fetchClients(user.id, role);
    },
    enabled: !isLoadingAuth && !!user?.id, // Only enable if auth is loaded and user is present
  });
};

// --- Create Client ---
const createClient = async (newClient: ClientInsert): Promise<Client> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("UsuÃ¡rio nÃ£o autenticado");

  const { data, error } = await supabase
    .from('clients')
    .insert({ ...newClient, user_id: user.id })
    .select()
    .single();

  if (error) throw new Error(error.message);
  return data as Client;
};

export const useCreateClient = () => {
  const queryClient = useQueryClient();
  return useMutation<Client, Error, ClientInsert>({
    mutationFn: createClient,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['clients'] });
      queryClient.invalidateQueries({ queryKey: ['dashboardStats'] });
      queryClient.invalidateQueries({ queryKey: ['financialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] });
      queryClient.invalidateQueries({ queryKey: ['automations'] }); // Invalida automaÃ§Ãµes
    },
  });
};

// --- Update Client ---
const updateClient = async (updatedClient: ClientUpdate & { id: string }): Promise<Client> => {
  const { id, ...updateData } = updatedClient;
  const { data, error } = await supabase
    .from('clients')
    .update(updateData)
    .eq('id', id)
    .select()
    .single();

  if (error) throw new Error(error.message);
  return data as Client;
};

export const useUpdateClient = () => {
  const queryClient = useQueryClient();
  return useMutation<Client, Error, ClientUpdate & { id: string }>({
    mutationFn: updateClient,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['clients'] });
      queryClient.invalidateQueries({ queryKey: ['dashboardStats'] });
      queryClient.invalidateQueries({ queryKey: ['financialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] });
      queryClient.invalidateQueries({ queryKey: ['automations'] }); // Invalida automaÃ§Ãµes
    },
  });
};

// --- Delete Client ---
const deleteClient = async (id: string): Promise<void> => {
  const { error } = await supabase
    .from('clients')
    .delete()
    .eq('id', id);

  if (error) throw new Error(error.message);
};

export const useDeleteClient = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string>({
    mutationFn: deleteClient,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['clients'] });
      queryClient.invalidateQueries({ queryKey: ['dashboardStats'] });
      queryClient.invalidateQueries({ queryKey: ['financialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] });
      queryClient.invalidateQueries({ queryKey: ['automations'] }); // Invalida automaÃ§Ãµes
    },
  });
};

// --- Renew Client ---
interface RenewClientParams {
  clientId: string;
  planPeriodDays: number;
  currentNextBillingDate: string;
  clientName: string;
  clientValue: number;
}

const renewClient = async ({ clientId, planPeriodDays, currentNextBillingDate, clientName, clientValue }: RenewClientParams): Promise<void> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("UsuÃ¡rio nÃ£o autenticado");

  const date = new Date(currentNextBillingDate);
  date.setDate(date.getDate() + planPeriodDays);
  const newNextBillingDate = format(date, 'yyyy-MM-dd');

  const { error: updateError } = await supabase
    .from("clients")
    .update({ next_billing_date: newNextBillingDate, status: "active" })
    .eq("id", clientId);

  if (updateError) throw new Error(updateError.message);

  // Registrar a renovaÃ§Ã£o como uma entrada financeira
  const { error: financialError } = await supabase.from("financial_entries").insert({
    user_id: user.id,
    description: `RenovaÃ§Ã£o - ${clientName}`,
    value: clientValue,
    type: "credit",
  });

  if (financialError) {
    console.error("Erro ao registrar entrada financeira de renovaÃ§Ã£o:", financialError.message);
    throw new Error(`Erro ao registrar entrada financeira: ${financialError.message}`);
  }
};

export const useRenewClient = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, RenewClientParams>({
    mutationFn: renewClient,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['clients'] });
      queryClient.invalidateQueries({ queryKey: ['financialEntries'] }); // Invalida extrato
      queryClient.invalidateQueries({ queryKey: ['financialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] });
      queryClient.invalidateQueries({ queryKey: ['automations'] }); // Invalida automaÃ§Ãµes
    },
  });
};

// --- Update Client Status ---
interface UpdateClientStatusParams {
  clientId: string;
  newStatus: ClientStatus;
  clientName: string;
  planId: string;
  planName: string;
  clientValue: number;
}

const updateClientStatus = async ({ clientId, newStatus, clientName, planId, planName, clientValue }: UpdateClientStatusParams): Promise<void> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("UsuÃ¡rio nÃ£o autenticado");

  // Se o status for alterado para 'inactive', registrar evento de churn
  if (newStatus === "inactive") {
    const { error: logError } = await supabase.from("logs").insert({
      user_id: user.id,
      action: "client_churned",
      details: {
        client_id: clientId,
        client_name: clientName,
        plan_id: planId,
        plan_name: planName,
        plan_value: clientValue,
      },
    });
    if (logError) console.error("Erro ao registrar evento de churn:", logError.message);
  }

  const { error } = await supabase
    .from("clients")
    .update({ status: newStatus })
    .eq("id", clientId);

  if (error) throw new Error(error.message);
};

export const useUpdateClientStatus = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, UpdateClientStatusParams>({
    mutationFn: updateClientStatus,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['clients'] });
      queryClient.invalidateQueries({ queryKey: ['dashboardStats'] });
      queryClient.invalidateQueries({ queryKey: ['financialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] });
      queryClient.invalidateQueries({ queryKey: ['automations'] }); // Invalida automaÃ§Ãµes
    },
  });
};

// --- Set Client Due Today ---
interface SetClientDueTodayParams {
  clientId: string;
  clientName: string;
  currentStatus: ClientStatus;
}

const setClientDueToday = async ({ clientId, currentStatus }: SetClientDueTodayParams): Promise<void> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("UsuÃ¡rio nÃ£o autenticado");

  const today = format(new Date(), 'yyyy-MM-dd');
  const newStatus = currentStatus === "inactive" ? "active" : currentStatus;

  const { error } = await supabase
    .from("clients")
    .update({ next_billing_date: today, status: newStatus })
    .eq("id", clientId);

  if (error) throw new Error(error.message);
};

export const useSetClientDueToday = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, SetClientDueTodayParams>({
    mutationFn: setClientDueToday,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['clients'] });
      queryClient.invalidateQueries({ queryKey: ['dashboardStats'] });
      queryClient.invalidateQueries({ queryKey: ['financialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] });
      queryClient.invalidateQueries({ queryKey: ['automations'] }); // Invalida automaÃ§Ãµes
    },
  });
};
--- ConteÃºdo de: src/hooks/useDashboardStats.ts ---
import { useQuery } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/contexts/AuthContext'; // Import useAuth

interface Stats {
  totalClients: number;
  activeClients: number;
  totalPlans: number;
  overdueClients: number;
  migrationNeeded?: boolean;
}

const fetchDashboardStats = async (userId: string, userRole: string | null): Promise<Stats> => {
  let clientsQuery = supabase.from("clients").select("*", { count: "exact" });
  let plansQuery = supabase.from("plans").select("*", { count: "exact" });

  // Apply filter ONLY if the user is NOT an admin
  if (userRole !== 'admin') {
    clientsQuery = clientsQuery.eq("user_id", userId);
    plansQuery = plansQuery.eq("user_id", userId);
  }

  const [clientsResult, plansResult] = await Promise.all([
    clientsQuery,
    plansQuery,
  ]);

  if (clientsResult.error) throw new Error(clientsResult.error.message);
  if (plansResult.error) throw new Error(plansResult.error.message);

  const clients = clientsResult.data || [];
  const activeClients = clients.filter((c) => c.status === "active").length;
  const overdueClients = clients.filter((c) => c.status === "overdue").length;

  // Check if schema migration is needed
  try {
    await supabase.functions.invoke('apply-schema-migration');
  } catch (error) {
    console.log('Migration check:', error);
  }

  return {
    totalClients: clientsResult.count || 0,
    activeClients,
    totalPlans: plansResult.count || 0,
    overdueClients,
  };
};

export const useDashboardStats = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth(); // Get user and role from AuthContext

  return useQuery<Stats, Error>({
    queryKey: ['dashboardStats', user?.id, role], // Add role to query key
    queryFn: () => {
      if (!user?.id) throw new Error("UsuÃ¡rio nÃ£o autenticado");
      return fetchDashboardStats(user.id, role);
    },
    enabled: !isLoadingAuth && !!user?.id, // Only enable if auth is loaded and user is present
    staleTime: 1000 * 60, // 1 minuto de cache
  });
};
--- ConteÃºdo de: src/hooks/useEvolutionLogoutHistory.ts ---
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { EvolutionLogoutHistoryEntry, Json } from '@/integrations/supabase/schema';
import { toast } from "sonner";
import { useAuth } from '@/contexts/AuthContext'; // Import useAuth

interface LogEvolutionLogoutPayload {
  requestPayload: Json;
  responsePayload: Json | null;
  statusCode: number | null;
  errorMessage: string | null;
  instanceName: string;
}

const logEvolutionLogoutHistory = async (payload: LogEvolutionLogoutPayload): Promise<EvolutionLogoutHistoryEntry> => {
  const { requestPayload, responsePayload, statusCode, errorMessage, instanceName } = payload;
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error('UsuÃ¡rio nÃ£o autenticado');

  // Service role bypasses RLS, so no explicit user_id filter needed here.
  const { data, error } = await supabase
    .from('evolution_logout_history')
    .insert({
      user_id: user.id,
      webhook_type: 'n8n_evolution_logout_outbound', // Tipo para logs de logout
      payload: { instanceName, requestPayload, responsePayload, errorMessage },
      request_payload: requestPayload,
      response_payload: responsePayload,
      status_code: statusCode,
    })
    .select()
    .single();

  if (error) {
    console.error('Error inserting into evolution_logout_history:', error.message);
    throw new Error(`Failed to log Evolution logout interaction: ${error.message}`);
  }
  return data as EvolutionLogoutHistoryEntry;
};

export const useLogEvolutionLogoutHistory = () => {
  const queryClient = useQueryClient();
  const { user, role } = useAuth(); // Get user and role from AuthContext

  return useMutation<EvolutionLogoutHistoryEntry, Error, LogEvolutionLogoutPayload>({
    mutationFn: logEvolutionLogoutHistory,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['webhookHistory', 'evolution_logout_history', user?.id, role] }); // Add user.id and role to query key
    },
    onError: (error) => {
      toast.error('Erro ao registrar histÃ³rico de logout', { description: error.message });
    },
  });
};
--- ConteÃºdo de: src/hooks/useFinancialEntries.ts ---
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { FinancialEntry, FinancialEntryInsert, FinancialEntryUpdate } from '@/integrations/supabase/schema';
import { useAuth } from '@/contexts/AuthContext'; // Import useAuth

// --- Fetch Financial Entries ---
const fetchFinancialEntries = async (userId: string, userRole: string | null): Promise<FinancialEntry[]> => {
  let query = supabase
    .from('financial_entries')
    .select('*')
    .order('created_at', { ascending: false });

  // Aplica o filtro APENAS se o usuÃ¡rio NÃO for admin
  if (userRole !== 'admin') {
    query = query.eq('user_id', userId);
  }

  const { data, error } = await query;

  if (error) throw new Error(error.message);
  return data || [];
};

export const useFinancialEntries = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth(); // Get user and role from AuthContext

  return useQuery<FinancialEntry[], Error>({
    queryKey: ['financialEntries', user?.id, role], // Add role to query key
    queryFn: () => {
      if (!user?.id) throw new Error("UsuÃ¡rio nÃ£o autenticado");
      return fetchFinancialEntries(user.id, role);
    },
    enabled: !isLoadingAuth && !!user?.id, // Only enable if auth is loaded and user is present
  });
};

// --- Create Financial Entry ---
const createFinancialEntry = async (newEntry: FinancialEntryInsert): Promise<FinancialEntry> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("UsuÃ¡rio nÃ£o autenticado");

  const { data, error } = await supabase
    .from('financial_entries')
    .insert({ ...newEntry, user_id: user.id })
    .select()
    .single();

  if (error) throw new Error(error.message);
  return data as FinancialEntry;
};

export const useCreateFinancialEntry = () => {
  const queryClient = useQueryClient();
  return useMutation<FinancialEntry, Error, FinancialEntryInsert>({
    mutationFn: createFinancialEntry,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['financialEntries'] });
      queryClient.invalidateQueries({ queryKey: ['financialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] });
    },
  });
};

// --- Update Financial Entry ---
const updateFinancialEntry = async (updatedEntry: FinancialEntryUpdate & { id: string }): Promise<FinancialEntry> => {
  const { id, ...updateData } = updatedEntry;
  const { data, error } = await supabase
    .from('financial_entries')
    .update(updateData)
    .eq('id', id)
    .select()
    .single();

  if (error) throw new Error(error.message);
  return data as FinancialEntry;
};

export const useUpdateFinancialEntry = () => {
  const queryClient = useQueryClient();
  return useMutation<FinancialEntry, Error, FinancialEntryUpdate & { id: string }>({
    mutationFn: updateFinancialEntry,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['financialEntries'] });
      queryClient.invalidateQueries({ queryKey: ['financialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] });
    },
  });
};

// --- Delete Financial Entry ---
const deleteFinancialEntry = async (id: string): Promise<void> => {
  const { error } = await supabase
    .from('financial_entries')
    .delete()
    .eq('id', id);

  if (error) throw new Error(error.message);
};

export const useDeleteFinancialEntry = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string>({
    mutationFn: deleteFinancialEntry,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['financialEntries'] });
      queryClient.invalidateQueries({ queryKey: ['financialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] });
    },
  });
};
--- ConteÃºdo de: src/hooks/useMercadoPagoConfig.ts ---
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { toast } from "sonner";
import { MercadoPagoConfig, MercadoPagoConfigInsert } from '@/integrations/supabase/schema';
import { useAuth } from '@/contexts/AuthContext';

const SUPABASE_PROJECT_ID = "cgqyfpsfymhntumrmbzj";
const EDGE_FUNCTION_NAME = "crud-mercado-pago-configs";
const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

// --- Fetch Mercado Pago Config ---
const fetchMercadoPagoConfig = async (): Promise<MercadoPagoConfig | null> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao buscar configuraÃ§Ãµes do Mercado Pago.");
  }

  return response.json();
};

export const useMercadoPagoConfig = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();
  return useQuery<MercadoPagoConfig | null, Error>({
    queryKey: ["mercadoPagoConfig", user?.id, role],
    queryFn: fetchMercadoPagoConfig,
    enabled: !isLoadingAuth && !!user?.id && role === 'admin',
    staleTime: 1000 * 60 * 5, // Cache por 5 minutos
  });
};

// --- Save Mercado Pago Config (Upsert) ---
const saveMercadoPagoConfig = async (config: MercadoPagoConfigInsert): Promise<MercadoPagoConfig> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST", // Usamos POST para upsert, a Edge Function lida com a lÃ³gica
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(config),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao salvar configuraÃ§Ãµes do Mercado Pago.");
  }

  return response.json();
};

export const useSaveMercadoPagoConfig = () => {
  const queryClient = useQueryClient();
  return useMutation<MercadoPagoConfig, Error, MercadoPagoConfigInsert>({
    mutationFn: saveMercadoPagoConfig,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['mercadoPagoConfig'] });
      toast.success("ConfiguraÃ§Ãµes do Mercado Pago salvas com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao salvar configuraÃ§Ãµes do Mercado Pago", { description: error.message });
    },
  });
};
--- ConteÃºdo de: src/hooks/usePagbankConfig.ts ---
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { toast } from "sonner";
import { useAuth } from '@/contexts/AuthContext';
import { Tables, TablesInsert, TablesUpdate } from '@/integrations/supabase/schema';

// Definir o tipo para a tabela pagbank_configs
export type PagbankConfig = Tables<'pagbank_configs'>;
export type PagbankConfigInsert = TablesInsert<'pagbank_configs'>;
export type PagbankConfigUpdate = TablesUpdate<'pagbank_configs'>;

const SUPABASE_PROJECT_ID = "cgqyfpsfymhntumrmbzj";
const EDGE_FUNCTION_NAME = "crud-pagbank-configs";
const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

// --- Fetch PagBank Config ---
const fetchPagbankConfig = async (): Promise<PagbankConfig | null> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao buscar configuraÃ§Ãµes do PagBank.");
  }

  return response.json();
};

export const usePagbankConfig = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();
  return useQuery<PagbankConfig | null, Error>({
    queryKey: ["pagbankConfig", user?.id, role],
    queryFn: fetchPagbankConfig,
    enabled: !isLoadingAuth && !!user?.id && role === 'admin',
    staleTime: 1000 * 60 * 5, // Cache por 5 minutos
  });
};

// --- Save PagBank Config (Upsert) ---
const savePagbankConfig = async (config: PagbankConfigInsert): Promise<PagbankConfig> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST", // Usamos POST para upsert, a Edge Function lida com a lÃ³gica
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(config),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao salvar configuraÃ§Ãµes do PagBank.");
  }

  return response.json();
};

export const useSavePagbankConfig = () => {
  const queryClient = useQueryClient();
  return useMutation<PagbankConfig, Error, PagbankConfigInsert>({
    mutationFn: savePagbankConfig,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['pagbankConfig'] });
      toast.success("ConfiguraÃ§Ãµes do PagBank salvas com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao salvar configuraÃ§Ãµes do PagBank", { description: error.message });
    },
  });
};
--- ConteÃºdo de: src/hooks/usePlans.ts ---
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { Plan, PlanInsert, PlanUpdate } from '@/integrations/supabase/schema';
import { useAuth } from '@/contexts/AuthContext'; // Import useAuth

// --- Fetch Plans ---
const fetchPlans = async (userId: string, userRole: string | null): Promise<Plan[]> => {
  let query = supabase
    .from('plans')
    .select('*')
    .order('name');

  // Aplica o filtro APENAS se o usuÃ¡rio NÃO for admin
  if (userRole !== 'admin') {
    query = query.eq('user_id', userId);
  }

  const { data, error } = await query;

  if (error) throw new Error(error.message);
  return data || [];
};

export const usePlans = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth(); // Get user and role from AuthContext

  return useQuery<Plan[], Error>({
    queryKey: ['plans', user?.id, role], // Add role to query key
    queryFn: () => {
      if (!user?.id) throw new Error("UsuÃ¡rio nÃ£o autenticado");
      return fetchPlans(user.id, role);
    },
    enabled: !isLoadingAuth && !!user?.id, // Only enable if auth is loaded and user is present
  });
};

// --- Create Plan ---
const createPlan = async (newPlan: PlanInsert): Promise<Plan> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("UsuÃ¡rio nÃ£o autenticado");

  const { data, error } = await supabase
    .from('plans')
    .insert({ ...newPlan, user_id: user.id })
    .select()
    .single();

  if (error) throw new Error(error.message);
  return data as Plan;
};

export const useCreatePlan = () => {
  const queryClient = useQueryClient();
  return useMutation<Plan, Error, PlanInsert>({
    mutationFn: createPlan,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['plans'] });
      queryClient.invalidateQueries({ queryKey: ['dashboardStats'] });
      queryClient.invalidateQueries({ queryKey: ['clients'] }); // Clientes podem precisar de planos atualizados
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] }); // AnÃ¡lise pode depender de planos
    },
  });
};

// --- Update Plan ---
const updatePlan = async (updatedPlan: PlanUpdate & { id: string }): Promise<Plan> => {
  const { id, ...updateData } = updatedPlan;
  const { data, error } = await supabase
    .from('plans')
    .update(updateData)
    .eq('id', id)
    .select()
    .single();

  if (error) throw new Error(error.message);
  return data as Plan;
};

export const useUpdatePlan = () => {
  const queryClient = useQueryClient();
  return useMutation<Plan, Error, PlanUpdate & { id: string }>({
    mutationFn: updatePlan,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['plans'] });
      queryClient.invalidateQueries({ queryKey: ['dashboardStats'] });
      queryClient.invalidateQueries({ queryKey: ['clients'] }); // Clientes podem precisar de planos atualizados
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] }); // AnÃ¡lise pode depender de planos
    },
  });
};

// --- Delete Plan ---
const deletePlan = async (id: string): Promise<void> => {
  const { error } = await supabase
    .from('plans')
    .delete()
    .eq('id', id);

  if (error) throw new Error(error.message);
};

export const useDeletePlan = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string>({
    mutationFn: deletePlan,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['plans'] });
      queryClient.invalidateQueries({ queryKey: ['dashboardStats'] });
      queryClient.invalidateQueries({ queryKey: ['clients'] }); // Clientes podem precisar de planos atualizados
      queryClient.invalidateQueries({ queryKey: ['financialAnalysis'] }); // AnÃ¡lise pode depender de planos
    },
  });
};
--- ConteÃºdo de: src/hooks/useProfileData.ts ---
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { Profile } from '@/integrations/supabase/schema'; // Importar o tipo Profile
import { toast } from "sonner"; // Importar toast

const fetchUserProfile = async (userId: string): Promise<Profile | null> => {
  const { data, error } = await supabase
    .from('profiles')
    .select('*, pix_key, phone, tax_id') // Incluir pix_key, phone e tax_id na seleÃ§Ã£o
    .eq('id', userId)
    .single();

  if (error && error.code !== 'PGRST116') { // PGRST116 = No rows found
    throw new Error(error.message);
  }
  return data;
};

export const useUserProfile = () => {
  return useQuery<Profile | null, Error>({
    queryKey: ['userProfile'],
    queryFn: async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return null;
      return fetchUserProfile(user.id);
    },
  });
};

// NOVO: Hook para buscar dados de perfil e assinatura combinados
export const useProfileAndSubscriptionData = () => {
    const { data: profile, isLoading: isLoadingProfile, error: profileError } = useUserProfile();

    return useQuery({
        queryKey: ['profileAndSubscription', profile?.id], // Adicionar profile.id para re-fetch quando o perfil mudar
        queryFn: async () => {
            if (!profile) throw new Error('Perfil do usuÃ¡rio nÃ£o encontrado.');

            // Buscar a assinatura real do usuÃ¡rio
            const { data: subscriptionData, error: subscriptionError } = await supabase
                .from('subscriptions')
                .select('id, plan_name, price, status, next_billing_date')
                .eq('user_id', profile.id)
                .single();

            if (subscriptionError && subscriptionError.code !== 'PGRST116') {
                throw new Error(subscriptionError.message);
            }

            let subscription = null;
            if (subscriptionData) {
                // Se houver assinatura, buscar o plano correspondente para obter is_free
                const { data: planData, error: planError } = await supabase
                    .from('subscriber_plans')
                    .select('is_free')
                    .eq('name', subscriptionData.plan_name) // Assumindo que plan_name em subscriptions corresponde a name em subscriber_plans
                    .single();

                if (planError && planError.code !== 'PGRST116') {
                    console.error("Erro ao buscar plano de assinante para a assinatura:", planError.message);
                    // Em caso de erro ou plano nÃ£o encontrado, isFree serÃ¡ false por padrÃ£o
                }

                subscription = {
                    id: subscriptionData.id,
                    planName: subscriptionData.plan_name,
                    price: subscriptionData.price,
                    nextBillingDate: subscriptionData.next_billing_date,
                    status: subscriptionData.status,
                    isFree: planData?.is_free || false, // Extrair is_free do planData, ou false se nÃ£o encontrado
                };
            }

            return { profile, subscription };
        },
        enabled: !!profile && !isLoadingProfile && !profileError, // SÃ³ executa esta query se o perfil jÃ¡ tiver sido carregado
        staleTime: 1000 * 60 * 5, // 5 minutos de cache
    });
};

const useUpdateProfile = () => {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: async ({ name, pix_key, phone, tax_id }: { name: string; pix_key: string | null; phone: string | null; tax_id: string | null }) => { // MODIFICADO: tax_id pode ser null
            const { data: { user } } = await supabase.auth.getUser();
            if (!user) throw new Error('Utilizador nÃ£o autenticado');
            
            // Convert empty string to null for tax_id before sending to Supabase
            const taxIdToSave = tax_id === '' ? null : tax_id;

            const { error } = await supabase.from('profiles').update({ name, pix_key, phone, tax_id: taxIdToSave }).eq('id', user.id);
            if (error) throw new Error(error.message);
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['userProfile'] });
            queryClient.invalidateQueries({ queryKey: ['profileAndSubscription'] });
            toast.success('Perfil atualizado com sucesso!');
        },
        onError: (error) => toast.error(`Erro ao atualizar perfil: ${error.message}`),
    });
};

export { useUpdateProfile }; // Exportar o hook useUpdateProfile
--- ConteÃºdo de: src/hooks/useSubscriberManagement.ts ---
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import {
  Profile,
  Enums,
  SubscriberPlan, SubscriberPlanInsert, SubscriberPlanUpdate,
  SubscriberAutomation, SubscriberAutomationInsert, SubscriberAutomationUpdate,
  SubscriberTemplate, SubscriberTemplateInsert, SubscriberTemplateUpdate,
  AppSubscriptionStatus, // Import the manually defined type
} from '@/integrations/supabase/schema';
import { toast } from "sonner";
import { useAuth } from '@/contexts/AuthContext';
import { DateTime } from 'luxon';

const SUPABASE_PROJECT_ID = "cgqyfpsfymhntumrmbzj";

export interface UserWithDetails extends Profile {
  role: Enums<'app_role'>;
  phone: string | null;
  subscription: {
    id: string;
    plan_name: string;
    price: number;
    status: AppSubscriptionStatus; // Use the new type
    next_billing_date: string | null;
    isFree: boolean;
  } | null;
  instance: {
    id: string;
    instance_name: string;
    status: string;
  } | null;
}

const fetchAllUsers = async (): Promise<UserWithDetails[]> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "list-all-users";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao buscar lista de usuÃ¡rios.");
  }

  return response.json();
};

export const useAllUsers = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();
  return useQuery<UserWithDetails[], Error>({
    queryKey: ["allUsers", user?.id, role],
    queryFn: fetchAllUsers,
    enabled: !isLoadingAuth && !!user?.id && role === 'admin',
    staleTime: 1000 * 60,
  });
};

interface UpdateUserRolePayload {
  targetUserId: string;
  newRole: Enums<'app_role'>;
}

const updateUserRole = async (payload: UpdateUserRolePayload): Promise<any> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "update-user-role";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao atualizar funÃ§Ã£o do usuÃ¡rio.");
  }

  return response.json();
};

export const useUpdateUserRole = () => {
  const queryClient = useQueryClient();
  return useMutation<any, Error, UpdateUserRolePayload>({
    mutationFn: updateUserRole,
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['allUsers'] });
      queryClient.invalidateQueries({ queryKey: ['userProfile', variables.targetUserId] });
      queryClient.invalidateQueries({ queryKey: ['profileAndSubscription', variables.targetUserId] });
      toast.success("FunÃ§Ã£o do usuÃ¡rio atualizada com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao atualizar funÃ§Ã£o do usuÃ¡rio", { description: error.message });
    },
  });
};

interface UpdateUserSubscriptionPayload {
  subscriptionId: string;
  userId: string;
  plan_name: string;
  price: number;
  status: AppSubscriptionStatus; // Use the new type
  next_billing_date: string | null;
}

const updateUserSubscription = async (payload: UpdateUserSubscriptionPayload): Promise<any> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "update-user-subscription";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao atualizar assinatura do usuÃ¡rio.");
  }

  return response.json();
};

export const useUpdateUserSubscription = () => {
  const queryClient = useQueryClient();
  return useMutation<any, Error, UpdateUserSubscriptionPayload>({
    mutationFn: updateUserSubscription,
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['allUsers'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialAnalysis'] });
      queryClient.invalidateQueries({ queryKey: ['userProfile', variables.userId] });
      queryClient.invalidateQueries({ queryKey: ['profileAndSubscription', variables.userId] });
      toast.success("Assinatura do usuÃ¡rio atualizada com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao atualizar assinatura do usuÃ¡rio", { description: error.message });
    },
  });
};

interface RenewSubscriberParams {
  subscriptionId: string;
  targetUserId: string;
  planName: string;
  currentNextBillingDate: string;
  price: number;
}

const renewSubscriber = async (payload: RenewSubscriberParams): Promise<any> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "renew-subscriber-subscription";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao renovar assinatura do assinante.");
  }

  return response.json();
};

export const useRenewSubscriber = () => {
  const queryClient = useQueryClient();
  return useMutation<any, Error, RenewSubscriberParams>({
    mutationFn: renewSubscriber,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['allUsers'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialEntries'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialAnalysis'] });
      toast.success("Assinatura renovada com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao renovar assinatura", { description: error.message });
    },
  });
};

interface SetSubscriberDueTodayParams {
  subscriptionId: string;
  targetUserId: string;
  currentStatus: AppSubscriptionStatus; // Use the new type
  price: number;
}

const setSubscriberDueToday = async (payload: SetSubscriberDueTodayParams): Promise<any> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "set-subscriber-due-today";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao definir vencimento para hoje.");
  }

  return response.json();
};

export const useSetSubscriberDueToday = () => {
  const queryClient = useQueryClient();
  return useMutation<any, Error, SetSubscriberDueTodayParams>({
    mutationFn: setSubscriberDueToday,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['allUsers'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialEntries'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialSummary'] });
      queryClient.invalidateQueries({ queryKey: ['adminFinancialAnalysis'] });
      toast.success("Vencimento da assinatura definido para hoje!");
    },
    onError: (error) => {
      toast.error("Erro ao definir vencimento para hoje", { description: error.message });
    },
  });
};

const deleteUser = async (targetUserId: string): Promise<void> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session || !session.user) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "delete-user";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify({ targetUserId }),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao excluir usuÃ¡rio.");
  }
};

export const useDeleteUser = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string>({
    mutationFn: deleteUser,
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['allUsers'] });
      queryClient.invalidateQueries({ queryKey: ['userProfile', variables] });
      queryClient.invalidateQueries({ queryKey: ['profileAndSubscription', variables] });
      toast.success("UsuÃ¡rio excluÃ­do com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao excluir usuÃ¡rio", { description: error.message });
    },
  });
};

const fetchSubscriberPlans = async (): Promise<SubscriberPlan[]> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "crud-subscriber-plans";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao buscar planos de assinantes.");
  }

  return response.json();
};

export const useSubscriberPlans = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();
  return useQuery<SubscriberPlan[], Error>({
    queryKey: ["subscriberPlans", user?.id, role],
    queryFn: fetchSubscriberPlans,
    enabled: !isLoadingAuth && !!user?.id && role === 'admin',
    staleTime: 1000 * 60 * 5,
  });
};

const createSubscriberPlan = async (newPlan: SubscriberPlanInsert): Promise<SubscriberPlan> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "crud-subscriber-plans";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(newPlan),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao criar plano de assinante.");
  }

  return response.json();
};

export const useCreateSubscriberPlan = () => {
  const queryClient = useQueryClient();
  return useMutation<SubscriberPlan, Error, SubscriberPlanInsert>({
    mutationFn: createSubscriberPlan,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['subscriberPlans'] });
      toast.success("Plano de assinante criado com sucesso!");
    },
    onError: (error) => {
      console.error("Erro tÃ©cnico ao criar template de assinante:", error);
      toast.error("Erro ao criar plano de assinante", { description: error.message });
    },
  });
};

const updateSubscriberPlan = async (updatedPlan: SubscriberPlanUpdate & { id: string }): Promise<SubscriberPlan> => {
  console.log('updateSubscriberPlan: FunÃ§Ã£o de mutaÃ§Ã£o iniciada com payload:', updatedPlan);
  const { id, ...updateData } = updatedPlan;
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "crud-subscriber-plans";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}?id=${id}`;

  const fetchOptions: RequestInit = {
    method: "PUT",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(updateData),
  };

  console.log('useUpdateSubscriberPlan: Tentando requisiÃ§Ã£o PUT com opÃ§Ãµes:', fetchOptions);

  const response = await fetch(EDGE_FUNCTION_URL, fetchOptions);

  if (!response.ok) {
    const errorData = await response.json();
    console.error('useUpdateSubscriberPlan: Falha na requisiÃ§Ã£o com errorData:', errorData);
    throw new Error(errorData.error || "Erro ao atualizar plano de assinante.");
  }

  return response.json();
};

export const useUpdateSubscriberPlan = () => {
  const queryClient = useQueryClient();
  return useMutation<SubscriberPlan, Error, SubscriberPlanUpdate & { id: string }>({
    mutationFn: updateSubscriberPlan,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['subscriberPlans'] });
      toast.success("Plano de assinante atualizado com sucesso!");
    },
    onError: (error) => {
      console.error("useUpdateSubscriberPlan: MutaÃ§Ã£o falhou:", error);
      toast.error("Erro ao atualizar plano de assinante", { description: error.message });
    },
  });
};

const deleteSubscriberPlan = async (id: string): Promise<void> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session || !session.user) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const { data: planDetails, error: fetchError } = await supabase
    .from('subscriber_plans')
    .select('is_free, name')
    .eq('id', id)
    .single();

  if (fetchError && fetchError.code !== 'PGRST116') {
    throw new Error(`Erro ao verificar o plano: ${fetchError.message}`);
  }
  if (!planDetails) {
    throw new Error("Plano nÃ£o encontrado.");
  }

  if (planDetails.is_free) {
    console.log(`Attempting direct deletion for free plan: ${planDetails.name} (ID: ${id})`);
    const { error: deleteError } = await supabase
      .from('subscriber_plans')
      .delete()
      .eq('id', id);

    if (deleteError) {
      console.error('Direct deletion failed:', deleteError);
      throw new Error(deleteError.message || "Erro ao excluir plano gratuito diretamente.");
    }
  } else {
    console.log(`Chamando Edge Function DELETE para Plano Pago: https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/crud-subscriber-plans?id=${id}`);
    const EDGE_FUNCTION_NAME = "crud-subscriber-plans";
    const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}?id=${id}`;

    const fetchOptions: RequestInit = {
      method: "DELETE",
      headers: {
        "Authorization": `Bearer ${session.access_token}`,
      },
      body: undefined,
    };

    console.log('useDeleteSubscriberPlan: Tentando requisiÃ§Ã£o DELETE com opÃ§Ãµes:', fetchOptions);

    const response = await fetch(EDGE_FUNCTION_URL, fetchOptions);

    if (!response.ok) {
      const errorData = await response.json();
      console.error('useDeleteSubscriberPlan: Falha na requisiÃ§Ã£o com errorData:', errorData);
      throw new Error(errorData.error || "Erro ao excluir plano de assinante.");
    }
  }
};

export const useDeleteSubscriberPlan = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string>({
    mutationFn: deleteSubscriberPlan,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['subscriberPlans'] });
      toast.success("Plano de assinante excluÃ­do com sucesso!");
    },
    onError: (error) => {
      console.error("useDeleteSubscriberPlan: MutaÃ§Ã£o falhou:", error);
      toast.error("Erro ao excluir plano de assinante", { description: error.message });
    },
  });
};

const fetchSubscriberTemplates = async (): Promise<SubscriberTemplate[]> => {
  const { data: { session } = {} } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "crud-subscriber-templates";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao buscar templates de assinantes.");
  }

  return response.json();
};

export const useSubscriberTemplates = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();
  return useQuery<SubscriberTemplate[], Error>({
    queryKey: ["subscriberTemplates", user?.id, role],
    queryFn: fetchSubscriberTemplates,
    enabled: !isLoadingAuth && !!user?.id && role === 'admin',
    staleTime: 1000 * 60 * 5,
  });
};

const createSubscriberTemplate = async (newTemplate: SubscriberTemplateInsert): Promise<SubscriberTemplate> => {
  const { data: { session } = {} } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "crud-subscriber-templates";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(newTemplate),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao criar template de assinante.");
  }

  return response.json();
};

export const useCreateSubscriberTemplate = () => {
  const queryClient = useQueryClient();
  return useMutation<SubscriberTemplate, Error, SubscriberTemplateInsert>({
    mutationFn: createSubscriberTemplate,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['subscriberTemplates'] });
      toast.success("Template de assinante criado com sucesso!");
    },
    onError: (error) => {
      console.error("Erro tÃ©cnico ao criar template de assinante:", error);
      toast.error("Erro ao criar template de assinante", { description: error.message });
    },
  });
};

const updateSubscriberTemplate = async (updatedTemplate: SubscriberTemplateUpdate & { id: string }): Promise<SubscriberTemplate> => {
  const { id, ...updateData } = updatedTemplate;
  const { data: { session } = {} } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "crud-subscriber-templates";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}?id=${id}`;

  const fetchOptions: RequestInit = {
    method: "PUT",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(updateData),
  };

  console.log('useUpdateSubscriberTemplate: Tentando requisiÃ§Ã£o PUT com opÃ§Ãµes:', fetchOptions);

  const response = await fetch(EDGE_FUNCTION_URL, fetchOptions);

  if (!response.ok) {
    const errorData = await response.json();
    console.error('useUpdateSubscriberTemplate: Falha na requisiÃ§Ã£o com errorData:', errorData);
    throw new Error(errorData.error || "Erro ao atualizar template de assinante.");
  }

  return response.json();
};

export const useUpdateSubscriberTemplate = () => {
  const queryClient = useQueryClient();
  return useMutation<SubscriberTemplate, Error, SubscriberTemplateUpdate & { id: string }>({
    mutationFn: updateSubscriberTemplate,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['subscriberTemplates'] });
      toast.success("Template de assinante atualizado com sucesso!");
    },
    onError: (error) => {
      console.error("Erro tÃ©cnico ao atualizar template de assinante:", error);
      toast.error("Erro ao atualizar template de assinante", { description: error.message });
    },
  });
};

const deleteSubscriberTemplate = async (id: string): Promise<void> => {
  const { data: { session } = {} } = await supabase.auth.getSession();
  if (!session || !session.user) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "crud-subscriber-templates";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}?id=${id}`;

  const fetchOptions: RequestInit = {
    method: "DELETE",
    headers: {
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: undefined,
  };

  console.log('useDeleteSubscriberTemplate: Tentando requisiÃ§Ã£o DELETE com opÃ§Ãµes:', fetchOptions);

  const response = await fetch(EDGE_FUNCTION_URL, fetchOptions);

  if (!response.ok) {
    const errorData = await response.json();
    console.error('useDeleteSubscriberTemplate: Falha na requisiÃ§Ã£o com errorData:', errorData);
    throw new Error(errorData.error || "Erro ao excluir template de assinante.");
  }
};

export const useDeleteSubscriberTemplate = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string>({
    mutationFn: deleteSubscriberTemplate,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['subscriberTemplates'] });
      toast.success("Template de assinante excluÃ­do com sucesso!");
    },
    onError: (error) => {
      console.error("Erro tÃ©cnico ao excluir template de assinante:", error);
      toast.error("Erro ao excluir template de assinante", { description: error.message });
    },
  });
};

const fetchSubscriberAutomations = async (): Promise<SubscriberAutomation[]> => {
  const { data: { session } = {} } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "crud-subscriber-automations";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao buscar automaÃ§Ãµes de assinantes.");
  }

  return response.json();
};

export const useSubscriberAutomations = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();
  return useQuery<SubscriberAutomation[], Error>({
    queryKey: ["subscriberAutomations", user?.id, role],
    queryFn: fetchSubscriberAutomations,
    enabled: !isLoadingAuth && !!user?.id && role === 'admin',
    staleTime: 1000 * 60,
  });
};

interface ScheduleSubscriberNotificationsPayload {
  automation: SubscriberAutomation;
  subscribers: UserWithDetails[];
}

const scheduleSubscriberNotificationsForRule = async (payload: ScheduleSubscriberNotificationsPayload) => {
  const { automation, subscribers } = payload;
  const { data: { session } = {} } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const notificationsToInsert: { user_id: string; subscriber_template_id: string; send_at: string; status: 'pending' }[] = [];
  const SAO_PAULO_TIMEZONE = 'America/Sao_Paulo';
  const [scheduledHour, scheduledMinute] = automation.scheduled_time.split(':').map(Number);
  const now = DateTime.now();

  const relevantSubscribers = subscribers.filter(s =>
    automation.subscriber_ids.includes(s.id) && s.subscription?.status === 'active'
  );

  for (const subscriber of relevantSubscribers) {
    if (!subscriber.subscription?.next_billing_date) continue;

    const localBillingDate = DateTime.fromISO(subscriber.subscription.next_billing_date, { zone: SAO_PAULO_TIMEZONE }).startOf('day');
    const targetDate = localBillingDate.plus({ days: automation.days_offset });

    const localTargetDateTime = targetDate.set({
        hour: scheduledHour,
        minute: scheduledMinute
    });

    const sendAtUtcIso = localTargetDateTime.toUTC().toISO();

    if (!sendAtUtcIso) {
        console.warn(`Skipping notification for subscriber ${subscriber.id} due to invalid date/time conversion.`);
        continue;
    }

    if (localTargetDateTime.toMillis() >= now.toMillis() - (60 * 1000)) {
        notificationsToInsert.push({
            user_id: subscriber.id,
            subscriber_template_id: automation.subscriber_template_id,
            send_at: sendAtUtcIso,
            status: 'pending',
        });
    }
  }

  if (notificationsToInsert.length === 0) {
      console.log("Nenhuma notificaÃ§Ã£o futura para agendar para esta regra de assinante.");
      return { success: true, message: 'Nenhuma notificaÃ§Ã£o futura para agendar.' };
  }

  const EDGE_FUNCTION_NAME = "schedule-subscriber-notifications";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
      method: "POST",
      headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${session.access_token}`,
      },
      body: JSON.stringify({ automationId: automation.id, notifications: notificationsToInsert }),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao invocar a Edge Function de agendamento de assinantes.");
  }

  return response.json();
};

export const useScheduleSubscriberNotificationsForRule = () => {
  const queryClient = useQueryClient();
  return useMutation<any, Error, ScheduleSubscriberNotificationsPayload>({
    mutationFn: scheduleSubscriberNotificationsForRule,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['scheduledNotifications'] });
      queryClient.invalidateQueries({ queryKey: ['connectionMetrics'] });
      toast.success('Fila de envios para assinantes agendada com sucesso!');
    },
    onError: (error) => toast.error(`Erro ao agendar fila de envios para assinantes: ${error.message}`),
  });
};

export const useCreateSubscriberAutomation = () => {
  const queryClient = useQueryClient();
  const scheduleMutation = useScheduleSubscriberNotificationsForRule();
  const { data: allUsers } = useAllUsers();

  // Omit admin_user_id from the input type as it's added internally
  type CreatePayload = Omit<SubscriberAutomationInsert, 'admin_user_id'>;

  return useMutation<SubscriberAutomation, Error, CreatePayload>({
    mutationFn: async (newAutomationData) => {
      const { data: { session } = {} } = await supabase.auth.getSession();
      if (!session || !session.user) throw new Error("UsuÃ¡rio nÃ£o autenticado");

      const { data, error } = await supabase
        .from('subscriber_automations')
        .insert({ ...newAutomationData, admin_user_id: session.user.id })
        .select()
        .single();

      if (error) throw new Error(error.message);
      return data as SubscriberAutomation;
    },
    onSuccess: async (newAutomation) => {
      queryClient.invalidateQueries({ queryKey: ['subscriberAutomations'] });
      queryClient.invalidateQueries({ queryKey: ['connectionMetrics'] });
      toast.success('AutomaÃ§Ã£o de assinante criada!');

      if (allUsers) {
        await scheduleMutation.mutateAsync({
          automation: newAutomation,
          subscribers: allUsers,
        });
      }
    },
    onError: (error) => toast.error(`Erro ao criar automaÃ§Ã£o de assinante: ${error.message}`),
  });
};

export const useUpdateSubscriberAutomation = () => {
  const queryClient = useQueryClient();
  const scheduleMutation = useScheduleSubscriberNotificationsForRule();
  const { data: allUsers } = useAllUsers();

  // Omit admin_user_id from the input type as it's handled internally
  type UpdatePayload = Omit<SubscriberAutomationUpdate, 'admin_user_id'> & { id: string };

  return useMutation<SubscriberAutomation, Error, UpdatePayload>({
    mutationFn: async (updatedAutomationData) => {
      const { id, ...updateData } = updatedAutomationData;
      const { data: { session } = {} } = await supabase.auth.getSession();
      if (!session || !session.user) throw new Error("UsuÃ¡rio nÃ£o autenticado");

      const { data, error } = await supabase
        .from('subscriber_automations')
        .update(updateData)
        .eq('id', id)
        .eq('admin_user_id', session.user.id)
        .select()
        .single();

      if (error) throw new Error(error.message);
      return data as SubscriberAutomation;
    },
    onSuccess: async (updatedAutomation) => {
      queryClient.invalidateQueries({ queryKey: ['subscriberAutomations'] });
      queryClient.invalidateQueries({ queryKey: ['connectionMetrics'] });
      toast.success('AutomaÃ§Ã£o de assinante atualizada!');

      if (allUsers) {
        await scheduleMutation.mutateAsync({
          automation: updatedAutomation,
          subscribers: allUsers,
        });
      }
    },
    onError: (error) => toast.error(`Erro ao atualizar automaÃ§Ã£o de assinante: ${error.message}`),
  });
};

const deleteSubscriberAutomation = async (id: string): Promise<void> => {
  const { data: { session } = {} } = await supabase.auth.getSession();
  if (!session || !session.user) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  await supabase
    .from('scheduled_notifications')
    .delete()
    .eq('automation_id', id)
    .eq('user_id', session.user.id)
    .eq('type', 'subscriber_notification');

  const { error } = await supabase
    .from('subscriber_automations')
    .delete()
    .eq('id', id)
    .eq('admin_user_id', session.user.id);

  if (error) throw new Error(error.message);
};

export const useDeleteSubscriberAutomation = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string>({
    mutationFn: deleteSubscriberAutomation,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['subscriberAutomations'] });
      queryClient.invalidateQueries({ queryKey: ['connectionMetrics'] });
      queryClient.invalidateQueries({ queryKey: ['scheduledNotifications'] });
      toast.success('AutomaÃ§Ã£o de assinante excluÃ­da e agendamentos removidos!');
    },
    onError: (error) => toast.error(`Erro ao excluir automaÃ§Ã£o de assinante: ${error.message}`),
  });
};

const fetchN8nMessageSenderUrl = async (): Promise<string | null> => {
  const { data: { session } = {} } = await supabase.auth.getSession();
  if (!session || !session.user) throw new Error('UsuÃ¡rio nÃ£o autenticado');

  const { data, error } = await supabase
    .from('webhook_configs')
    .select('url')
    .eq('type', 'n8n_message_sender')
    .maybeSingle();

  if (error) throw error;
  return data?.url || null;
};

export const useN8nMessageSenderUrl = () => {
  const { user, role, isLoading: isLoadingAuth } = useAuth();
  return useQuery<string | null, Error>({
    queryKey: ['n8nMessageSenderUrl', user?.id, role],
    queryFn: fetchN8nMessageSenderUrl,
    enabled: !isLoadingAuth && !!user?.id && role === 'admin',
    staleTime: 1000 * 60 * 5,
  });
};

interface SendSubscriberMessagePayload {
  n8nWebhookUrl: string;
  subscriber: UserWithDetails;
  templateId: string;
  renderedTextContent: string;
}

const sendSubscriberMessageViaWebhook = async ({ n8nWebhookUrl, subscriber, templateId, renderedTextContent }: SendSubscriberMessagePayload) => {
  const { data: { session } = {} } = await supabase.auth.getSession();
  const adminUser = session?.user;
  if (!adminUser) throw new Error('Administrador nÃ£o autenticado');

  const { data: adminUserInstance, error: instanceError } = await supabase
    .from('user_instances')
    .select('instance_name')
    .eq('user_id', adminUser.id)
    .single();

  if (instanceError || !adminUserInstance?.instance_name) {
    throw new Error('Nenhuma instÃ¢ncia do WhatsApp configurada para o administrador. Por favor, conecte o WhatsApp em "ConexÃ£o > WhatsApp".');
  }
  const instanceName = adminUserInstance.instance_name;

  const requestBody = {
    body: [
      {
        instanceName: instanceName,
        contact_name: subscriber.name,
        number: subscriber.phone,
        text: renderedTextContent,
        mode: "real"
      }
    ]
  };

  let statusCode: number | null = null;
  let responsePayload: any = null;
  let errorMessage: string | null = null;

  try {
    const response = await fetch(n8nWebhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody),
    });

    statusCode = response.status;
    
    try {
      responsePayload = await response.json();
    } catch (jsonError) {
      responsePayload = await response.text();
      console.warn("Webhook response was not JSON, read as text.", jsonError);
    }

    if (!response.ok) {
      errorMessage = responsePayload?.message || response.statusText || `O servidor de automaÃ§Ã£o retornou um erro com status ${statusCode}.`;
      throw new Error(errorMessage || 'An unknown error occurred during webhook processing.');
    }

    return { success: true, statusCode };

  } catch (error: any) {
    errorMessage = error.message;
    console.error("Erro ao enviar mensagem via webhook para assinante:", error);
    throw new Error(errorMessage || 'An unknown error occurred.');
  } finally {
    await supabase
      .from('n8n_message_sender_history')
      .insert({
        user_id: adminUser.id,
        client_id: subscriber.id,
        template_id: templateId,
        webhook_type: 'n8n_message_outbound_subscriber',
        payload: requestBody,
        request_payload: requestBody,
        response_payload: responsePayload,
        status_code: statusCode,
        client_name_snapshot: subscriber.name,
      });
  }
};

export const useSendSubscriberMessageWebhook = () => {
  const queryClient = useQueryClient();
  return useMutation<any, Error, SendSubscriberMessagePayload>({
    mutationFn: sendSubscriberMessageViaWebhook,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['webhookHistory', 'n8n_message_sender_history', 'n8n_message_outbound_subscriber'] });
    },
  });
};

interface UpdateUserInstanceStatusPayload {
  instanceId: string;
  newStatus: string;
}

const updateUserInstanceStatus = async (payload: UpdateUserInstanceStatusPayload): Promise<any> => {
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) throw new Error("UsuÃ¡rio nÃ£o autenticado.");

  const EDGE_FUNCTION_NAME = "update-user-instance-status";
  const EDGE_FUNCTION_URL = `https://${SUPABASE_PROJECT_ID}.supabase.co/functions/v1/${EDGE_FUNCTION_NAME}`;

  const response = await fetch(EDGE_FUNCTION_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${session.access_token}`,
    },
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || "Erro ao atualizar status da instÃ¢ncia do usuÃ¡rio.");
  }

  return response.json();
};

export const useUpdateUserInstanceStatus = () => {
  const queryClient = useQueryClient();
  return useMutation<any, Error, UpdateUserInstanceStatusPayload>({
    mutationFn: updateUserInstanceStatus,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['allUsers'] });
      queryClient.invalidateQueries({ queryKey: ['userInstance'] });
      toast.success("Status da instÃ¢ncia atualizado com sucesso!");
    },
    onError: (error) => {
      toast.error("Erro ao atualizar status da instÃ¢ncia", { description: error.message });
    },
  });
};
--- ConteÃºdo de: src/hooks/useTemplates.ts ---
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";
import { Tables } from "@/integrations/supabase/schema"; // Importar Tables do schema

// Tipos para os dados do template
export interface Template extends Tables<'templates'> {
  // A interface Tables<'templates'> jÃ¡ inclui todos os campos e a tipagem correta (user_id: string | null)
  // NÃ£o precisamos redefinir os campos aqui, apenas estender para garantir que o tipo seja o esperado.
}

// Hook para buscar todos os templates do usuÃ¡rio
export const useTemplates = () => {
  return useQuery<Template[], Error>({
    queryKey: ["templates"],
    queryFn: async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error("Utilizador nÃ£o autenticado");

      // Verificar se o perfil do usuÃ¡rio existe
      const { data: _profileData, error: profileError } = await supabase // Renomeado para _profileData
        .from("profiles")
        .select("id, name, email, tax_id")
        .eq("id", user.id)
        .single();

      if (profileError && profileError.code === 'PGRST116') { // No rows found
        // Perfil nÃ£o existe, criar um novo
        const { error: insertProfileError } = await supabase.from("profiles").insert({
          id: user.id,
          email: user.email!, // O email do usuÃ¡rio Ã© obrigatÃ³rio
          name: user.user_metadata?.full_name || user.email!, // Usar o nome completo se disponÃ­vel, caso contrÃ¡rio, o email
          phone: null, // Inicializar phone como null
          pix_key: null, // Inicializar pix_key como null
          tax_id: "", // Inicializar tax_id como uma string vazia, pois Ã© um campo obrigatÃ³rio
        });

        if (insertProfileError) {
          console.error("Erro ao criar perfil:", insertProfileError.message);
          throw new Error("Erro ao criar perfil do usuÃ¡rio.");
        }
      } else if (profileError) {
        console.error("Erro ao buscar perfil:", profileError.message);
        throw new Error("Erro ao buscar perfil do usuÃ¡rio.");
      }

      const { data, error } = await supabase
        .from("templates")
        .select("*")
        .or(`user_id.eq.${user.id},type.eq.global,user_id.is.null`) // MODIFICADO: Incluir templates do usuÃ¡rio, globais e padrÃ£o (user_id nulo)
        .order("created_at", { ascending: false });

      if (error) throw new Error(error.message);
      return data as Template[]; // Adicionar type assertion
    },
  });
};

// Hook para criar um novo template
export const useCreateTemplate = () => {
  const queryClient = useQueryClient();
  return useMutation<Template, Error, Omit<Tables<'templates'>, "id" | "created_at" | "updated_at">>({
    mutationFn: async (newTemplate) => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error("Utilizador nÃ£o autenticado");

      const { data, error } = await supabase
        .from("templates")
        .insert({ ...newTemplate, user_id: user.id })
        .select()
        .single();

      if (error) throw new Error(error.message);
      return data as Template; // Adicionar type assertion
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["templates"] });
      toast.success("Template criado com sucesso!");
    },
    onError: (error) => toast.error(`Erro ao criar template: ${error.message}`),
  });
};

// Hook para atualizar um template existente
export const useUpdateTemplate = () => {
  const queryClient = useQueryClient();
  return useMutation<Template, Error, Partial<Tables<'templates'>> & { id: string }>({
    mutationFn: async (updatedTemplate) => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error("Utilizador nÃ£o autenticado");

      const { id, ...updates } = updatedTemplate;
      const { data, error } = await supabase
        .from("templates")
        .update(updates)
        .eq("id", id!)
        .eq("user_id", user.id)
        .select()
        .single();

      if (error) throw new Error(error.message);
      return data as Template; // Adicionar type assertion
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["templates"] });
      toast.success("Template atualizado com sucesso!");
    },
    onError: (error) => toast.error(`Erro ao atualizar template: ${error.message}`),
  });
};

// Hook para deletar um template
export const useDeleteTemplate = () => {
  const queryClient = useQueryClient();
  return useMutation<void, Error, string>({
    mutationFn: async (templateId) => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error("Utilizador nÃ£o autenticado");

      const { error } = await supabase
        .from("templates")
        .delete()
        .eq("id", templateId)
        .eq("user_id", user.id);

      if (error) throw new Error(error.message);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["templates"] });
      toast.success("Template deletado com sucesso!");
    },
    onError: (error) => toast.error(`Erro ao deletar template: ${error.message}`),
  });
};
--- ConteÃºdo de: src/hooks/useWebhookConfig.ts ---
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { WebhookConfig } from '@/integrations/supabase/schema';
import { toast } from "sonner";
// Removed: import { useAuth } from '@/contexts/AuthContext'; // Import useAuth

// A interface WebhookConfig jÃ¡ Ã© exportada do schema.ts

const fetchWebhookConfig = async (type: string): Promise<WebhookConfig | null> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error('UsuÃ¡rio nÃ£o autenticado');

  // RLS will handle access based on role. For SELECT, any authenticated user can read.
  const { data, error } = await supabase
    .from('webhook_configs')
    .select('*')
    .eq('type', type) // Removed .eq('user_id', user.id)
    .maybeSingle();

  if (error) throw error;
  return data;
};

export const useWebhookConfig = (type: string) => {
  return useQuery<WebhookConfig | null, Error>({
    queryKey: ['webhookConfig', type],
    queryFn: () => fetchWebhookConfig(type),
  });
};

const saveWebhookConfig = async (type: string, url: string): Promise<WebhookConfig> => {
  const { data: { session } } = await supabase.auth.getSession(); // Corrected: Destructure 'session'
  if (!session || !session.user) throw new Error('UsuÃ¡rio nÃ£o autenticado'); // Corrected: Check 'session' and 'session.user'

  // The user_id is still passed, but RLS will ensure only admins can perform upsert.
  const { data, error } = await supabase
    .from('webhook_configs')
    .upsert({
      user_id: session.user.id, // user_id is still a column, but RLS controls who can modify it
      type,
      url,
      payload: {}, // Adicionado para satisfazer o campo 'payload' obrigatÃ³rio
    }, {
      onConflict: 'type' // Changed onConflict to 'type' since it's global per type
    })
    .select()
    .single();

  if (error) throw error;
  return data;
};

export const useSaveWebhookConfig = () => {
  const queryClient = useQueryClient();

  return useMutation<WebhookConfig, Error, { type: string; url: string }>({
    mutationFn: ({ type, url }) => saveWebhookConfig(type, url),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['webhookConfig', variables.type] });
      toast.success('ConfiguraÃ§Ã£o salva!', { description: 'URL do webhook atualizada com sucesso.' });
    },
    onError: (error) => {
      toast.error('Erro ao salvar', { description: error.message });
    },
  });
};
--- ConteÃºdo de: src/hooks/useWebhookHistory.ts ---
import { useQuery } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { Json } from '@/integrations/supabase/schema'; // Importar Json do schema
import { useAuth } from '@/contexts/AuthContext'; // Import useAuth

// Definir uma interface base que todas as tabelas de histÃ³rico devem seguir
interface BaseHistoryEntry {
  id: string;
  user_id: string | null; // Pode ser null se o user_id nÃ£o for encontrado no momento do log
  webhook_type: string;
  payload: Json;
  request_payload: Json | null;
  response_payload: Json | null;
  status_code: number | null;
  timestamp: string;
  client_id: string | null;
  template_id: string | null;
  client_name_snapshot: string | null;
}

// Definir os nomes das tabelas de histÃ³rico permitidos
type HistoryTableNames = 'evolution_api_history' | 'n8n_qr_code_history' | 'n8n_message_sender_history' | 'webhook_history' | 'evolution_logout_history';

// A funÃ§Ã£o de fetch agora Ã© genÃ©rica e retorna um array do tipo T
const fetchWebhookHistory = async <T extends BaseHistoryEntry>(
  tableName: HistoryTableNames,
  webhookTypes: string | string[] | null,
  userId: string,
  userRole: string | null
): Promise<T[]> => {
  let query = supabase
    .from(tableName)
    .select('*');

  // Apply filter ONLY if the user is NOT an admin
  if (userRole !== 'admin') {
    query = query.eq('user_id', userId);
  }

  if (webhookTypes && (Array.isArray(webhookTypes) ? webhookTypes.length > 0 : true)) {
    const types = Array.isArray(webhookTypes) ? webhookTypes : [webhookTypes];
    query = query.in('webhook_type', types);
  }

  const { data, error } = await query
    .order('timestamp', { ascending: false })
    .limit(50);

  if (error) {
    console.error(`Error fetching webhook history from ${tableName}:`, error.message);
    throw new Error(`Failed to fetch history from ${tableName}: ${error.message}`);
  }
  return data as T[] || [];
};

// O hook useWebhookHistory tambÃ©m Ã© genÃ©rico
export const useWebhookHistory = <T extends BaseHistoryEntry>(
  tableName: HistoryTableNames,
  webhookTypes?: string | string[] | null
) => {
  const { user, role, isLoading: isLoadingAuth } = useAuth(); // Get user and role from AuthContext

  const typesKey = Array.isArray(webhookTypes) ? webhookTypes.join(',') : (webhookTypes === null ? 'all_inbound' : webhookTypes || 'all');
  
  return useQuery<T[], Error>({
    queryKey: ['webhookHistory', tableName, typesKey, user?.id, role], // Add user.id and role to query key
    queryFn: () => {
      if (!user?.id) throw new Error("UsuÃ¡rio nÃ£o autenticado");
      return fetchWebhookHistory<T>(tableName, webhookTypes || null, user.id, role); // Explicitly pass null if webhookTypes is undefined
    },
    enabled: !isLoadingAuth && !!user?.id, // Only enable if auth is loaded and user is present
    refetchInterval: 5000, // Atualiza a cada 5 segundos
  });
};======================================
  7. SCHEMA COMPLETO COM POLÃTICAS DE SEGURANÃA (RLS)
======================================



SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


CREATE EXTENSION IF NOT EXISTS "pg_cron" WITH SCHEMA "pg_catalog";






COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "pg_net" WITH SCHEMA "public";






CREATE EXTENSION IF NOT EXISTS "http" WITH SCHEMA "public";






CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE TYPE "public"."app_role" AS ENUM (
    'admin',
    'user'
);


ALTER TYPE "public"."app_role" OWNER TO "postgres";


CREATE TYPE "public"."app_subscription_status" AS ENUM (
    'active',
    'inactive',
    'overdue'
);


ALTER TYPE "public"."app_subscription_status" OWNER TO "postgres";


CREATE TYPE "public"."client_status" AS ENUM (
    'active',
    'inactive',
    'overdue'
);


ALTER TYPE "public"."client_status" OWNER TO "postgres";


CREATE TYPE "public"."pagbank_environment" AS ENUM (
    'sandbox',
    'production'
);


ALTER TYPE "public"."pagbank_environment" OWNER TO "postgres";


CREATE TYPE "public"."template_type" AS ENUM (
    'normal',
    'global'
);


ALTER TYPE "public"."template_type" OWNER TO "postgres";


CREATE TYPE "public"."transaction_type" AS ENUM (
    'credit',
    'debit'
);


ALTER TYPE "public"."transaction_type" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_client_cancellation"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  -- A funÃ§Ã£o sÃ³ executa se o status foi alterado PARA 'inactive'
  IF NEW.status = 'inactive' AND OLD.status != 'inactive' THEN
    
    -- AÃ§Ã£o 1: Remover o cliente de todas as futuras mensagens agendadas
    DELETE FROM public.pending_sends
    WHERE client_id = NEW.id;

    -- AÃ§Ã£o 2: Remover o ID do cliente de todas as regras de automaÃ§Ã£o
    -- onde ele possa estar presente.
    UPDATE public.automations
    SET client_ids = array_remove(client_ids, NEW.id)
    WHERE user_id = NEW.user_id AND NEW.id = ANY(client_ids);

  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_client_cancellation"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_client_overdue_status"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  -- A funÃ§Ã£o sÃ³ executa se o status foi alterado PARA 'overdue'
  IF NEW.status = 'overdue' AND OLD.status != 'overdue' THEN
    
    -- AÃ§Ã£o: Remove o cliente de todas as futuras mensagens agendadas
    DELETE FROM public.pending_sends
    WHERE client_id = NEW.id;

  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_client_overdue_status"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  default_plan RECORD;
BEGIN
  -- 1. Inserir na tabela profiles
  INSERT INTO public.profiles (id, name, email, phone) -- Adicionado 'phone'
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'name', split_part(NEW.email, '@', 1)),
    NEW.email,
    NEW.raw_user_meta_data->>'phone' -- Tenta pegar o telefone do metadata
  );

  -- 2. Inserir na tabela user_roles
  INSERT INTO public.user_roles (user_id, role)
  VALUES (NEW.id, 'user');

  -- 3. Buscar o "Plano Inicial" dinamicamente
  SELECT name, value, period_days
  INTO default_plan
  FROM public.subscriber_plans
  WHERE name = 'Plano Inicial'
  LIMIT 1;

  -- 4. Inserir na tabela subscriptions usando o Plano Inicial
  IF default_plan IS NOT NULL THEN
    INSERT INTO public.subscriptions (user_id, plan_name, price, status, next_billing_date)
    VALUES (
      NEW.id,
      default_plan.name,
      default_plan.value,
      'active',
      (NOW() + (default_plan.period_days || ' days')::INTERVAL)::date
    );
  ELSE
    -- Fallback: Se o Plano Inicial nÃ£o existir, usar valores padrÃ£o
    INSERT INTO public.subscriptions (user_id, plan_name, price, status, next_billing_date)
    VALUES (NEW.id, 'Plano Gratuito', 0.00, 'active', (NOW() + INTERVAL '30 days')::date);
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_new_user"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."prevent_default_plan_deletion"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  IF OLD.name = 'Plano Inicial' THEN
    RAISE EXCEPTION 'NÃ£o Ã© permitido excluir o Plano Inicial. VocÃª pode editÃ¡-lo se necessÃ¡rio.';
  END IF;
  RETURN OLD;
END;
$$;


ALTER FUNCTION "public"."prevent_default_plan_deletion"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_automated_notifications"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
    current_utc_hour INTEGER := EXTRACT(HOUR FROM NOW() AT TIME ZONE 'UTC');
    automation_record RECORD;
    client_record RECORD;
    template_content TEXT;
    n8n_webhook_url TEXT;
    rendered_message TEXT;
    request_body JSONB;
    http_response_status_code INTEGER;
    http_response_body TEXT;
    user_id_for_log UUID;
BEGIN
    -- Get the n8n webhook URL once
    SELECT url INTO n8n_webhook_url
    FROM public.webhook_configs
    WHERE type = 'n8n_message_sender'
    LIMIT 1;

    IF n8n_webhook_url IS NULL THEN
        RAISE WARNING 'N8N message sender webhook URL not configured. Skipping automated notifications.';
        RETURN;
    END IF;

    -- Loop through automations matching the current UTC hour
    FOR automation_record IN
        SELECT
            a.id AS automation_id,
            a.user_id,
            a.days_offset,
            a.template_id,
            a.client_ids,
            t.content AS template_content,
            p.name AS plan_name_placeholder, -- Placeholder for plan name
            p.value AS plan_value_placeholder -- Placeholder for plan value
        FROM
            public.automations a
        JOIN
            public.templates t ON a.template_id = t.id
        LEFT JOIN
            public.plans p ON t.id = p.id -- Join with plans to get plan details if template is related
        WHERE
            EXTRACT(HOUR FROM a.scheduled_time) = current_utc_hour
    LOOP
        user_id_for_log := automation_record.user_id;

        -- Loop through clients associated with this automation
        FOR client_record IN
            SELECT
                c.id AS client_id,
                c.name AS customer_name,
                c.phone,
                c.value,
                c.next_billing_date,
                cp.name AS client_plan_name, -- Actual plan name from client's plan_id
                cp.value AS client_plan_value -- Actual plan value from client's plan_id
            FROM
                public.clients c
            LEFT JOIN
                public.plans cp ON c.plan_id = cp.id
            WHERE
                c.id = ANY(automation_record.client_ids)
                AND c.user_id = automation_record.user_id
                AND c.status IN ('active', 'overdue')
                AND c.next_billing_date = (CURRENT_DATE + (automation_record.days_offset * INTERVAL '1 day'))::DATE
        LOOP
            -- Replace placeholders
            rendered_message := REPLACE(automation_record.template_content, '{{customer_name}}', client_record.customer_name);
            rendered_message := REPLACE(rendered_message, '{{plan_name}}', COALESCE(client_record.client_plan_name, 'Plano Desconhecido'));
            rendered_message := REPLACE(rendered_message, '{{due_date}}', TO_CHAR(client_record.next_billing_date, 'DD/MM/YYYY'));
            rendered_message := REPLACE(rendered_message, '{{value}}', TO_CHAR(client_record.value, 'FM999G999G999D00'));

            -- Construct request body for n8n
            request_body := JSONB_BUILD_OBJECT(
                'body', JSONB_BUILD_ARRAY(
                    JSONB_BUILD_OBJECT(
                        'contact_name', client_record.customer_name,
                        'number', client_record.phone,
                        'text', rendered_message,
                        'mode', 'real'
                    )
                )
            );

            -- Make HTTP POST request to n8n
            BEGIN
                SELECT status, content INTO http_response_status_code, http_response_body
                FROM http_post(
                    n8n_webhook_url,
                    request_body::TEXT,
                    'application/json'
                );

                -- Log to webhook_history
                INSERT INTO public.webhook_history (user_id, webhook_type, payload, status_code, timestamp)
                VALUES (
                    user_id_for_log,
                    'n8n_message_outbound_automated',
                    request_body,
                    http_response_status_code,
                    NOW()
                );

            EXCEPTION
                WHEN OTHERS THEN
                    RAISE WARNING 'Error sending automated notification for client %: %', client_record.client_id, SQLERRM;
                    -- Log error to webhook_history
                    INSERT INTO public.webhook_history (user_id, webhook_type, payload, status_code, timestamp)
                    VALUES (
                        user_id_for_log,
                        'n8n_message_outbound_automated',
                        request_body,
                        500, -- Internal Server Error for HTTP call failure
                        NOW()
                    );
            END;

        END LOOP;
    END LOOP;
END;
$$;


ALTER FUNCTION "public"."process_automated_notifications"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_notification_queue"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
    notification_record RECORD;
    edge_function_url TEXT;
    supabase_project_id TEXT := 'cgqyfpsfymhntumrmbzj';
    edge_function_name TEXT := 'send-scheduled-notification';
BEGIN
    RAISE NOTICE 'DEBUG: Iniciando process_notification_queue (versÃ£o http_request)...';

    edge_function_url := 'https://' || supabase_project_id || '.supabase.co/functions/v1/' || edge_function_name;

    FOR notification_record IN
        SELECT id FROM public.scheduled_notifications
        WHERE status = 'pending' AND send_at <= NOW()
        FOR UPDATE SKIP LOCKED
    LOOP
        RAISE NOTICE 'DEBUG: Processando notificaÃ§Ã£o ID: %', notification_record.id;

        -- CORREÃÃO: Nome da tabela corrigido de 'public.scheduled.notifications' para 'public.scheduled_notifications'
        UPDATE public.scheduled_notifications
        SET status = 'processing'
        WHERE id = notification_record.id;

        -- Usando a construÃ§Ã£o explÃ­cita do objeto http_request com a schema 'extensions'
        PERFORM extensions.http((
            'POST',
            edge_function_url,
            ARRAY[extensions.http_header('Content-Type', 'application/json')],
            'application/json',
            jsonb_build_object('id', notification_record.id)::text
        )::extensions.http_request);

        RAISE NOTICE 'DEBUG: NotificaÃ§Ã£o ID % delegada para a Edge Function.', notification_record.id;
    END LOOP;

    RAISE NOTICE 'DEBUG: Finalizado o processamento da fila.';
END;
$$;


ALTER FUNCTION "public"."process_notification_queue"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_client_status_based_on_due_date"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
DECLARE
  local_today DATE;
BEGIN
  -- ObtÃ©m a data de hoje no fuso horÃ¡rio 'America/Sao_Paulo'
  local_today := (NOW() AT TIME ZONE 'America/Sao_Paulo')::DATE;

  -- Apenas atualiza o status se nÃ£o for 'inactive' (cancelado)
  IF NEW.status != 'inactive' THEN
    -- Se a data de vencimento for anterior a local_today, define o status como 'overdue'
    IF NEW.next_billing_date < local_today THEN
      NEW.status := 'overdue';
    -- Caso contrÃ¡rio, se for local_today ou no futuro, define o status como 'active'
    ELSE
      NEW.status := 'active';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_client_status_based_on_due_date"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_subscription_status_based_on_plan_and_due_date"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  plan_is_free BOOLEAN;
  local_today DATE;
BEGIN
  -- ObtÃ©m a data de hoje no fuso horÃ¡rio 'America/Sao_Paulo'
  local_today := (NOW() AT TIME ZONE 'America/Sao_Paulo')::DATE;

  -- Busca se o plano associado Ã© gratuito
  SELECT sp.is_free INTO plan_is_free
  FROM public.subscriber_plans sp
  WHERE sp.name = NEW.plan_name
  LIMIT 1;

  -- Se o plano for gratuito, o status Ã© sempre 'active' e next_billing_date Ã© NULL
  IF plan_is_free THEN
    NEW.status := 'active';
    NEW.next_billing_date := NULL;
  ELSE
    -- Se o plano nÃ£o for gratuito, verifica a data de vencimento
    IF NEW.next_billing_date IS NULL THEN
      -- Se nÃ£o for gratuito e nÃ£o tiver data de vencimento, Ã© inativo
      NEW.status := 'inactive';
    ELSIF NEW.next_billing_date < local_today THEN
      NEW.status := 'overdue';
    ELSE
      NEW.status := 'active';
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_subscription_status_based_on_plan_and_due_date"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_templates_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_templates_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_updated_at_column"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_updated_at_column"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."active_payment_gateway" (
    "id" bigint DEFAULT 1 NOT NULL,
    "gateway_name" "text" NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."active_payment_gateway" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."admin_financial_entries" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "admin_user_id" "uuid",
    "subscriber_id" "uuid",
    "description" "text" NOT NULL,
    "value" numeric NOT NULL,
    "type" "public"."transaction_type" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."admin_financial_entries" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."automations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "days_offset" integer NOT NULL,
    "template_id" "uuid" NOT NULL,
    "client_ids" "uuid"[] NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "scheduled_time" time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL
);


ALTER TABLE "public"."automations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."clients" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "phone" "text" NOT NULL,
    "email" "text",
    "notes" "text",
    "plan_id" "uuid",
    "due_date" "date" NOT NULL,
    "next_billing_date" "date" NOT NULL,
    "status" "public"."client_status" DEFAULT 'active'::"public"."client_status" NOT NULL,
    "value" numeric(10,2) NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."clients" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."connection_status" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "instance_name" "text" NOT NULL,
    "status" "text" DEFAULT 'disconnected'::"text" NOT NULL,
    "qr_code_base64" "text",
    "last_updated" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."connection_status" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."evolution_api_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "webhook_type" "text" NOT NULL,
    "payload" "jsonb" NOT NULL,
    "request_payload" "jsonb",
    "response_payload" "jsonb",
    "status_code" integer,
    "timestamp" timestamp with time zone DEFAULT "now"(),
    "client_id" "uuid",
    "template_id" "uuid",
    "client_name_snapshot" "text"
);


ALTER TABLE "public"."evolution_api_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."evolution_logout_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "webhook_type" "text" NOT NULL,
    "payload" "jsonb" NOT NULL,
    "request_payload" "jsonb",
    "response_payload" "jsonb",
    "status_code" integer,
    "timestamp" timestamp with time zone DEFAULT "now"(),
    "client_id" "uuid",
    "template_id" "uuid",
    "client_name_snapshot" "text"
);


ALTER TABLE "public"."evolution_logout_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."financial_entries" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "description" "text" NOT NULL,
    "value" numeric(10,2) NOT NULL,
    "type" "public"."transaction_type" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."financial_entries" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "action" "text" NOT NULL,
    "details" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."mercado_pago_charges" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "subscription_id" "uuid" NOT NULL,
    "mercado_pago_payment_id" "text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "value" numeric NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."mercado_pago_charges" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."mercado_pago_configs" (
    "id" bigint DEFAULT 1 NOT NULL,
    "mercado_pago_public_key" "text" NOT NULL,
    "mercado_pago_access_token" "text" NOT NULL,
    "mercado_pago_client_id" "text" NOT NULL,
    "mercado_pago_client_secret" "text" NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "enforce_single_row" CHECK (("id" = 1))
);


ALTER TABLE "public"."mercado_pago_configs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."n8n_message_sender_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "webhook_type" "text" NOT NULL,
    "payload" "jsonb" NOT NULL,
    "request_payload" "jsonb",
    "response_payload" "jsonb",
    "status_code" integer,
    "timestamp" timestamp with time zone DEFAULT "now"(),
    "client_id" "uuid",
    "template_id" "uuid",
    "client_name_snapshot" "text"
);


ALTER TABLE "public"."n8n_message_sender_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."n8n_qr_code_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "webhook_type" "text" NOT NULL,
    "payload" "jsonb" NOT NULL,
    "request_payload" "jsonb",
    "response_payload" "jsonb",
    "status_code" integer,
    "timestamp" timestamp with time zone DEFAULT "now"(),
    "client_id" "uuid",
    "template_id" "uuid",
    "client_name_snapshot" "text"
);


ALTER TABLE "public"."n8n_qr_code_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."pagbank_charges" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "subscription_id" "uuid" NOT NULL,
    "pagbank_charge_id" "text" NOT NULL,
    "status" "text" DEFAULT 'PENDING'::"text" NOT NULL,
    "value" numeric NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."pagbank_charges" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."pagbank_configs" (
    "id" bigint DEFAULT 1 NOT NULL,
    "pagbank_email" "text" NOT NULL,
    "pagbank_token" "text" NOT NULL,
    "pagbank_pix_key" "text" NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "environment" "public"."pagbank_environment" DEFAULT 'sandbox'::"public"."pagbank_environment" NOT NULL
);


ALTER TABLE "public"."pagbank_configs" OWNER TO "postgres";


COMMENT ON COLUMN "public"."pagbank_configs"."environment" IS 'Ambiente da API PagBank a ser utilizado (sandbox ou production).';



CREATE TABLE IF NOT EXISTS "public"."pending_sends" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "client_id" "uuid" NOT NULL,
    "automation_id" "uuid" NOT NULL,
    "template_id" "uuid" NOT NULL,
    "scheduled_for" "date" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."pending_sends" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."plans" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "value" numeric(10,2) NOT NULL,
    "period_days" integer NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."plans" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."profiles" (
    "id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "email" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "pix_key" "text",
    "phone" "text",
    "tax_id" "text" DEFAULT ''::"text"
);


ALTER TABLE "public"."profiles" OWNER TO "postgres";


COMMENT ON COLUMN "public"."profiles"."pix_key" IS 'Chave PIX do usuÃ¡rio para recebimento de pagamentos.';



COMMENT ON COLUMN "public"."profiles"."phone" IS 'NÃºmero de telefone do usuÃ¡rio, obrigatÃ³rio para usuÃ¡rios nÃ£o-admin.';



COMMENT ON COLUMN "public"."profiles"."tax_id" IS 'CPF ou CNPJ do usuÃ¡rio (apenas nÃºmeros). ObrigatÃ³rio.';



CREATE TABLE IF NOT EXISTS "public"."scheduled_notifications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "client_id" "uuid" NOT NULL,
    "template_id" "uuid" NOT NULL,
    "automation_id" "uuid" NOT NULL,
    "send_at" timestamp with time zone NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "type" "text" DEFAULT 'client_notification'::"text" NOT NULL
);


ALTER TABLE "public"."scheduled_notifications" OWNER TO "postgres";


COMMENT ON COLUMN "public"."scheduled_notifications"."type" IS 'Type of notification: client_notification or subscriber_notification.';



CREATE TABLE IF NOT EXISTS "public"."send_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "client_id" "uuid" NOT NULL,
    "template_id" "uuid" NOT NULL,
    "sent_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "status" "text" NOT NULL,
    "error_message" "text",
    CONSTRAINT "send_history_status_check" CHECK (("status" = ANY (ARRAY['success'::"text", 'failed'::"text"])))
);


ALTER TABLE "public"."send_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."subscriber_automations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "admin_user_id" "uuid",
    "days_offset" integer NOT NULL,
    "subscriber_template_id" "uuid",
    "subscriber_ids" "uuid"[] NOT NULL,
    "scheduled_time" time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."subscriber_automations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."subscriber_plans" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "value" numeric NOT NULL,
    "period_days" integer NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "is_free" boolean DEFAULT false NOT NULL
);


ALTER TABLE "public"."subscriber_plans" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."subscriber_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "admin_user_id" "uuid",
    "name" "text" NOT NULL,
    "content" "text" NOT NULL,
    "type" "public"."template_type" DEFAULT 'normal'::"public"."template_type" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."subscriber_templates" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."subscriptions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "plan_name" "text" NOT NULL,
    "price" numeric(10,2) NOT NULL,
    "status" "public"."app_subscription_status" DEFAULT 'inactive'::"public"."app_subscription_status" NOT NULL,
    "next_billing_date" "date",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."subscriptions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "name" "text" NOT NULL,
    "content" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "type" "public"."template_type" DEFAULT 'normal'::"public"."template_type" NOT NULL
);


ALTER TABLE "public"."templates" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."url_configs" (
    "id" integer DEFAULT 1 NOT NULL,
    "n8n_webhook_url" "text" NOT NULL,
    "evolution_listener_url" "text" NOT NULL,
    CONSTRAINT "single_row_check" CHECK (("id" = 1))
);


ALTER TABLE "public"."url_configs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_instances" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "instance_name" "text" NOT NULL,
    "status" "text" DEFAULT 'disconnected'::"text" NOT NULL,
    "qr_code_base64" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."user_instances" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_roles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "role" "public"."app_role" DEFAULT 'user'::"public"."app_role" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."user_roles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."webhook_configs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "type" "text" NOT NULL,
    "url" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."webhook_configs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."webhook_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "webhook_type" "text" NOT NULL,
    "payload" "jsonb" NOT NULL,
    "status_code" integer,
    "timestamp" timestamp with time zone DEFAULT "now"() NOT NULL,
    "request_payload" "jsonb",
    "response_payload" "jsonb",
    "client_id" "uuid",
    "template_id" "uuid",
    "client_name_snapshot" "text"
);


ALTER TABLE "public"."webhook_history" OWNER TO "postgres";


COMMENT ON COLUMN "public"."webhook_history"."client_name_snapshot" IS 'Snapshot of the client name at the time of the webhook call. Used to preserve history even if client is deleted.';



ALTER TABLE ONLY "public"."active_payment_gateway"
    ADD CONSTRAINT "active_payment_gateway_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."admin_financial_entries"
    ADD CONSTRAINT "admin_financial_entries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."automations"
    ADD CONSTRAINT "automations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."connection_status"
    ADD CONSTRAINT "connection_status_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."connection_status"
    ADD CONSTRAINT "connection_status_user_id_instance_name_key" UNIQUE ("user_id", "instance_name");



ALTER TABLE ONLY "public"."evolution_api_history"
    ADD CONSTRAINT "evolution_api_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."evolution_logout_history"
    ADD CONSTRAINT "evolution_logout_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."financial_entries"
    ADD CONSTRAINT "financial_entries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."logs"
    ADD CONSTRAINT "logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."mercado_pago_charges"
    ADD CONSTRAINT "mercado_pago_charges_mercado_pago_payment_id_key" UNIQUE ("mercado_pago_payment_id");



ALTER TABLE ONLY "public"."mercado_pago_charges"
    ADD CONSTRAINT "mercado_pago_charges_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."mercado_pago_configs"
    ADD CONSTRAINT "mercado_pago_configs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."n8n_message_sender_history"
    ADD CONSTRAINT "n8n_message_sender_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."n8n_qr_code_history"
    ADD CONSTRAINT "n8n_qr_code_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."pagbank_charges"
    ADD CONSTRAINT "pagbank_charges_pagbank_charge_id_key" UNIQUE ("pagbank_charge_id");



ALTER TABLE ONLY "public"."pagbank_charges"
    ADD CONSTRAINT "pagbank_charges_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."pagbank_configs"
    ADD CONSTRAINT "pagbank_configs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."pending_sends"
    ADD CONSTRAINT "pending_sends_client_id_automation_id_scheduled_for_key" UNIQUE ("client_id", "automation_id", "scheduled_for");



ALTER TABLE ONLY "public"."pending_sends"
    ADD CONSTRAINT "pending_sends_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."plans"
    ADD CONSTRAINT "plans_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."scheduled_notifications"
    ADD CONSTRAINT "scheduled_notifications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."send_history"
    ADD CONSTRAINT "send_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."subscriber_automations"
    ADD CONSTRAINT "subscriber_automations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."subscriber_plans"
    ADD CONSTRAINT "subscriber_plans_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."subscriber_templates"
    ADD CONSTRAINT "subscriber_templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."subscriptions"
    ADD CONSTRAINT "subscriptions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."subscriptions"
    ADD CONSTRAINT "subscriptions_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."templates"
    ADD CONSTRAINT "templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."url_configs"
    ADD CONSTRAINT "url_configs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_instances"
    ADD CONSTRAINT "user_instances_instance_name_key" UNIQUE ("instance_name");



ALTER TABLE ONLY "public"."user_instances"
    ADD CONSTRAINT "user_instances_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_instances"
    ADD CONSTRAINT "user_instances_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_user_id_role_key" UNIQUE ("user_id", "role");



ALTER TABLE ONLY "public"."webhook_configs"
    ADD CONSTRAINT "webhook_configs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."webhook_configs"
    ADD CONSTRAINT "webhook_configs_user_id_type_key" UNIQUE ("user_id", "type");



ALTER TABLE ONLY "public"."webhook_history"
    ADD CONSTRAINT "webhook_history_pkey" PRIMARY KEY ("id");



CREATE INDEX "idx_profiles_phone" ON "public"."profiles" USING "btree" ("phone");



CREATE INDEX "idx_webhook_history_client_name_snapshot" ON "public"."webhook_history" USING "btree" ("client_name_snapshot");



CREATE UNIQUE INDEX "unique_standard_template_name" ON "public"."templates" USING "btree" ("name") WHERE ("user_id" IS NULL);



CREATE OR REPLACE TRIGGER "prevent_default_plan_deletion_trigger" BEFORE DELETE ON "public"."subscriber_plans" FOR EACH ROW EXECUTE FUNCTION "public"."prevent_default_plan_deletion"();



CREATE OR REPLACE TRIGGER "trigger_handle_client_cancellation" AFTER UPDATE ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."handle_client_cancellation"();



CREATE OR REPLACE TRIGGER "trigger_handle_client_overdue_status" AFTER UPDATE ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."handle_client_overdue_status"();



CREATE OR REPLACE TRIGGER "trigger_set_client_status" BEFORE INSERT OR UPDATE ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."set_client_status_based_on_due_date"();



CREATE OR REPLACE TRIGGER "trigger_set_subscription_status" BEFORE INSERT OR UPDATE ON "public"."subscriptions" FOR EACH ROW EXECUTE FUNCTION "public"."set_subscription_status_based_on_plan_and_due_date"();



CREATE OR REPLACE TRIGGER "update_automations_updated_at" BEFORE UPDATE ON "public"."automations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_clients_updated_at" BEFORE UPDATE ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_plans_updated_at" BEFORE UPDATE ON "public"."plans" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_profiles_updated_at" BEFORE UPDATE ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_subscriber_automations_updated_at" BEFORE UPDATE ON "public"."subscriber_automations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_subscriber_plans_updated_at" BEFORE UPDATE ON "public"."subscriber_plans" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_subscriber_templates_updated_at" BEFORE UPDATE ON "public"."subscriber_templates" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_subscriptions_updated_at" BEFORE UPDATE ON "public"."subscriptions" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_templates_updated_at" BEFORE UPDATE ON "public"."templates" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_user_instances_updated_at" BEFORE UPDATE ON "public"."user_instances" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_webhook_configs_updated_at" BEFORE UPDATE ON "public"."webhook_configs" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



ALTER TABLE ONLY "public"."admin_financial_entries"
    ADD CONSTRAINT "admin_financial_entries_admin_user_id_fkey" FOREIGN KEY ("admin_user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."admin_financial_entries"
    ADD CONSTRAINT "admin_financial_entries_subscriber_id_fkey" FOREIGN KEY ("subscriber_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."automations"
    ADD CONSTRAINT "automations_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."templates"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."automations"
    ADD CONSTRAINT "automations_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_plan_id_fkey" FOREIGN KEY ("plan_id") REFERENCES "public"."plans"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."connection_status"
    ADD CONSTRAINT "connection_status_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."evolution_api_history"
    ADD CONSTRAINT "evolution_api_history_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."evolution_api_history"
    ADD CONSTRAINT "evolution_api_history_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."templates"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."evolution_api_history"
    ADD CONSTRAINT "evolution_api_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."evolution_logout_history"
    ADD CONSTRAINT "evolution_logout_history_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."evolution_logout_history"
    ADD CONSTRAINT "evolution_logout_history_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."templates"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."evolution_logout_history"
    ADD CONSTRAINT "evolution_logout_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."financial_entries"
    ADD CONSTRAINT "financial_entries_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."logs"
    ADD CONSTRAINT "logs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mercado_pago_charges"
    ADD CONSTRAINT "mercado_pago_charges_subscription_id_fkey" FOREIGN KEY ("subscription_id") REFERENCES "public"."subscriptions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mercado_pago_charges"
    ADD CONSTRAINT "mercado_pago_charges_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."n8n_message_sender_history"
    ADD CONSTRAINT "n8n_message_sender_history_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."n8n_message_sender_history"
    ADD CONSTRAINT "n8n_message_sender_history_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."templates"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."n8n_message_sender_history"
    ADD CONSTRAINT "n8n_message_sender_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."n8n_qr_code_history"
    ADD CONSTRAINT "n8n_qr_code_history_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."n8n_qr_code_history"
    ADD CONSTRAINT "n8n_qr_code_history_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."templates"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."n8n_qr_code_history"
    ADD CONSTRAINT "n8n_qr_code_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."pagbank_charges"
    ADD CONSTRAINT "pagbank_charges_subscription_id_fkey" FOREIGN KEY ("subscription_id") REFERENCES "public"."subscriptions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."pagbank_charges"
    ADD CONSTRAINT "pagbank_charges_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."pending_sends"
    ADD CONSTRAINT "pending_sends_automation_id_fkey" FOREIGN KEY ("automation_id") REFERENCES "public"."automations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."pending_sends"
    ADD CONSTRAINT "pending_sends_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."pending_sends"
    ADD CONSTRAINT "pending_sends_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."templates"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."pending_sends"
    ADD CONSTRAINT "pending_sends_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."plans"
    ADD CONSTRAINT "plans_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."scheduled_notifications"
    ADD CONSTRAINT "scheduled_notifications_automation_id_fkey" FOREIGN KEY ("automation_id") REFERENCES "public"."automations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."scheduled_notifications"
    ADD CONSTRAINT "scheduled_notifications_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."scheduled_notifications"
    ADD CONSTRAINT "scheduled_notifications_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."templates"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."scheduled_notifications"
    ADD CONSTRAINT "scheduled_notifications_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."send_history"
    ADD CONSTRAINT "send_history_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."send_history"
    ADD CONSTRAINT "send_history_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."templates"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."send_history"
    ADD CONSTRAINT "send_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."subscriber_automations"
    ADD CONSTRAINT "subscriber_automations_admin_user_id_fkey" FOREIGN KEY ("admin_user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."subscriber_automations"
    ADD CONSTRAINT "subscriber_automations_subscriber_template_id_fkey" FOREIGN KEY ("subscriber_template_id") REFERENCES "public"."subscriber_templates"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."subscriber_templates"
    ADD CONSTRAINT "subscriber_templates_admin_user_id_fkey" FOREIGN KEY ("admin_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."subscriptions"
    ADD CONSTRAINT "subscriptions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."templates"
    ADD CONSTRAINT "templates_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_instances"
    ADD CONSTRAINT "user_instances_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."webhook_configs"
    ADD CONSTRAINT "webhook_configs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."webhook_history"
    ADD CONSTRAINT "webhook_history_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."clients"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."webhook_history"
    ADD CONSTRAINT "webhook_history_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."templates"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."webhook_history"
    ADD CONSTRAINT "webhook_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



CREATE POLICY "Admins can delete Mercado Pago charges" ON "public"."mercado_pago_charges" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can delete admin financial entries" ON "public"."admin_financial_entries" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can delete subscriber automations" ON "public"."subscriber_automations" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can delete subscriber plans" ON "public"."subscriber_plans" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can delete subscriber templates" ON "public"."subscriber_templates" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can insert Mercado Pago charges" ON "public"."mercado_pago_charges" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can insert PagBank configs" ON "public"."pagbank_configs" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can insert active payment gateway" ON "public"."active_payment_gateway" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can insert admin financial entries" ON "public"."admin_financial_entries" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can insert subscriber automations" ON "public"."subscriber_automations" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can insert subscriber plans" ON "public"."subscriber_plans" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can insert subscriber templates" ON "public"."subscriber_templates" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can manage Mercado Pago configs" ON "public"."mercado_pago_configs" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can manage webhook configs" ON "public"."webhook_configs" TO "authenticated" USING ((( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")) WITH CHECK ((( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role"));



CREATE POLICY "Admins can update Mercado Pago charges" ON "public"."mercado_pago_charges" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can update PagBank configs" ON "public"."pagbank_configs" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can update active payment gateway" ON "public"."active_payment_gateway" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can update admin financial entries" ON "public"."admin_financial_entries" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can update subscriber automations" ON "public"."subscriber_automations" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can update subscriber plans" ON "public"."subscriber_plans" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can update subscriber templates" ON "public"."subscriber_templates" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can view Mercado Pago configs" ON "public"."mercado_pago_configs" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can view PagBank configs" ON "public"."pagbank_configs" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can view all Mercado Pago charges" ON "public"."mercado_pago_charges" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can view all admin financial entries" ON "public"."admin_financial_entries" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can view all subscriber automations" ON "public"."subscriber_automations" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can view all subscriber plans" ON "public"."subscriber_plans" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Admins can view all subscriber templates" ON "public"."subscriber_templates" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))));



CREATE POLICY "Allow authenticated users to read their own, standard, or globa" ON "public"."templates" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR ("user_id" IS NULL) OR ("type" = 'global'::"public"."template_type")));



CREATE POLICY "Allow users to delete normal templates and admins to delete any" ON "public"."templates" FOR DELETE TO "authenticated" USING (((("auth"."uid"() = "user_id") AND ("type" = 'normal'::"public"."template_type")) OR (EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role"))))));



CREATE POLICY "Allow users to insert normal templates and admins to insert any" ON "public"."templates" FOR INSERT TO "authenticated" WITH CHECK (((("auth"."uid"() = "user_id") AND ("type" = 'normal'::"public"."template_type")) OR (EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role"))))));



CREATE POLICY "Allow users to update normal templates and admins to update any" ON "public"."templates" FOR UPDATE TO "authenticated" USING (((("auth"."uid"() = "user_id") AND ("type" = 'normal'::"public"."template_type")) OR (EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role")))))) WITH CHECK (((("auth"."uid"() = "user_id") AND ("type" = 'normal'::"public"."template_type")) OR (EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role"))))));



CREATE POLICY "Authenticated users can read url configs" ON "public"."url_configs" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can read webhook configs" ON "public"."webhook_configs" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can view active payment gateway" ON "public"."active_payment_gateway" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Users can delete their own Mercado Pago charges" ON "public"."mercado_pago_charges" FOR DELETE TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can delete their own connection status OR Admins can dele" ON "public"."connection_status" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can delete their own financial entries OR Admins can dele" ON "public"."financial_entries" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can delete their own logs OR Admins can delete for others" ON "public"."logs" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can delete their own profile OR Admins can delete for oth" ON "public"."profiles" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can delete their own scheduled notifications OR Admins ca" ON "public"."scheduled_notifications" FOR DELETE TO "authenticated" USING (((("auth"."uid"() = "user_id") AND ("type" = 'client_notification'::"text")) OR (EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role"))))));



CREATE POLICY "Users can delete their own send history OR Admins can delete fo" ON "public"."send_history" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can delete their own subscription OR Admins can delete fo" ON "public"."subscriptions" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can delete their own webhook history OR Admins can delete" ON "public"."webhook_history" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can insert their own Mercado Pago charges" ON "public"."mercado_pago_charges" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can insert their own connection status OR Admins can inse" ON "public"."connection_status" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can insert their own financial entries OR Admins can inse" ON "public"."financial_entries" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can insert their own logs OR Admins can insert for others" ON "public"."logs" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can insert their own scheduled notifications OR Admins ca" ON "public"."scheduled_notifications" FOR INSERT TO "authenticated" WITH CHECK (((("auth"."uid"() = "user_id") AND ("type" = 'client_notification'::"text")) OR (EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role"))))));



CREATE POLICY "Users can insert their own send history OR Admins can insert fo" ON "public"."send_history" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can insert their own subscription OR Admins can insert fo" ON "public"."subscriptions" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can insert their own webhook history OR Admins can insert" ON "public"."webhook_history" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can manage their own automations OR Admins can manage all" ON "public"."automations" TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role"))) WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can manage their own clients OR Admins can manage all" ON "public"."clients" TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role"))) WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can manage their own instance mapping OR Admins can manag" ON "public"."user_instances" TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role"))) WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can manage their own pending sends" ON "public"."pending_sends" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can manage their own plans OR Admins can manage all" ON "public"."plans" TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role"))) WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can manage their own role" ON "public"."user_roles" TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can update their own Mercado Pago charges" ON "public"."mercado_pago_charges" FOR UPDATE TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can update their own connection status OR Admins can upda" ON "public"."connection_status" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can update their own financial entries OR Admins can upda" ON "public"."financial_entries" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can update their own logs OR Admins can update for others" ON "public"."logs" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can update their own profile OR Admins can update for oth" ON "public"."profiles" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can update their own scheduled notifications OR Admins ca" ON "public"."scheduled_notifications" FOR UPDATE TO "authenticated" USING (((("auth"."uid"() = "user_id") AND ("type" = 'client_notification'::"text")) OR (EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role"))))));



CREATE POLICY "Users can update their own send history OR Admins can update fo" ON "public"."send_history" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can update their own subscription OR Admins can update fo" ON "public"."subscriptions" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can update their own webhook history OR Admins can update" ON "public"."webhook_history" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can view their own Mercado Pago charges" ON "public"."mercado_pago_charges" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view their own PagBank charges" ON "public"."pagbank_charges" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role"))))));



CREATE POLICY "Users can view their own connection status OR Admins can view a" ON "public"."connection_status" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can view their own financial entries OR Admins can view a" ON "public"."financial_entries" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can view their own logs OR Admins can view all" ON "public"."logs" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can view their own profile OR Admins can view all" ON "public"."profiles" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can view their own role" ON "public"."user_roles" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view their own scheduled notifications OR Admins can " ON "public"."scheduled_notifications" FOR SELECT TO "authenticated" USING (((("auth"."uid"() = "user_id") AND ("type" = 'client_notification'::"text")) OR (EXISTS ( SELECT 1
   FROM "public"."user_roles"
  WHERE (("user_roles"."user_id" = "auth"."uid"()) AND ("user_roles"."role" = 'admin'::"public"."app_role"))))));



CREATE POLICY "Users can view their own send history OR Admins can view all" ON "public"."send_history" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can view their own subscription OR Admins can view all" ON "public"."subscriptions" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "Users can view their own webhook history OR Admins can view all" ON "public"."webhook_history" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



ALTER TABLE "public"."active_payment_gateway" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."admin_financial_entries" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."automations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."clients" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."connection_status" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."evolution_api_history" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "evolution_api_history_delete_policy OR Admins can delete for ot" ON "public"."evolution_api_history" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "evolution_api_history_insert_policy OR Admins can insert for ot" ON "public"."evolution_api_history" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "evolution_api_history_select_policy OR Admins can view all" ON "public"."evolution_api_history" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "evolution_api_history_update_policy OR Admins can update for ot" ON "public"."evolution_api_history" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



ALTER TABLE "public"."evolution_logout_history" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "evolution_logout_history_delete_policy OR Admins can delete for" ON "public"."evolution_logout_history" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "evolution_logout_history_insert_policy OR Admins can insert for" ON "public"."evolution_logout_history" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "evolution_logout_history_select_policy OR Admins can view all" ON "public"."evolution_logout_history" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "evolution_logout_history_update_policy OR Admins can update for" ON "public"."evolution_logout_history" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



ALTER TABLE "public"."financial_entries" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."mercado_pago_charges" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."mercado_pago_configs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."n8n_message_sender_history" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "n8n_message_sender_history_delete_policy OR Admins can delete f" ON "public"."n8n_message_sender_history" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "n8n_message_sender_history_insert_policy OR Admins can insert f" ON "public"."n8n_message_sender_history" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "n8n_message_sender_history_select_policy OR Admins can view all" ON "public"."n8n_message_sender_history" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "n8n_message_sender_history_update_policy OR Admins can update f" ON "public"."n8n_message_sender_history" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



ALTER TABLE "public"."n8n_qr_code_history" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "n8n_qr_code_history_delete_policy OR Admins can delete for othe" ON "public"."n8n_qr_code_history" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "n8n_qr_code_history_insert_policy OR Admins can insert for othe" ON "public"."n8n_qr_code_history" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "n8n_qr_code_history_select_policy OR Admins can view all" ON "public"."n8n_qr_code_history" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



CREATE POLICY "n8n_qr_code_history_update_policy OR Admins can update for othe" ON "public"."n8n_qr_code_history" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "user_id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



ALTER TABLE "public"."pagbank_charges" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."pagbank_configs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."pending_sends" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."plans" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."profiles" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "profiles_insert_policy OR Admins can insert for others" ON "public"."profiles" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."uid"() = "id") OR (( SELECT "user_roles"."role"
   FROM "public"."user_roles"
  WHERE ("user_roles"."user_id" = "auth"."uid"())) = 'admin'::"public"."app_role")));



ALTER TABLE "public"."scheduled_notifications" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."send_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."subscriber_automations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."subscriber_plans" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."subscriber_templates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."subscriptions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."templates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."url_configs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_instances" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_roles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."webhook_configs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."webhook_history" ENABLE ROW LEVEL SECURITY;




ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";






ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."connection_status";






GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";

















































































































































































GRANT ALL ON FUNCTION "public"."bytea_to_text"("data" "bytea") TO "postgres";
GRANT ALL ON FUNCTION "public"."bytea_to_text"("data" "bytea") TO "anon";
GRANT ALL ON FUNCTION "public"."bytea_to_text"("data" "bytea") TO "authenticated";
GRANT ALL ON FUNCTION "public"."bytea_to_text"("data" "bytea") TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_client_cancellation"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_client_cancellation"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_client_cancellation"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_client_overdue_status"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_client_overdue_status"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_client_overdue_status"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "service_role";



GRANT ALL ON FUNCTION "public"."http"("request" "public"."http_request") TO "postgres";
GRANT ALL ON FUNCTION "public"."http"("request" "public"."http_request") TO "anon";
GRANT ALL ON FUNCTION "public"."http"("request" "public"."http_request") TO "authenticated";
GRANT ALL ON FUNCTION "public"."http"("request" "public"."http_request") TO "service_role";



GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying, "content" character varying, "content_type" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying, "content" character varying, "content_type" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying, "content" character varying, "content_type" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying, "content" character varying, "content_type" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying, "data" "jsonb") TO "postgres";
GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying, "data" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying, "data" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying, "data" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."http_head"("uri" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_head"("uri" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_head"("uri" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_head"("uri" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_header"("field" character varying, "value" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_header"("field" character varying, "value" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_header"("field" character varying, "value" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_header"("field" character varying, "value" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_list_curlopt"() TO "postgres";
GRANT ALL ON FUNCTION "public"."http_list_curlopt"() TO "anon";
GRANT ALL ON FUNCTION "public"."http_list_curlopt"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_list_curlopt"() TO "service_role";



GRANT ALL ON FUNCTION "public"."http_patch"("uri" character varying, "content" character varying, "content_type" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_patch"("uri" character varying, "content" character varying, "content_type" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_patch"("uri" character varying, "content" character varying, "content_type" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_patch"("uri" character varying, "content" character varying, "content_type" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "data" "jsonb") TO "postgres";
GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "data" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "data" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "data" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "content" character varying, "content_type" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "content" character varying, "content_type" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "content" character varying, "content_type" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "content" character varying, "content_type" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_put"("uri" character varying, "content" character varying, "content_type" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_put"("uri" character varying, "content" character varying, "content_type" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_put"("uri" character varying, "content" character varying, "content_type" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_put"("uri" character varying, "content" character varying, "content_type" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_reset_curlopt"() TO "postgres";
GRANT ALL ON FUNCTION "public"."http_reset_curlopt"() TO "anon";
GRANT ALL ON FUNCTION "public"."http_reset_curlopt"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_reset_curlopt"() TO "service_role";



GRANT ALL ON FUNCTION "public"."http_set_curlopt"("curlopt" character varying, "value" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_set_curlopt"("curlopt" character varying, "value" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_set_curlopt"("curlopt" character varying, "value" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_set_curlopt"("curlopt" character varying, "value" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."prevent_default_plan_deletion"() TO "anon";
GRANT ALL ON FUNCTION "public"."prevent_default_plan_deletion"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."prevent_default_plan_deletion"() TO "service_role";



GRANT ALL ON FUNCTION "public"."process_automated_notifications"() TO "anon";
GRANT ALL ON FUNCTION "public"."process_automated_notifications"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_automated_notifications"() TO "service_role";



GRANT ALL ON FUNCTION "public"."process_notification_queue"() TO "anon";
GRANT ALL ON FUNCTION "public"."process_notification_queue"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_notification_queue"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_client_status_based_on_due_date"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_client_status_based_on_due_date"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_client_status_based_on_due_date"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_subscription_status_based_on_plan_and_due_date"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_subscription_status_based_on_plan_and_due_date"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_subscription_status_based_on_plan_and_due_date"() TO "service_role";



GRANT ALL ON FUNCTION "public"."text_to_bytea"("data" "text") TO "postgres";
GRANT ALL ON FUNCTION "public"."text_to_bytea"("data" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."text_to_bytea"("data" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."text_to_bytea"("data" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_templates_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_templates_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_templates_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "service_role";



GRANT ALL ON FUNCTION "public"."urlencode"("string" "bytea") TO "postgres";
GRANT ALL ON FUNCTION "public"."urlencode"("string" "bytea") TO "anon";
GRANT ALL ON FUNCTION "public"."urlencode"("string" "bytea") TO "authenticated";
GRANT ALL ON FUNCTION "public"."urlencode"("string" "bytea") TO "service_role";



GRANT ALL ON FUNCTION "public"."urlencode"("data" "jsonb") TO "postgres";
GRANT ALL ON FUNCTION "public"."urlencode"("data" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."urlencode"("data" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."urlencode"("data" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."urlencode"("string" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."urlencode"("string" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."urlencode"("string" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."urlencode"("string" character varying) TO "service_role";
























GRANT ALL ON TABLE "public"."active_payment_gateway" TO "anon";
GRANT ALL ON TABLE "public"."active_payment_gateway" TO "authenticated";
GRANT ALL ON TABLE "public"."active_payment_gateway" TO "service_role";



GRANT ALL ON TABLE "public"."admin_financial_entries" TO "anon";
GRANT ALL ON TABLE "public"."admin_financial_entries" TO "authenticated";
GRANT ALL ON TABLE "public"."admin_financial_entries" TO "service_role";



GRANT ALL ON TABLE "public"."automations" TO "anon";
GRANT ALL ON TABLE "public"."automations" TO "authenticated";
GRANT ALL ON TABLE "public"."automations" TO "service_role";



GRANT ALL ON TABLE "public"."clients" TO "anon";
GRANT ALL ON TABLE "public"."clients" TO "authenticated";
GRANT ALL ON TABLE "public"."clients" TO "service_role";



GRANT ALL ON TABLE "public"."connection_status" TO "anon";
GRANT ALL ON TABLE "public"."connection_status" TO "authenticated";
GRANT ALL ON TABLE "public"."connection_status" TO "service_role";



GRANT ALL ON TABLE "public"."evolution_api_history" TO "anon";
GRANT ALL ON TABLE "public"."evolution_api_history" TO "authenticated";
GRANT ALL ON TABLE "public"."evolution_api_history" TO "service_role";



GRANT ALL ON TABLE "public"."evolution_logout_history" TO "anon";
GRANT ALL ON TABLE "public"."evolution_logout_history" TO "authenticated";
GRANT ALL ON TABLE "public"."evolution_logout_history" TO "service_role";



GRANT ALL ON TABLE "public"."financial_entries" TO "anon";
GRANT ALL ON TABLE "public"."financial_entries" TO "authenticated";
GRANT ALL ON TABLE "public"."financial_entries" TO "service_role";



GRANT ALL ON TABLE "public"."logs" TO "anon";
GRANT ALL ON TABLE "public"."logs" TO "authenticated";
GRANT ALL ON TABLE "public"."logs" TO "service_role";



GRANT ALL ON TABLE "public"."mercado_pago_charges" TO "anon";
GRANT ALL ON TABLE "public"."mercado_pago_charges" TO "authenticated";
GRANT ALL ON TABLE "public"."mercado_pago_charges" TO "service_role";



GRANT ALL ON TABLE "public"."mercado_pago_configs" TO "anon";
GRANT ALL ON TABLE "public"."mercado_pago_configs" TO "authenticated";
GRANT ALL ON TABLE "public"."mercado_pago_configs" TO "service_role";



GRANT ALL ON TABLE "public"."n8n_message_sender_history" TO "anon";
GRANT ALL ON TABLE "public"."n8n_message_sender_history" TO "authenticated";
GRANT ALL ON TABLE "public"."n8n_message_sender_history" TO "service_role";



GRANT ALL ON TABLE "public"."n8n_qr_code_history" TO "anon";
GRANT ALL ON TABLE "public"."n8n_qr_code_history" TO "authenticated";
GRANT ALL ON TABLE "public"."n8n_qr_code_history" TO "service_role";



GRANT ALL ON TABLE "public"."pagbank_charges" TO "anon";
GRANT ALL ON TABLE "public"."pagbank_charges" TO "authenticated";
GRANT ALL ON TABLE "public"."pagbank_charges" TO "service_role";



GRANT ALL ON TABLE "public"."pagbank_configs" TO "anon";
GRANT ALL ON TABLE "public"."pagbank_configs" TO "authenticated";
GRANT ALL ON TABLE "public"."pagbank_configs" TO "service_role";



GRANT ALL ON TABLE "public"."pending_sends" TO "anon";
GRANT ALL ON TABLE "public"."pending_sends" TO "authenticated";
GRANT ALL ON TABLE "public"."pending_sends" TO "service_role";



GRANT ALL ON TABLE "public"."plans" TO "anon";
GRANT ALL ON TABLE "public"."plans" TO "authenticated";
GRANT ALL ON TABLE "public"."plans" TO "service_role";



GRANT ALL ON TABLE "public"."profiles" TO "anon";
GRANT ALL ON TABLE "public"."profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."profiles" TO "service_role";



GRANT ALL ON TABLE "public"."scheduled_notifications" TO "anon";
GRANT ALL ON TABLE "public"."scheduled_notifications" TO "authenticated";
GRANT ALL ON TABLE "public"."scheduled_notifications" TO "service_role";



GRANT ALL ON TABLE "public"."send_history" TO "anon";
GRANT ALL ON TABLE "public"."send_history" TO "authenticated";
GRANT ALL ON TABLE "public"."send_history" TO "service_role";



GRANT ALL ON TABLE "public"."subscriber_automations" TO "anon";
GRANT ALL ON TABLE "public"."subscriber_automations" TO "authenticated";
GRANT ALL ON TABLE "public"."subscriber_automations" TO "service_role";



GRANT ALL ON TABLE "public"."subscriber_plans" TO "anon";
GRANT ALL ON TABLE "public"."subscriber_plans" TO "authenticated";
GRANT ALL ON TABLE "public"."subscriber_plans" TO "service_role";



GRANT ALL ON TABLE "public"."subscriber_templates" TO "anon";
GRANT ALL ON TABLE "public"."subscriber_templates" TO "authenticated";
GRANT ALL ON TABLE "public"."subscriber_templates" TO "service_role";



GRANT ALL ON TABLE "public"."subscriptions" TO "anon";
GRANT ALL ON TABLE "public"."subscriptions" TO "authenticated";
GRANT ALL ON TABLE "public"."subscriptions" TO "service_role";



GRANT ALL ON TABLE "public"."templates" TO "anon";
GRANT ALL ON TABLE "public"."templates" TO "authenticated";
GRANT ALL ON TABLE "public"."templates" TO "service_role";



GRANT ALL ON TABLE "public"."url_configs" TO "anon";
GRANT ALL ON TABLE "public"."url_configs" TO "authenticated";
GRANT ALL ON TABLE "public"."url_configs" TO "service_role";



GRANT ALL ON TABLE "public"."user_instances" TO "anon";
GRANT ALL ON TABLE "public"."user_instances" TO "authenticated";
GRANT ALL ON TABLE "public"."user_instances" TO "service_role";



GRANT ALL ON TABLE "public"."user_roles" TO "anon";
GRANT ALL ON TABLE "public"."user_roles" TO "authenticated";
GRANT ALL ON TABLE "public"."user_roles" TO "service_role";



GRANT ALL ON TABLE "public"."webhook_configs" TO "anon";
GRANT ALL ON TABLE "public"."webhook_configs" TO "authenticated";
GRANT ALL ON TABLE "public"."webhook_configs" TO "service_role";



GRANT ALL ON TABLE "public"."webhook_history" TO "anon";
GRANT ALL ON TABLE "public"."webhook_history" TO "authenticated";
GRANT ALL ON TABLE "public"."webhook_history" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";































RESET ALL;

